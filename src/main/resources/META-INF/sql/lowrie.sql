/*
Navicat MySQL Data Transfer

Source Server         : localhost_53306
Source Server Version : 50022
Source Host           : localhost:53306
Source Database       : lowrie

Target Server Type    : MYSQL
Target Server Version : 50022
File Encoding         : 65001

Date: 2013-08-07 09:47:50
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for authority
-- ----------------------------
DROP TABLE IF EXISTS `authority`;
CREATE TABLE `authority` (
  `id` int(11) NOT NULL auto_increment,
  `path` varchar(255) default NULL,
  `role_id` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of authority
-- ----------------------------

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` int(11) NOT NULL auto_increment,
  `title` varchar(100) default NULL,
  `content` longtext,
  `tag` varchar(100) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('6', '我是林小生', null, null);
INSERT INTO `blog` VALUES ('7', 'Java给图片添加水印和水印文字', '\n            直接上代码\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileOutputStream;\n\nimport javax.imageio.ImageIO;\n\nimport com.sun.image.codec.jpeg.JPEGCodec;\nimport com.sun.image.codec.jpeg.JPEGImageEncoder;\n\n/**\n * \n * @author Linxs\n *\n */\npublic final class ImageWatermarkHelper {\n\n    public ImageWatermarkHelper() {}\n\n    /**\n     * \n     * @param watermarkPath\n     * @param imagePath\n     * @param x\n     * @param y\n     */\n    public final static void pressImage(String watermarkPath, String imagePath, int x, int y) {\n        try {\n                File targetFile = new File(imagePath);\n                Image targetImage = ImageIO.read(targetFile);\n                int wideth = targetImage.getWidth(null);\n                int height = targetImage.getHeight(null);\n                BufferedImage bufferedImage = new BufferedImage(wideth, height, BufferedImage.TYPE_INT_RGB);\n                Graphics graphics = bufferedImage.createGraphics();\n                graphics.drawImage(targetImage, 0, 0, wideth, height, null);\n\n                File watermarkFile = new File(watermarkPath);\n                Image watermarkImage = ImageIO.read(watermarkFile);\n                int wideth_biao = watermarkImage.getWidth(null);\n                int height_biao = watermarkImage.getHeight(null);\n                graphics.drawImage(watermarkImage, (wideth - wideth_biao) / 2, (height - height_biao) / 2, wideth_biao, height_biao, null);\n                graphics.dispose();\n\n                FileOutputStream fileOutputStream = new FileOutputStream(imagePath);\n                JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(fileOutputStream);\n                encoder.encode(bufferedImage);\n                fileOutputStream.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n    }\n\n    /**\n     * \n     * @param watermarkText\n     * @param imagePath\n     * @param fontName\n     * @param fontStyle\n     * @param color\n     * @param fontSize\n     * @param x\n     * @param y\n     */\n    public static void pressText(String watermarkText, String imagePath, String fontName, int fontStyle, int color, int fontSize, int x, int y) {\n\n        try {\n                File file = new File(imagePath);\n                Image targetImage = ImageIO.read(file);\n                int wideth = targetImage.getWidth(null);\n                int height = targetImage.getHeight(null);\n                BufferedImage image = new BufferedImage(wideth, height, BufferedImage.TYPE_INT_RGB);\n                Graphics graphics = image.createGraphics();\n                graphics.drawImage(targetImage, 0, 0, wideth, height, null);\n                graphics.setColor(Color.RED);\n                graphics.setFont(new Font(fontName, fontStyle, fontSize));\n                graphics.drawString(watermarkText, wideth - fontSize - x, height - fontSize / 2 - y);\n                graphics.dispose();\n                FileOutputStream out = new FileOutputStream(imagePath);\n                JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);\n                encoder.encode(image);\n                out.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n    }\n\n    public static void main(String[] args) {\n        pressImage(&quot;D:\\\\psb.jpg&quot;, &quot;D:\\\\psb (2).jpg&quot;, 0, 0);\n    }\n\n}\n\n        ', null);
INSERT INTO `blog` VALUES ('8', 'web开发中的各种4X错误', '\n            4 请求失败4xx 4xx应答定义了特定服务器响应的请求失败的情况。客户端不应当在不更改请求的情况下重新尝试同一个请求。（例如，增加合适的认证信息）。不过，同一个请求交给不同服务器也许就会成功。 4.1 400 Bad Request 请求中的语法错误。Reason-Phrase应当标志这个详细的语法错误，比如”Missing Call-ID header field”。 4.2 401 Unauthorized 请求需要用户认证。这个应答是由UAS和注册服务器产生的，当407（Proxy Authentication Required）是proxy服务器产生的。 4.3 402 Payment Required 保留/以后使用 4.4 403 Forbidden 服务端支持这个请求，但是拒绝执行请求。增加验证信息是没有必要的，并且请求应当不被重试。 4.5 404 Not Found 服务器返回最终信息：用户在Request-URI指定的域上不存在。当Request-URI的domain和接收这个请求的domain不匹配的情况下， 也会产生这个应答。 4.6 405 Method Not Allowed 服务器支持Request-Line中的方法，但是对于这个Request-URI中的地址来说，是不允许应用这个方法的。 应答必须包括一个Allow头域，这个头域包含了指定地址允许的方法列表。 4.7 Not Acceptable 请求中的资源只会导致产生一个在请求中的Accept头域外的，内容无法接收的错误。 4.8 407 Proxy Authentication Required 这个返回码和401（Unauthorized）很类四，但是标志了客户端应当首先在proxy上通过认证。SIP对认证的访问请参见26节和22.3节。 这个返回码用于应用程序访问通讯网关（比如，电话网关），而很少用于被叫方要求认证。 4.9 408 Request Timeout 在一段时间内，服务器不能产生一个终结应答，例如，如果它无法及时决定用户的位置。客户端可以在稍后不更改请求的内容然后重新尝试请求。 4.10 410 Gone 请求的资源在本服务器上已经不存在了，并且不知道应当把请求转发到哪里。这个问题将会使永久性的。如果服务器不知道，或者不容易检测，这个资源消失是临时性质的还是永久性质的，那么应当返回一个404（Not Found）。 4.11 413请求实体过大。 服务器拒绝处理请求，因为这个请求的实体超过了服务器希望或者能够处理的大小。这个服务器应当关闭连接避免客户端重发这个请求。 如果这个情况是暂时的，那么服务端应当包含一个Retry-After头域来表明这是一个暂时的故障，并且客户端可以过一段时间再次尝试。 4.12 414 Request-URI Too Long 服务器拒绝这个请求，因为Request-URI超过了服务器能够处理的长度。 4.13 415 Unsupported Media Type 服务器由于请求的消息体的格式本服务器不支持，所以拒绝处理这个请求。这个服务器必须根据内容的故障类型，返回一个Accept，Accpet-Encoding,或者Accept-Language头域列表。UAC根据8.1.3.5节定义的方法处理这个应答。 4.14 416 Unsupported URI Scheme 服务器由于不支持Request-URI中的URI方案而终止处理这个请求。客户端处理这个应答参照8.1.3.5。 4.15 Bad Extension 服务器不知道在请求中的Proxy-Require(20.29)或者Require(20.32)头域所指出的协议扩展。服务器必须在Unsupported头域中列出不支持的扩展。UAC处理这个应答请参见8.1.3.5 4.16 421Extension Required UAS需要特定的扩展来处理这个请求，但是这个扩展并没有在请求的Supported头域中列出。具有这个应答码的应答必须包含一个Require头域列出所需要的扩展。 UAS不应当使用这个应答除非它真的不能给客户端提供有效的服务。相反，如果在Support头域中没有列出需要的扩展，服务器应当根据基准的SIP兼容的方法和客户端支持的扩展来进行处理。 4.17 423 Interval Too Brief 服务器因为在请求中设置的资源刷新时间（或者有效时间）过短而拒绝请求。这个应答可以用于注册服务器来拒绝那些Contact头域有效期过短的注册请求。这个应答的用法和相关的Min-Expires头域在10.2.8,10.3,20.23节中介绍和说明。 4.18 480 Temporarily Unavailable 请 求成功到达被叫方的终端系统，但是被叫方当前不可用（例如，没有登陆，或者登陆了但是状态是不能通讯，或者有”请勿打扰”的标记）。应答应当在Retry -After中标志一个合适的重发时间。这个用户也有可能在其他地方是有效的（在本服务器中不知道）。Reason-Phrase(原因短句)应当提示更 详细的原因，为什么被叫方暂时不可用。这个值应当是可以被UA设置的。状态码486（Busy Here）可以用来更精确的表示本请求失败的特定原因。 这个状态码也可以是转发服务或者proxy服务器返回的，因为他们发现Request-URI指定的用户存在，但是没有一个给这个用户的合适的当前转发的地址。 4.19 481 Call/Transaction Does Not Exist 这个状态表示了UAS接收到请求，但是没有和现存的对话或者事务匹配。 4.20 482 Loop Detected 服务器检测到了一个循环(16.3/4) 4.21 483 Too Many Hops 服务器接收到了一个请求包含的Max-Forwards(20.22)头域是0 4.22 484 Address InComplete 服 务器接收到了一个请求，它的Request-URI是不完整的。在原因短语中应当有附加的信息说明。这个状态码可以和拨号交叠。在和拨号交叠中，客户端不 知道拨号串的长度。它发送增加长度的字串，并且提示用户输入更多的字串，直到不在出现484（Address Incomplete）应答为止。 4.23 485 Ambiguous Request -URI是不明确的。应答可以在Contact头域中包含一个可能的明确的地址列表。这个提示列表肯囊个在安全性和隐私性对用户或者组织造成破坏。必须能 够由配置决定是否以404（NotFound）代替这个应答，又或者禁止对不明确的地址使用可能的选择列表。 给带有Request-URI的请求的一个应答例子： sip: lee@example.com: SIP/2.0 485 Ambiguous Contact: Carol Lee Contact: Ping Lee Contact: Lee M.Foote 部分email和语音邮箱系统提供了这个功能。这个状态码和3xx状态码不同：对于300来说，它是假定同一个人或者服务有不同的地址选择。所以对3xx来说，自动选择系统或者连续查找就有效，但是对485（Ambiguous）应答来说，一定要用户的干预。 4.24 486 Busy Here 当 成功联系到被叫方的终端系统，但是被叫方当前在这个终端系统上不能接听这个电话，那么应答应当回给呼叫方一个更合适的时间在Retry-After头域重 试。这个用户也许在其他地方有效，比如电话邮箱系统等等。如果我们知道没有其他终端系统能够接听这个呼叫，那么应当返回一个状态码600（Busy Everywhere）。 4.25 487 Request Terminated 请求被BYE或者CANCEL所终止。这个应答永远不会给CANCEL请求本身回复。 4.26 488 Not Acceptable Here 这个应答和606（Not Acceptable）有相同的含义，但是只是应用于Request-URI所指出的特定资源不能接受，在其他地方请求可能可以接受。 包含了媒体兼容性描述的消息体可以出现在应答中，并且根据INVITE请求中的Accept头域进行规格化（如果没有Accept头域，那么就是application/sdp）。这个应答就像给OPTIONS请求的200(OK)应答的消息体一样。 4.27 491 Request Pending 在同一个对话中，UAS接收到的请求有一个依赖的请求正在处理。14.2描述了这种情况应当怎样解决。 4.28 493 Undecipherable UAS接收到了一个请求，包含了一个加密的MIME,并且不知道或者没有提供合适的解密密钥。这个应答可以包含单个包体，这个包体包含了合适的公钥，这个公钥用于给这个UAS通讯中加密包体使用的。\n        ', null);
INSERT INTO `blog` VALUES ('9', 'nginx+jetty 簡單學習', '\n            Jason: \n\n \n  nginx+jetty 簡單學習nginx乃是高效率高穩定性的輕量級服務器；jetty和java、maven兼容比較好，相對輕量，個人比較喜歡；\n  jetty簡單配置\n  \n   下載jetty-8.1.11 &nbsp;解壓；&nbsp;\n   清理不想要的東西，當然你不進行這一步也行，不過我看不過眼，呵呵!比如webapps目錄下的例子，幹掉；javadoc裏面的東西幹掉；contexts目錄的東西幹掉；\n   配置admin項目工程，在contexts目錄下建立admin.xml，內容如下（主要中文註釋的地方）：&lt;?xml version=&quot;1.0&quot;  encoding=&quot;ISO-8859-1&quot;?&gt;\n&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;http://www.eclipse.org/jetty/configure.dtd&quot;&gt;\n                                                                                                                                    \n&lt;Configure class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt;\n                                                                                                                     \n  &lt;Set name=&quot;contextPath&quot;&gt;/&lt;/Set&gt;&lt;!--域名訪問路徑--&gt;\n  &lt;Set name=&quot;war&quot;&gt;D:/nginx/project/admin&lt;/Set&gt;&lt;!--項目路徑；也可以直接war文件--&gt;\n                                                                                                                                      \n                                                                                                                                    \n  &lt;!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --&gt;\n  &lt;!-- Optional context configuration                                  --&gt;\n  &lt;!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --&gt;\n  &lt;Set name=&quot;extractWAR&quot;&gt;true&lt;/Set&gt;\n  &lt;Set name=&quot;copyWebDir&quot;&gt;false&lt;/Set&gt;\n  &lt;Set name=&quot;defaultsDescriptor&quot;&gt;&lt;SystemProperty name=&quot;jetty.home&quot; default=&quot;.&quot;/&gt;/etc/webdefault.xml&lt;/Set&gt;\n  &lt;!--&lt;Set name=&quot;overrideDescriptor&quot;&gt;&lt;SystemProperty name=&quot;jetty.home&quot; default=&quot;.&quot;/&gt;/contexts/test.d/override-web.xml&lt;/Set&gt;--&gt;\n                                                                                                                                    \n  &lt;!-- virtual hosts --&gt;\n  &lt;Set name=&quot;virtualHosts&quot;&gt;\n    &lt;Array type=&quot;String&quot;&gt;\n      &lt;Item&gt;localhost&lt;/Item&gt;&lt;Item&gt;admin.jasonsoso.com&lt;/Item&gt; &lt;!-- 虛擬域名 你可以用admin.jasonsoso.com:8080或者localhost：8080來訪問--&gt;       \n    &lt;/Array&gt;\n  &lt;/Set&gt;\n                                                                                                                                    \n  &lt;Get name=&quot;securityHandler&quot;&gt;\n    &lt;Set name=&quot;loginService&quot;&gt;\n      &lt;New class=&quot;org.eclipse.jetty.security.HashLoginService&quot;&gt;\n        &lt;Set name=&quot;name&quot;&gt;Test Realm&lt;/Set&gt;\n        &lt;Set name=&quot;config&quot;&gt;&lt;SystemProperty name=&quot;jetty.home&quot; default=&quot;.&quot;/&gt;/etc/realm.properties&lt;/Set&gt;\n            &lt;!-- To enable reload of realm when properties change, uncomment the following lines --&gt;\n            &lt;!-- changing refreshInterval (in seconds) as desired                                --&gt;\n            &lt;!-- \n            &lt;Set name=&quot;refreshInterval&quot;&gt;5&lt;/Set&gt;\n            &lt;Call name=&quot;start&quot;&gt;&lt;/Call&gt;\n            --&gt;\n      &lt;/New&gt;\n    &lt;/Set&gt;\n    &lt;Set name=&quot;authenticator&quot;&gt;\n      &lt;New class=&quot;org.eclipse.jetty.security.authentication.FormAuthenticator&quot;&gt;\n        &lt;Set name=&quot;alwaysSaveUri&quot;&gt;true&lt;/Set&gt;\n      &lt;/New&gt;\n    &lt;/Set&gt;\n    &lt;Set name=&quot;checkWelcomeFiles&quot;&gt;true&lt;/Set&gt;\n  &lt;/Get&gt;\n                                                                                                                                      \n                                                                                                                                    \n&lt;/Configure&gt;這樣的話，admin.jasonsoso.com:8080或者localhost：8080來訪問你的應用程式；\n    如果你想一個jetty運行多個應用程式，比如sso項目，則sso.xml，則複製上面的內容，修改部份內容就行，主要修改如下內容:&lt;Set name=&quot;contextPath&quot;&gt;/&lt;/Set&gt;\n &lt;Set name=&quot;war&quot;&gt;D:/nginx/project/sso&lt;/Set&gt; &lt;!--項目路徑 可以指向war包--&gt;\n                                                                                           \n &lt;!-- virtual hosts --&gt;\n &lt;Set name=&quot;virtualHosts&quot;&gt;\n   &lt;Array type=&quot;String&quot;&gt;\n     &lt;Item&gt;sso.jasonsoso.com&lt;/Item&gt;  &lt;!-- sso.jasonsoso.com:8080 訪問此工程--&gt;\n     &lt;Item&gt;localhost&lt;/Item&gt;\n   &lt;/Array&gt;\n &lt;/Set&gt;這樣的話，admin.jasonsoso.com:8080訪問admin工程，而sso.jasonsoso.com:8080可訪問sso工程；見證歷史時刻：&nbsp;\n   記錄jetty的簡單命令#jetty目錄下執行：\njava -jar start.jar #啟動 不過我還是喜歡下面的\n                                                                         \n./bin/jetty.sh start #啟動\n./bin/jetty.sh stop  \n./bin/jetty.sh restart #重啟&nbsp;\n  \n \n \n  兩個二級域名分別指向兩個應用，則用nginx代理，更不想看到8080端口在nginx.conf 添加include語句:#user  nobody;\nworker_processes  1;\n                                                     \n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n                                                     \n#pid        logs/nginx.pid;\n                                                     \nevents {\n    worker_connections  1024;\n}\n                                                     \nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n                                                     \n    sendfile        on;\n                                                     \n    keepalive_timeout  65;\n                                                     \n    include jasonsoso/*.conf;\n}&nbsp;建立目錄jasonsoso存放配置文件，在這裡連個應用則用兩個文件其中有admin.conf文件:upstream admin.jasonsoso.com{\n    server 127.0.0.1:8080;  #這裡可以做負載均衡的東西，暫時沒\n}\n                                               \nserver {\n    listen       80;\n    server_name  admin.jasonsoso.com;  #域名\n    location / {\n    proxy_pass http://admin.jasonsoso.com;    #指向upstream admin.jasonsoso.com\n    }\n}其中有sso.conf文件：upstream sso.jasonsoso.com{\n    server 127.0.0.1:8080;\n}\n                                              \nserver {\n    listen       80;\n    server_name  sso.jasonsoso.com;   #域名\n    location / {\n    proxy_pass http://sso.jasonsoso.com;   #指向upstream sso.jasonsoso.com \n    }\n}這樣子的話，admin.jasonsoso.com 和 sso.jasonsoso.com 就擺脫端口的困擾，直接分別訪問對應的兩個工程，歷史見證時刻到了：nginx命令記錄：nginx -s reload #優雅的重啟\nnginx -s stop  #停止&nbsp;\n \n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n \n  nginx簡單集群\n  worker_processes  1;        \nevents {        \n    worker_connections  1024;        \n}        \n                                                                                                                                                                                                    \n                                                                                                                                                                                                    \nhttp {        \n    include       mime.types;        \n    default_type  application/octet-stream;        \n                                                                                                                                                                                                    \n    sendfile        on;        \n    keepalive_timeout  65;        \n                                                                                                                                                                                                    \n    upstream  www.g.cn {          \n       server   localhost:8080;     #中間件服務8080端口\n       server   localhost:9090;     #中間件服務8090端口\n     }        \n                                                                                                                                                                                                    \n    server {        \n        listen       80;        \n        server_name  localhost;        \n                                                                                                                                                                                                    \n        location / {        \n            proxy_pass http://www.g.cn; #指向upstream  \n            proxy_redirect default;        \n        #root   html;        \n            #index  index.html index.htm;        \n        }        \n                                                                                                                                                                                                        \n        error_page   500 502 503 504  /50x.html;        \n        location = /50x.html {        \n            root   html;        \n        }        \n    }\n  這樣的話方法http://localhost 或者 http://www.g.cn(host需要指向一下) &nbsp;就可以訪問同一個應用：localhost:8080 和 localhost:9090\n  &nbsp;\n  &nbsp;\n  &nbsp;\n   以上多謝朋友HK指導！特此鳴謝! &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n \n\n        ', null);
INSERT INTO `blog` VALUES ('10', '使用 Sonar 进行代码质量管理', '\n            Jason: \n\n \n  Sonar简介：本文将介绍代码质量管理平台 Sonar 的搭建和使用。简单使用 Maven 插件方便地进行代码质量管理。对传统的pmd、findbugs等工具进行整合，目前为最强大的代码质量管理工具之一。\n  Sonar安装：\n  \n   访问Sonar主网站 进行下载，我下载的是sonar-3.5.1.zip ；\n   下载后解压，直接双击sonar-3.5.1\\bin\\windows-x86-64\\StartSonar.bat 进行启动，现在在window下面跑；默认jetty服务器；\n   然后直接访问http://192.168.1.102:9000 就OK。&nbsp;\n  \n  安装插件\n  \n   安装插件，以Quality Index Plugin为例子，访问Plugin Library 点击Quality Index，进行下载 ；\n   下载后sonar-quality-index-plugin-1.1.3.jar 放在sonar-3.5.1\\extensions\\plugins目录下，重启服务器\n  \n  &nbsp;\n  数据库设置\n  \n   貌似数据库默认是database H2，现在修改为mysql；\n   创建数据库sonar 用户名root 密码123456；\n   修改配置文件 修改为：修改后重启服务器；#----- Credentials\n# Permissions to create tables and indexes must be granted to JDBC user.\n# The schema must be created first.\nsonar.jdbc.username:                       root\nsonar.jdbc.password:                       123456\n                                \n#----- Embedded database H2\n# Note : it does not accept connections from remote hosts, so the\n# sonar server and the maven plugin must be executed on the same host.\n                                  \n# Comment the following line to deactivate the default embedded database.\n# sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar\n#sonar.jdbc.driverClassName:                org.h2.Driver\n                                \n# directory containing H2 database files. By default it\'s the /data directory in the sonar installation.\n#sonar.embeddedDatabase.dataDir:\n# H2 embedded database server listening port, defaults to 9092\n#sonar.embeddedDatabase.port:               9092\n                                \n                                \n#----- MySQL 5.x\n# Comment the embedded database and uncomment the following line to use MySQL\nsonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true\n                                \n# Optional properties\nsonar.jdbc.driverClassName:                com.mysql.jdbc.Driver&nbsp;\n  \n  Maven 插件进行代码质量管理\n  \n   Maven中的settings.xml配置如下&lt;settings&gt;\n    &lt;profiles&gt;\n        &lt;profile&gt;\n            &lt;id&gt;sonar&lt;/id&gt;\n            &lt;activation&gt;\n                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n            &lt;/activation&gt;\n            &lt;properties&gt;\n                &lt;!-- EXAMPLE FOR MYSQL --&gt;\n                &lt;sonar.jdbc.url&gt;\n                  jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8\n                &lt;/sonar.jdbc.url&gt;\n                &lt;sonar.jdbc.driverClassName&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driverClassName&gt;\n                &lt;sonar.jdbc.username&gt;root&lt;/sonar.jdbc.username&gt;\n                &lt;sonar.jdbc.password&gt;123456&lt;/sonar.jdbc.password&gt;\n                          \n                &lt;!-- optional URL to server. Default value is http://localhost:9000 --&gt;\n                &lt;sonar.host.url&gt;http://192.168.1.102:9000/&lt;/sonar.host.url&gt;\n            &lt;/properties&gt;\n        &lt;/profile&gt;\n     &lt;/profiles&gt;\n&lt;/settings&gt;&nbsp;\n   编译如下：mvn clean install\nmvn sonar:sonar\n   则将 Soanr 所需要的数据上传到 Sonar 服务器上之后，Sonar 安装的插件会对这些数据进行分析和处理，并以各种方式显示给用户，从而使用户方便地对代码质量的监测和管理。如图：\n  \n \n\n        ', null);
INSERT INTO `blog` VALUES ('11', '关于IE6下jquery属性定位的bug记录', '\n            function addValue() {\n            var keyId = $(this).attr(&quot;name&quot;);\n            screeningValueAddNumber = screeningValueAddNumber + 1;\n            var currentIndex = $(this).attr(&quot;name&quot;);\n            var html = &quot;&quot;;\n            html = html.concat(&quot;&lt;li class=\'property\' lang=\'&quot; + screeningValueAddNumber + &quot;\' style=\'clear: both;\'&gt;&quot;)\n                       .concat(&quot;&lt;div class=\'quality_01\'&gt;&quot;)\n                       .concat(&quot;&lt;span&gt;&lt;a href=\'#\' name=\'&quot; + screeningValueAddNumber + &quot;\' class=\'decrease\'&gt;&lt;/a&gt;&quot;)\n                       .concat(&quot;&lt;/span&gt;&quot;)\n                       .concat(&quot;&lt;input name=\'&quot;+ keyId +&quot;\' type=\'text\' alt=\'&quot; + keyId + &quot;\' class=\'value quality1_text\' value=\'\'&gt;&quot;)\n                       .concat(&quot;&lt;/div&gt;&quot;)\n                       .concat(&quot;&lt;/li&gt;&quot;);\n                                          \n            $(&quot;.valueContent[name=\'&quot;+ currentIndex +&quot;\']&quot;).after(html);\n        };\n今天用IE6黑盒测试了自己手头的项目，发现在分类管理里面修改用Jquery动态生成的标签的时候，添加标签和删除标签都失效了，一步步断点调试后发现问题出在第14行代码上，无法定位到一个&lt;ul class=\'valueContent\' name=\'2\' &gt;这样的一个标签上，刚开始以为是IE下无法用JQuery的属性定位，结果试着定位其他标签却又可以，百度谷歌了一堆后发现问题依旧没解决，突然怀疑是name属性的问题，在生成这个UL标签的时候，把本来写着name这个属性的改为lang，清空浏览器缓存，再次尝试，问题解决，谷歌了下关于IE6的name属性后才知道，原来IE6有一个name属性的定位bug，到IE8才被修复。记录完毕，真心恶心IE6，可项目需求却必须要兼容IE6，唉。。。\n        ', null);
INSERT INTO `blog` VALUES ('12', '重装系统后恢复ubuntu启动项', '\n            一、重装xp后恢复Ubuntu启动项（用wubi安装的Ubuntu） \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把安装ubuntu-&gt;winboot文件夹下wubidr和wubidr.mbr两个文件拷到C盘根目录下，然后用记事本打开c盘下的boot.ini，在最后一行加入c:/wubildr.mbr=&quot;Ubuntu&quot;就可以了，然后保存重启。ubuntu启动项出来了！！！ \n二、Vista或windows7下恢复Ubuntu启动项（用wubi安装的Ubuntu）\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows7（vista）没有boot.ini文件,所以上面的方法不适用,可以用bcdedit来添加： \n &nbsp;&nbsp;&nbsp;1&gt;把安装ubuntu-&gt;winboot文件夹下wubidr和wubidr.mbr两个文件拷到C盘根目录下 \n &nbsp;&nbsp;&nbsp;2&gt;在“运行”中输入cmd到命令提示\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令界面bcdedit /create /d &quot;ubuntu&quot; /application bootsector\n &nbsp;&nbsp;&nbsp;得到多启动菜单上显示的名字项 {dbff544b-a7c4-11dd-a51d-00155803ebb4} 成功创建。 \n &nbsp;&nbsp;&nbsp;3&gt;把{}中的id复制下来，如：dbff544b-a7c4-11dd-a51d-00155803ebb4 \n &nbsp;&nbsp;&nbsp;4&gt;再依次输入下列命令 &nbsp;（注意：自己替换下面{}中的id为第2步得到的id）\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcdedit /set {id} device partition=c:\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcdedit /set {id} path \\wubildr.mbr\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcdedit /set {id} description &quot;Ubuntu&quot;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcdedit /displayorder {id} /addlast\n &nbsp;注意啦，别把空格省略了哦，重启后就可以看到久违的ubuntu启动项了。\n        ', null);
INSERT INTO `blog` VALUES ('13', '2012-01-30', '\n            我是卢小明: \n\n 转眼，12年就过去了。\n 先用几句话总结下自己，然后发发牢骚。\n 用一句话总结下自己吧：\n 依旧一贫如洗。\n &nbsp;\n 12年是个很神奇的年份，传说的世界末日没到来，传说的发奖金也没发。\n 12年碰到了一些神奇的人物，或者说，经过本人深刻的观察，发现是个神奇人物。\n 神奇人物之一，某IT公司神级产品经理，江湖人称向日葵（想看庐山真面目吗？请汇款至xxx）。\n 此君有两门绝技，且听我一一道来：\n 绝技一：交换一个思想，于是我有一个思想，你也还是只有一个思想。请看流程图：\n \n 场景：\n 1.boss来到之前：\n 向日葵：各位对xxx项目有没什么好的想法。\n 路人甲：我觉得xxxx，然后xxx。\n 酱油乙：我觉得xxxx，我们应该xxxx。\n 向日葵沉默不语，用母亲般的眼神静静的看着这群孩子。\n 2.boss到来：\n 向日葵：xxx总，我觉得这个项目xxxx，我们应该xxxx。\n boss：向日葵果然是专家！！！\n 从以上的例子，我突然发现，向日葵其实精通设计模式。\n 与此同时，告诉我们一个道理：沉默乃金也。\n &nbsp;\n 绝技二：everything is four page,and everything is b2b。\n 我上学那会，有一天在课堂突然听我们的老师说了句：everything is object。\n 那会，可谓醍醐灌顶，高，实在是高。\n 而向日葵，又给我上了一课，其洞悉能力以及抽象能力可见一斑。\n 那什么是four page呢？\n 说白了，世间万物就是4个页面：index,search,category,detail。\n 那什么是everything is b2b呢？\n 别误会，这可不是变二B的意思。\n 只是说，所有的软件应用只要通过b2b平台稍微改变即可得来。\n 好像表达式变型一样，一变，世界就洞悉了，世界就通透了。\n &nbsp;\n 在这里，再多言语实在也无法表达我的敬仰之心。\n 那些竞争对手们，一定要感谢向日葵，正是因为他，某公司才能做不大。\n 向日葵，我觉得干啥都行，就是干不得产品经理。\n 或者，凡人已无法理解向日葵的思维。\n （灯管打起，音乐响起，请诸君听我唱首：法海你不懂爱）\n &nbsp;\n 神奇人物二：啊？不用我说了吧。你们懂的。\n\n        ', null);
INSERT INTO `blog` VALUES ('14', 'Ubuntu 12.4 环境搭建', '\n            Jason: \n\n unbunt 12.4安装环境 记之！\n \n \n  nginx安装：sudo apt-get install nginx常用命令：sudo /etc/init.d/nginx start //启动\nsudo /etc/init.d/nginx reload //重载\nsudo /etc/init.d/nginx stop //停止\nsudo /etc/init.d/nginx restart //重启访问测试：http://localhost/ 或者 你的IP \n  java安装：vi /etc/apt/sources.list  //添加以下源 找你真辛苦\ndeb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse\n                                                                     \nsudo apt-get update //更新apt源\n                                                                     \nsudo apt-get install sun-java6-jdk //安装\n                                                                     \n提示：安装过程中需要你回答是否同意使用协议（终端中红蓝色的提示界面），此时按tab键至OK，再按回车即可正常安装测试是否搞定:\n  mysql安装：sudo apt-get install php5-cli php5-cgi mysql-server php5-mysql测试：\n  git安装：sudo apt-get install git&nbsp;\n  maven安装：sudo apt-get install  maven测试：\n  mongodb安装：sudo apt-get install mongodb检验：\n  其他\n \n\n        ', null);
INSERT INTO `blog` VALUES ('15', 'MongoDB学习(二、安装)', '\n            Jason: \n\n \n &nbsp;\n \n  认住MongoDB！NB东西！\n  去官方 下载解压\n  解压后，创建默认的日志存放处\n  启动\n  登陆试试\n  设置权限\n  系统已启动就启动mongoDB \n  Oh! My God! Over!\n \n\n        ', null);
INSERT INTO `blog` VALUES ('16', 'MongoDB学习(二、JavaClient)', '\n            Jason: \n\n \n  连接MongoDBpublic static DB connect() {\n        // 获得数据库连接\n        Mongo mongo;\n        DB db = null;\n        try {\n            mongo = new Mongo(&quot;192.168.31.130&quot;, 27017);\n            db = mongo.getDB(&quot;mydb&quot;);\n            System.out.println(&quot;实例的IP地址:&quot; + mongo.getAddress() + &quot; 列出所有数据库：&quot;\n                    + mongo.getDatabaseNames());\n            // 授权 账号密码\n            // boolean b = db.authenticate(&quot;uid&quot;, &quot;pwd&quot;.toCharArray());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (MongoException e) {\n            e.printStackTrace();\n        }\n        return db;\n    }&nbsp;&nbsp;\n  插入数据public void insert() {\n        DB db = MongoTest.connect();\n        DBCollection collection = db.getCollection(&quot;c1&quot;);\n        BasicDBObject doc = new BasicDBObject();\n        doc.put(&quot;name&quot;, &quot;jason&quot;);\n        doc.put(&quot;sex&quot;, &quot;women&quot;);\n        doc.put(&quot;count&quot;, 1);\n     \n        BasicDBObject info = new BasicDBObject();\n        info.put(&quot;x&quot;, 123);\n        info.put(&quot;y&quot;, 234);\n     \n        doc.put(&quot;info&quot;, info);\n     \n        collection.insert(doc);// 数据库持久化到磁盘上\n        System.out.println(&quot;insert ok&quot;);\n    }&nbsp;\n  查找一条数据public void findOne() {\n        DB db = MongoTest.connect();\n        DBCollection collection = db.getCollection(&quot;c1&quot;);\n        DBObject doc = collection.findOne();\n        System.out.println(doc);\n    }&nbsp;\n  更新public void update() {\n        DB db = MongoTest.connect();\n        DBCollection collection = db.getCollection(&quot;c1&quot;);\n  \n        db.requestStart();// 开始事务控制\n  \n        // 业务逻辑 只有 同时成功 和 同时回滚\n        DBObject updateCondition = new BasicDBObject();\n        updateCondition.put(&quot;name&quot;, &quot;jason&quot;);\n  \n        DBObject updateValue = new BasicDBObject();\n        updateValue.put(&quot;sex&quot;, &quot;man&quot;);\n  \n        DBObject updateSetValue = new BasicDBObject(&quot;$set&quot;, updateValue);\n        collection.update(updateCondition, updateSetValue);\n  \n        db.requestDone();// 结束事务控制\n        System.out.println(&quot;update ok&quot;);\n    }&nbsp;&nbsp;\n \n\n        ', null);
INSERT INTO `blog` VALUES ('17', 'intellij IDEA快捷键', '\n            1. Ctrl + Space\n完成类、方法、变量名称的自动输入\n2. Ctrl + N（Ctrl + Shift + N）\n跳转到指定的java文件（其它文件）\n3. Ctrl + B\n跳转到定义处\n4. Ctrl + Alt + T\n用if、while、try catch来围绕选中的代码行\n5. Ctrl + Alt + B\n跳转到方法实现处\n6. Ctrl + W\n按一个word来进行选择操作,在IDEA里的这个快捷键功能是先选择光标所在字符处的单词，然后是选择源\n代码的扩展区域。\n7. Shift + F1\n在浏览器中显示指定的java docs\n8. Ctrl + Q\n在editor window中显示java docs这个功能很方便--因为有时仅仅是忘记了自己编写的方法中的某个参数的含义，此时又不想再起一个浏览器来查看java doc，此时这个功能的好处就体现出来了\n9. Ctrl + /\n注释/反注释指定的语句,你也可以用Ctrl + Shift + / 来进行多行语句的注释（即使用多行注释符号&quot;/* ... */&quot;）\n10. F2/Shift + F2\n跳转到下/上一个错误语句处\n11. Shift + F6\n提供对方法、变量的重命名\n12. Ctrl + Alt + L\n根据模板格式化选择的代码,是只对java文件有效13. Ctrl + Alt + I\n将选中的代码进行自动缩进编排,这个功能在编辑jsp文件的时候也可以工作，\n提供了一个对Ctrl + Alt + L功能的补充。\n14. Ctrl + Alt + O\n优化import自动去除无用的import语句\n15. Ctrl + ]/[\n跳转到代码块结束/开始处\n16.Ctrl+E\n显示最近编辑的文件列表\n17.Shift+Click\n关闭文件\n18.Ctrl+Shift+Backspace\n跳转到上次编辑的地方\n19.Ctrl+F12\n显示当前文件的结构\n20.Ctrl+F7\n查询当前元素在当前文件中的引用，然后按F3可以选择\n21.Ctrl+Shift+N\n快速打开文件\n22.Alt+Q\n看到当前方法的声明\n23.Ctrl+P\n显示参数信息\n25.Alt+Insert\n生成构造器/Getter/Setter等\n26.Ctrl+Alt+V\n引入变量。例如把括号内的SQL赋成一个变量\n27.Alt+Up and Alt+Down\n可在方法间快速移动\n下面的不是很有用\n28.Alt+Enter\n得到一些Intention Action，例如将”==”改为”equals()”\n29.Ctrl+Shift+Alt+N\n可以快速打开符号\n30.Ctrl+Shift+Space\n在很多时候都能够给出Smart提示\n31.Alt+F3\n可以快速寻找\n32.Ctrl+O\n可以选择父类的方法进行重写\n33.Ctrl+Alt+Space\n是类名自动完成\n34. Ctrl+J\nLive Templates!\n35.Ctrl+Shift+F7\n可以高亮当前元素在当前文件中的使用\n30.Ctrl+Alt+Up /Ctrl+Alt+Down\n可以快速跳转搜索结果\n31.Ctrl+Shift+J\n可以整合两行\n32.Alt+F8是计算变量值\nCtrl+D 复制上一行或复制选定\nCtrl+Alt+L 格式化代码\nAlt+Shift+Insert 列编辑\n装上UpperLowerCapitalize后\nAlt+P // to uppercase\nAlt+L // to lowercase\nAlt+C // 首字母大写\n你可以在Option--Keymaps中修改设置成你的习惯键位组合。\n        ', null);
INSERT INTO `blog` VALUES ('18', '谈谈对程序员的培养（转自四火的BLOG）', '\n            \n \n\n这篇文字是我好久以来的想法，有一些感悟，有一些激烈的言辞，我很自豪我就是一名程序员，我希望给程序员或者前程序员们带来一点启发。也许你认可我的言辞，也许你不屑我的观点，无论如何，欢迎谈谈你的看法。\n&nbsp;\n让程序员做更多种类的事\n为什么有人说小公司锻炼人？在小公司，条件并不那么齐备，很多事情都需要程序员自己做，自己去澄清需求、自己做设计、自己搭建环境、自己测试，甚至自己上线、自己维护（这件事情在我们团队被称为“自己吃自己狗食”）。\n然而到了某些公司，在一些正规的流程下，“人”反而显得不那么重要了：一个完、整的流程被切分成若干环节，程序员只能负责那小小的一环，更严重的是，他们显示出消极和片面的情绪，他们称自己码农，自嘲并且觉得在总做一些低级和毫无技术含量的事情。\n&nbsp;\n关于“码农”——这似乎是一件很悲哀的事情，在美国，程序员是一个相当值得尊敬的行业，去年硅谷的技术员工年薪平均已经超过10万美元；在中国，教师的行业起码获得了人们口头上的尊敬（虽然实质上也许并没有获得应有的待遇），而程序员，往往只能看到自己给自己呐喊。\n这里没有绝对的对错之分，但我一直在博客中强调软件开发实质是一种创造性的劳动，只是在一个流程严格控制的公司内，这样的创造的火花可能被扼杀，换来的好处是人员的流动中，代价最小化：谁都可以走、谁都可以代替谁，所有问题都被认为只是时间问题……那么，程序员，你的自我价值何在呢？\n&nbsp;\n关于测试\n我听到很多真实的声音，都在抱怨测试工作乏味、加班辛苦。我认为，国内大部分的测试，其实完全是程序员扭曲的工作形态导致的。\n专职的测试人员去做专项测试、整个系统的集成测试等等，我都能理解，但是绝对不应当深入模块内部去测试开发人员的代码，绝对不应该去考虑所谓的代码覆盖率——因为这些，比如白盒测试，本都是程序员自己该完成的事情。程序员自己开发的程序，当然要自己验证功能，很多软件公司在一些项目流程里就是没有专职测试介入测试执行，原因很简单，难道自己拉了稀，让别人给你擦屁股？\n另一方面，测试该掌握哪些技能？\n我见过许多测试人员，他们抱怨工作总是被轻视，没有说话的分量，但是每天的工作就是了解开发的流程，根据流程完成用例的编写，然后执行那些用例，发现bug并填写bug report。如果一名测试只需要做这些事情，那么确实太没有技术含量了、太没有入门门槛了，太单调乏味了。\n测试需要成长，既为自己考虑，也为团队中的程序员考虑。\n做一名优秀的测试，除了要有分析能力、辨识能力等等软实力以外，基础技能如通信协议、脚本、编译原理、操作系统等等，亦视情况掌握，只有这样，才能和程序员从并不清晰的需求开始，一起去分析、设计、实现和质量保证、去和上上下下的环节做沟通、论证。微软的测试（SDET）都把算法和编码视为基础要求，敢问国内一些公司的测试人员，有几个敢这么说？\n&nbsp;\n让程序员远离浮躁\n去看看国内几家知名博客和论坛，多少浮躁的博文和帖子四处乱飞？多少人在骂公司狗血，在自嘲薪水，甚至在人身攻击？\n浮躁的心态可能是造成这种现象的罪魁祸首，有一位同事说得好，很多具体的技术都可以学，但是执着的心和对技术的热爱是不容易学得的。\n整个社会都在日益浮躁，ITEye本来也是一个有技术深度、氛围浓厚的网站，现在看起来有些鱼龙混杂；微博的流行正验证了社会浮躁的趋势，很多人没有时间和耐心去写完整的文章，但是两三句感慨、甚至一词半句的惊叹却容易得多；程序员像寻找速配男女一样，在这个概念翻飞的时代，茫然地寻找自己应该进入的领域，应该了解的技术，于是，很容易看到许多所谓的架构师和咨询师可以把这些东西讲得海阔天空、天花乱坠，这个概念、那个素语，但是——给他一个具体问题吧，要他写写实际代码吧，你会要了他的命。\n&nbsp;\n给程序员一点宽松和鼓励\n都在说国内的IT环境不如欧美，大量劳动力的富余让人力成本变得无比廉价，能让青年付出卖肾代价以购买大部分配件都“Made In China”的iPhone，中国却只获得了1.8%的利润，这些都让人感叹，为什么中国做不出苹果系列这样的产品？为什么中国始终要给别人套上“廉价劳动力”的帽子？中国的程序员，你们的创造力呢？你们精彩的点子呢？\n好吧，我听到有人在说是教育体制的问题。对于程序员的地位的思考有很多，可惜我们不是教育工作者，我们也没有那么大的影响力，不过，在团队中间，我们应当多给予这些脆弱的程序员们一点鼓励，让他们表达出自己的想法，特别是在设计上、实现上的想法，不要嘲笑任何人弱智，不要咒骂评审的代码狗屁，多一点沟通，把眼光放长远一些。\n这些能表达出想法的人起码可以证明两点：有思考、有勇气，仅这两点，仅足以让旁观的人鼓掌。\n一名优秀的Team Leader，不应该整天陶醉在跟踪项目进度和获取程序员工作反馈上。我们都明白，所谓一张一弛，在工作压力恰当的时候，是最适宜工作的，程序员的工作本来就需要创造性，没有适度宽松的环境，就没有思维的火花。\n让程序员自己去布置工作台，给他们创造机会聊聊天，把各个团队、各个角色放到一起说说话，组织分享一些有趣的话题，做一些有意思的研究（最初程序员都很腼腆，得劳烦您多牵线搭桥了），Team Leader的工作，绝不仅仅是说“行”或“不行”。\n&nbsp;\n程序员的理想\n1983年，乔布斯对百事可乐的CEO John Sculley说：“Do you want to sell sugar water for the rest of your life, or do you want to change the world?”（你想卖一辈子糖水，还是改变世界？）。\n我们已经不在战火纷飞的年代，有多少程序员还愿意怀抱那些原始的理想，还能说出“做互联网的弄潮儿”、“用技术改变世界”这样的话来？\n这个世界执着的人并不多，用这样的理念去吸引程序员的公司，则更少。\n&nbsp;\n关于技术\n我始终觉得，做软件的公司是需要依赖于技术的，当然国内可以称得上是“技术公司”的并不多，但是，优秀的技术能让程序员脱颖而出，也作为一种谋生的手段，为其觅得不错的回报。\n做技术能不能一直有饭吃？我想答案是肯定的，有许多公司声称技术路线可以一直有发展的可行性，但是技术牛人还是转了管理或者一走了之，有一种粗暴但是易行的鉴别技术公司的办法，就是寻找里面又没有40岁，甚至50岁以上还在做实际设计和编码的人（不是那些脱离了具体实现向客户吹嘘的角色）。\n世界上有两种最赚钱的人，一种是真正的生产者，他们用自己独一无二的聪慧、灵感和劳动创造了价值；一种是极其老道的投机者，专门从别人口袋里把钱掏出来放到自己口袋里。他们都受人尊敬、受人瞩目，后一种让自己的生活变得更美好，但是前一种，让整个世界更美好。\n如果你不能在技术的道路上坚决地走下去，在大部分公司做市场、做管理、做咨询，顺便鄙视一下别的辛苦工作的程序员，那么也可以混得很好——毕竟，生活的解总是有很多种。\n原文：http://raychase.iteye.com/blog/1450079\n\n        ', null);
INSERT INTO `blog` VALUES ('19', '那些被F_UCK了的青春', '\n            \n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当开开心心上班敲代码赶项目的日子突然变成无聊的打打酱油等下班的时候，我们唯一能做的，除了浪费青春之外，还是浪费青春。。。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生活不是一场强&nbsp;jian，不应该反抗不了还TMD得学会享受，大好的青春，岂能过得如此苦逼？！宁可孤身拼死在青春的路上，也不能让平庸F_UCK了我的青春！！！\n\n\n\n\n\n\n\n\n        ', null);
INSERT INTO `blog` VALUES ('20', '2012-7-24', '\n            \n \n\n\n每天花那么半个小时看看一些职业文章，看看书，写写自己喜欢的程序，挺好的。\n\n\n\n        ', null);
INSERT INTO `blog` VALUES ('21', '阿里巴巴离职DBA职业生涯总结', '\n            \n \n\n导读\n　　去年很多朋友私下或新浪微博上在总结自己的职业生涯与职业规划，也感觉到很纠结与彷徨，尤其技术人的职业生涯，随年龄增加，一些优势逐渐丧失。4月13日数据库技术大会的主办方举行的晚宴上，也让本人支持一个大家感兴趣又贴合实际的话题：三十岁后的 IT 人如何抉择人生路？遗憾的是预订酒店饭桌是几个房间打通的，而不是一个大厅方式（总共8桌），大家无法围绕在一起，为此只是小范围讨论了下，今天看到曾经阿里巴巴数据库团队的海波兄弟的总结分享，非常有意义，转载给大家共同欣赏！\n　　十五年前，你或许还不懂爱情，看 Jack 和 Rose 执手相看泪眼，只是蒙胧的心痛。十五年后，你会和谁一起走进影院，更会和谁一起，走到生命终点。\n　　十五年前，我还不太懂技术，凭兴趣玩着C语言。十五年后，当铁达尼的旋律再次响起，我会选择和哪门技术，一起走到我职业生涯的终点。\n　　序言\n　　—- 回望雨中的园区，更是回望来时的路。\n\n　　此时天空飘着小雨，正如丝丝织雨细如愁。我刚刚离职，一路走出园区，回望了一眼雨中阿里巴巴的大楼，思绪随着微风，四处飘散。突然想起几年前我刚到杭州那天，也是细雨微风。我走进城西的创业大厦，终于见识了大师 Biti 的风采，也从此开始我的阿里巴巴之旅。\n　　杭州的特点，是隐匿在山青水秀之间，有很多雅至的主题饭店。团队第一次出外聚餐，就是在山间绕来绕去，最后到了一处青山环绕、绿水长流之处。Biti 在会议上就“什么是架构”进行了精彩的评论，高度已经超越普通技术人员，至今我仍记忆犹新。但不久之后，Biti 调至支付宝，真是遗憾。而这让我面临了空前巨大的压力，因为 Biti 一走，我变成了团队级别最高的 DBA。初来乍到，入职刚满一月，忽然成为阿里系一个子公司的“首席 DBA”，惊喜之余，感觉压力之大、常常令我透不过气来。不过还好，时间总一晃而过，此时此刻，刚刚走出阿里，掏出手机，拍了一张照片，算作我在阿里的留念，更是我人生一段最重要经历的留念。\n　　回望雨中的园区，更是回望来时之路。…………\n　　来时之路：硅谷，IT 传奇的开始。\n　　—- 人可以依靠梦想活一段时间，但不会一直下去。\n\n　　“坐落在纵横交错的高速公路之间的，是巨型的商业园区和简陋的三卧两浴的平房住宅，其间最高的建筑是变电站的铁塔和架着电话线的水泥杆子。真正的工作是员工们在简陋的、用屏风隔开的小办公室里，眼睛盯着电脑屏幕静静完成的。每个人都试图做一些前人没有做过的东西。”\n　　这就是李彦宏在《硅谷商战》中谈到的硅谷的样子。\n　　曾经有两个在一家公司供职的工程师，去找硅谷著名的投资家史蒂夫&middot;朱维森，这位资深风险投资家对他们提出网上数据库系统并不感兴趣，他问：“你们还有其他主意吗？”\n　　其中一个叫比尔&middot;巴迪亚的工程师就说，他还想通过因特网来提供免费的电子邮件账户，从网上广告获取收入。10天之后，朱维森连商业计划都没要便掏出 30 万美元帮助他们成立了 Hotmail 公司。Hotmail 后来以 10 亿美元的天价卖给了微软公司。\n　　这在当时看来有些离谱，但这样的故事到处流传，充斥着各类励志杂志，也充满着我的心。\n　　世界上赚钱的公司多的是，但没有哪家公司的口号是改变世界。看看现在的 IT、互联网公司，每个公司的口号中几乎都包含着改变世界的梦想。而且从微软、苹果这类老一代革命家，到 Google、Facebook 这类硅谷新星，也的确有很多家公司或多或少的改变了世界，或至少是深深影响了世界。\n　　IT，互联网，这是一个传奇的行业。当我的手抚过键盘，当眼光划过满屏自己写的代码，澎湃的激情，从来都没有息灭过。但无论多大的激情最终都会有息灭的时候。人可以依靠梦想活一段时间，但不会一直下去。\n　　1996年，我职专毕业。职专，是差等生的代名词。职专生的梦想，一般都是成为某武侠小说的男主角，有一个酷酷的名字，有一堆惊艳的红颜。我也不例外。但这一切，在 96 年的夏天到来时，突然中止了。原因我应聘到了一个很小规模的计算机培训中心 — “辰星计算培训中心”。还有，我看了辰星书柜中的电脑报合订本。\n　　有一篇故事我仍然记得，《软件辉煌》，其中详细讲述了盖茨创办微软的经历，还有 Word 的开发历程，……。一群大男孩，用电脑改变世界。美国，硅谷，IT 界，从来都不缺这样的故事。虽然这样的故事从来没有在东方某个伟大的国家发生过。\n　　合上电脑报，一个想法出现在我的脑海中，哪就是我要做中国的比尔&middot;盖茨。年轻人总有梦想，不是吗？\n　　一年后，1997年的夏天，四个辰星公司的“核心”员工，告别辰星，踏上创业之路。四人熟读微软、乃至硅谷的历史，这些历史让他们热血沸腾。\n　　40年前，晶体管之父肖克利博士的故乡，美国西海岸的圣克拉拉，八名怀着梦想的年轻人离开肖克利半导体实验室，创办了可谓硅谷摇篮的仙童半导体公司。这就是著名的八叛逆。而我们，则自许“四叛逆”。\n　　我们在和辰星仅一墙之隔的地方，买了二十台电脑，投资达十万，创办了红星计算培训中心。哪一年，我们十八岁。\n　　光辉岁月\n　　—- 青春总是这样苦涩，但在长长生命之中，装在记忆这个坛子里，慢慢的发醇，最后却能化为无比的感纯。这或许就是生命的魔力。\n\n\n ………………\n 梦想总是遥不可及\n 是不是应该放弃\n 花开花落又是一季\n 春天啊你在哪里\n 青春如同奔流的江河\n 一去不回来不及道别\n 只剩下（平凡）的我没有了当年的热血\n 看那漫天飘零的花朵\n 在最美丽的时刻凋谢\n ………………\n\n　　红星的创办，让我们的年青岁月，都达到了顶峰，此后再无超越。我们在同学中间成为传奇，成为创业的典泛。甚至有同学的同学，还幕名前来，向我们请教人生。\n　　在红星除了讲课，我们还为一些传销公司开发核算、财务软件。我还用C和汇编，写各种有趣的程序。我用汇编写过一个 DOS 下内存驻留的程序，写完很有成就感，自信潢潢。但转念一想，要学的东西如此之多，不知何年何月才能学完，霎那间又充满急燥。\n　　那段青春岁月真是难以形容。快乐与泪水，自信与自悲，坚持与彷徨，……，各种各样的感情交织着，匆匆的，过去了，不再来。\n　　寒来暑去，花儿谢了又开、开了又谢，时间就如同夏日傍晚的凉风，轻轻的带走了岁月，只给人留下，多样的回忆，哪怕这回忆是如此的沉重。\n　　小学三年级时，还是 1987 年，我在书店看到一本书，作者是诺查丹马斯(Nostradamus)。书中详细介绍了他的一系列预言，从狮心王理查的死期，到希特勒的出现。当然，最后是 1999 年人类大灾难，恐怖大王从天而降。很不巧，当时哥哥刚刚带我看完电影《超人》。超人故乡星球毁灭的特效，虽然在现在看来拙劣不堪，但当时强烈震憾了我幼小的心灵。如今再看诺查丹马斯的预言，我几乎已经看到了地球在强烈的地震、大火中，变为一片废墟。出了书店，我万念具灰。我马上找到我的一众好朋友，将这个噩耗讲给他们：“我们只剩 12 年好活。”，未了，看着他们一个个脸如死灰，我却突然心情大好起来，悠载悠载的回家写作业去也。有了这种经历，使我完全相信微博上的一句话：不要向任何人诉苦，因为 20% 的人不关心，剩下的 80% 听到后很高兴。这是题外话，我们继续。\n　　12年后，1999年到了，我却再无所谓。或许大家一起死了，比我迷茫的活着更好。曾经辉煌的红星，只不过几年，便已面目全非，曾经的朋友，分道扬镖。在千禧年来临的前夜，我和几个同样迷茫的年青人，喝着劣质的白酒，挥洒着青春，也挥洒着生命。\n　　青春总是这样苦涩，但在长长生命之中，装在记忆这个坛子里，慢慢的发醇，最后却能化为无比的感纯。这或许就是生命的魔力。\n　　我相信人生是一段段例行公事，一段忙完又一段，直到尽头。在红星的大门关上那一刻，我告诉自已，一段生命结束了，要开始新的一段了。\n　　2000年春暖花开之际，我踏上新的征程。通过以往学员的关系，到了我市一家百年老字号 — 五福糕点，做学徒。强烈的急燥心理，令我急切的寻找一条可以快速发家致富之路，我当时的选择是：糕点师。但我并没有忘记我的梦，我的盖茨之梦，我的程序员之梦。2000年周星驰贺岁片《喜剧之王》上映，其中一句“我是一个演员”，深深打动了我。我想，或许有一天，别人吃着我做的极品慕丝，我却告诉别人：”其实，我是一个程序员”。\n　　罗红可以先做糕点，开“好利来”，赚了钱再当摄影师，我也可以。成长就是这样，我的目标，已经从创办 Intel 的肖克利八判逆，或盖茨等世界级大腕，变成了中国人罗红。其实，即便是罗红这样的成就，也是高高在上的。所以，我成熟了，但还不够成熟。我想成为一个不普通的人，原因就是我是一个太普通的人。\n　　几个月后，我放弃糕点，拎起菜刀，成了一个饭店的帮厨学徒。\n　　几个月后，我放下菜刀，在路边摆摊卖精品。\n　　几个月后，我开了一家精品店。\n　　几个月后，精品店倒闭，我赔光了所有钱。\n　　这就是成长的代价。路不去走，就不知道原来走不通，更不知道哪条路可以走通。\n　　其实，在这一年左右的时间中，也不是没有收获。在饭店做帮厨学徒时，我认识一个厨师。当其他厨师都是打台球、或站在街边对着过往的美女吹口哨时，他在练习刻花，或者学习。他说，他的目标是要上天津一所厨师大学。我们一直保持着若有若无的联系，我要看看他的坚持是否会有结果。我想，他也这么想的，他也想看看，我的坚持，会不会有结果。因为，无论在干什么，我也从没有中断学习。我不会吹口哨，台球打的也不好，他在苦练刻花时，我通常会拿起严蔚敏《数据结构》、同济大学版的《离散数学》等等。从 96 年到现在，从我看完比尔&middot;盖茨故事那一刻起，无论的目标如何变化，我可以自豪的说，我的 IT 梦，从没有一天停止过。也从没有在哪个阶段，停止过学习。\n　　还在五福糕点时，虽然这个决定有点晚了，但我还是决定放下 DOS。开始看《Windows 程序设计》这本号称 Windows 下的圣经。当我拿起菜刀时，同时，严蔚敏的数据结构，已经开始看第二遍了，这本书后来成为我走北上、南下必带的书。而在精品店时，对于始终不明所以的编译原理，我也没有放弃，买了本号称龙书的，但我最终对编译原理还是不明所以……\n　　4年后，那名厨师告诉我，他并没有去上厨师大学，他在北京的一家饭店，一个月已经拿到八、九千块。6年后，他仍在北京，但薪水已经到达一万五了。到我入职阿里巴巴高级数据库专家时，他已经到了广州，薪水和我在阿里不相上下。之后，我们失去联系，不再有彼此的消息。因为我们在各自的身上，都已经找到了结果。\n　　残酷的青春\n　　—-&nbsp;&nbsp;在某一阶段，或许我们在寻找的和拒绝的都是自己\n&nbsp;\n　　中国最神密的部门是有关部门，最危险的工种是临时工。2001年的夏天，我来到郑州，到了我向往以久的事业单位，省计算中心，可惜从事最危险的职业：临时工。\n　　从小，妈妈就教导我：“要好好学习，长大了进事业单位，有个铁饭碗。”\n　　我问妈妈：“为什么只有事业单位才有铁饭碗，其他的就没有吗？”\n　　“其他单位会破产啊，效益不好会倒闭，发不下工资。”妈妈没加思索的回答我。\n　　我又不理解了，“哪会为什么事业单位就不会效益不好呢？”\n　　“事业单位是国家吗，国家可以印钱啊。钱不够了就印。所以事业单位永远都不会缺钱。”妈妈回答我。\n　　我想起阿甘正传中的一句话，Momma always had a way of explaining things so I could understand them. 妈妈总是有办法让我明白道理。\n　　妈妈的目标，就是让我能进事业单位。现在，我终于进了，这多亏了一个亲戚。但我只是个临时工。我的工作是讲课，还有为其他各个大小企、事业单位开发各种程序。我在计算中心一共待了 7 年，前 2 年，都是作为程序员，后来才转 DBA。那两年，我也为河南的不少企、事业单位开发了大大小小不少程序。现在想想，还有些害怕。常常午夜梦回，惊出一身冷汗。万一哪天我当年写的程序有问题，会不会被跨省追捕回去。或许我下半辈子最好待在和中国没有引渡协议的国家，才能真正安全。\n　　事业单位大家都互喊老师，在阿里的时候，大家都互喊同学。所以后来到阿里后，感觉年轻了几岁，哈哈。在事业单位，正式的愁每天无事可做，临时的愁每天有太多事要做。常常一个上午跑两个单位解决问题，下午又要回去参加会议、讨论新软件的架构。在马不停蹄的忙碌中，我一直在考虑我将来的发展。谁都明白一个道理，如果想从一个行业中脱颖而出，只有两种常见的可能：要么技术牛X，要么占得先手。技术牛X这个，不容易做到，所以，对我来说，取得成功的最简单方法只有一个，“取得先机”。\n　　我们都明白一个很简单的道理，当火焰烧起来的时候，你才想到去加柴火，只能收获一堆灰烬。于是，我开始以我自己的判断，从众多的技术种类中，找到一个还在发展中的技术。\n　　经过苦苦的寻觅，了解了众多专家学者的一致看法，我选定了承载我希望的东西 — VRML。VRML 是 HTML 的 3D 版，当时一些专家预测，未来的网页，都将是这个样子的。\n　　想想看，3D 的网页，酷吧。打开网页，首先看到一扇门，用鼠标点一下，门打开了，随着鼠标的移动，你的虚拟形象走进房间，这是一个客厅，有三三两两的网友进进出出，大家互相在聊着天，还有几个网友在角落中私聊，…………，怎么样，这样的网页够酷吧。\n　　那是 2001 年的仲夏，傍晚的凉风，让经历了一天酷暑的人，感到格外轻松。夕阳西下的天边，还飘着几朵云彩，恰到好处的点缀着色彩绚丽的天空。我骑着自行车，轻松的穿行在大街小巷。我的心情格外的好，因为我刚买了一本书，是专门讲 VRML 的。而且，我找遍了整个书店，只找到一本关于 VRML 的书。这更加证实了我的猜想，VRML 目前还比较小众，是一门方兴末艾的技术。只要抓住时机，在 VRML 全面代替 HTML 前，将 VRML 学的比较精通。等到 VRML 大行其道时，我的名字将随着 VRML 一起，响彻全国。哈哈哈哈，……，想到末来的美好前景，我几乎忍不住要狂笑起来。但命运如同横穿马路的汽车，在你得意忘形时，将你的梦想击的粉碎。\n　　2004年，一晃三年过去了。HTML 势头不减，Flash 红遍国内，之于我的未来希望：VRML，不提也罢。这从一个测面证明，不要相信所谓专家、学者的预测。绝大多数的预测，都是错误的。就像 IBM 创史人托马斯&middot;沃森曾经作出了：“全球只需 5 台计算机”的预言一样。专家对未来的预测，往往是不靠谱的。企业家公开发表的预测，往往更不靠谱，他们的预测是为了对他们的产品和市场策略作宣传。就如同早些年 Larry Ellison（拉里&middot;埃里森）将预言未来 PC 将不再是主角，NC（网络计算机）都是主流。可惜早些年我不明白这些道理，浪费了几年时间。\n　　如果能成功的抢占“先手”，无疑会以最小的代价、获得最大的成功。但是，如果你自以为是的“先机”的东西没有发展起来，一切都将是竹篮打水，一场空。\n　　抢得“先手”固然可以使用自己更快的功成名就，但刻意的去抢，往往适得其反。成功抢得“先手”，这是上帝赐给你的礼物，可遇而不可求。这段经历让我明白，不要刻意追求快，欲速则不达，还是一步一个脚印来得稳妥。\n　　其实仔细想一想，历史上固然有比尔&middot;盖茨、乔布斯，有 Google、FaceBook，等等人或者公司，以创新、抢先赢得市场和尊敬。但是，成功的人一定都是少数，还有更多的人，同样的才华横溢、同样的聪明无比，但是，他们的创新、他的“先机”，都失败了。历史不会记得他们，因为，历史，是胜利者的丰碑。\n　　硅谷的风险投资商厉害吧，他们肯定不会将钱随便投给不靠谱的人、不靠谱的项目。但是，即使经过硅谷风投认定靠谱的事，成功率仍只能达到 20% 左右，80% 的失败者没有人会记得。\n　　几年的坚持，几年的努力，只不过去学了一个毫无用处的东西。其实从 2003 年开始，我就想过要放弃，我可能压错了宝、选错了方向。无数个夜晚在孤灯前学习，换来的只是毫无价值的技术！\n　　我的内心，很不愿意承认这个事实。人有时候最难否定的，就是自己。一直坚持到 2004 年，还是一个仲夏的傍晚。依然是凉风习习，天空依然是绚丽多姿。我沿着金水河随意的漫步，我想，是不是要放弃了。一根接一根的抽着烟，买了几罐啤酒，一罐接一罐的喝着，夕阳将我的影子拖的老长老长。在某一阶段，或许我们在寻找的和拒绝的都是自己。你认为它错了，后来发现又对了，释然之后，你担然承认，自己执着了。错和对重要吗，关键是它过去了。\n　　是的，过去了。\n　　这之后不久，因为工作需要，我开始接触一个新的东西，Form 和 Report，是一种很少人听说的，一种叫 Oracle 数据库的开发语言。各种语言对我来说是驾轻就熟，除了安装配置，这两种语言的开发，我很快就撑握了。我的历史，也因为这两个东西而转折。\n　　灯塔：ITPUB\n\n　　2004、2005年，我一直在做 Oracle 开发，主要使用的就是 Form、Report，当然，还有 OCI。在一些项目中使用 OCI，纯粹是出于对C语言的偏爱。其实大多数我们的软件，可以全部使用 Form 和 Report。\n　　我从开发转型为 DBA，是一个很偶然的事件。2004年底，在给海关做一个项目时，认识了一名搞网络的技术人员，他刚刚考过 CCNP，正在向 CCIE 努力。当时，我从没想过要考什么认证，因此，也不了解这些认证。听了 CCIE，也没什么概念。他跟我讲，Oracle 有一个很牛的认证，OCM。考过了后可以身价倍增。我回去在网上查了一下，说是当年亚州只有 4 名 OCM 等等，总之就是很牛*。这个结果令我大吃一惊，我没想到一个认证，能有如此难度与作用。从此，我开始了我的转型之路。\n　　其实我们单位从 2002 年就开始使用 Oracle，几年下来，也基于 Oracle 开发了不少项目。很多地方有时也要求我们在项目交付的同时，提供容灾、高可用方案。但这些是我不肖做的。曾经的我对 SA 和 DBA 是如此的不肖一顾，“只是搬搬机器、装装系统的民工”。我的梦想是创造，创造独一无二的程序，获得巨额风投，凭一已之力改变世界，我能，我可以。当梦想的浮华散去，我发现，8年过去，我仍站在原地。\n　　我是从备份、恢复切入到 DBA 这个行业的。2004年底，我们为海关做了一个项目。项目完成后，我为他们搭建了 DataGuard，同时，写了个脚本每周未备份 DataGuard。当然，在项目软件中我也做了个按钮，如果需要，他们可以随时点这个按钮触发对备库的备份操作。软件中还有个按钮是将备库直接激活的，激活之后，备库要重搭，并且，如果 Redo 文件有问题的话，激活会丢失些数据，不过，这个项目的数据丢掉些他们可以接受。整个这些东西，我做为了高可用、容灾的方案，浓重的写进项目文档。当然，免不了介绍的天花乱缀。哪个时代，大家对 Oracle 都没有什么概念，你只要能把库装上，都会有人说你牛。客户测试了备份、切换这些功能，再加上看了我天花乱缀的文档，对于灾备方案、高可用方案非常满意。我们领导后来得知这一情况后，专门问我是否有意转型做 DBA，我自然没有问题。我已经厌倦了开发，或者说，厌倦了老是为了别人的需求，开发程序。听说 DBA 还算轻闲，我计划转做 DBA，再利用剩余时间开发自己的程序。但不可否认的是，Oracle 是有它独特的魅力的。随着对 Oracle 学习的越来越深，我慢慢的放弃了我的开发梦。\n　　这一切的转变，都是很自然的，自然到我每每想起，总觉得那是命中注定。\n　　数万年间我和 Oracle 相遇了，没有早一秒，也没有晚一秒，哪也没有别的话说，唯有说一句，原来你也在这里。\n　　海关的项目之后，我开始考虑，如何让用户的数据在切换时也可以保持不丢。最后考虑的结果很简单，就是将 Redo 每组中设两个成员，每个成员都在不同的存储上。但当时记得有人说这样做会对性能有影响，即使存放日志的两台存储一模一样。但也有人说没有影响。我在网上查了很多资料，大家的说法，莫衷一是。最后经过测试，结论很简单，有影响，但影响不大。对于这个结论，我想大部分读者也不会满意。到底影响在什么地方呢？\n　　每组中两个成员，每个成员在不同的存储中，存储性能是一致的。说这种情况下写 Redo 性能不会有影响的人，主要是认为 LGWR 会同时写两台存储中的两个 Redo 文件。如下图所示：\n\n　　但是，我们考虑一点，LGWR 进程只有一个，存储有两台，向A存储写和向B存储写，必然是两条语句，一个进程怎么可能同时执行两条语句呢。所以，上图不对，应该如下图所示才是：\n\n　　LGWR 发送命令写A存储中的 RedoFile，不必等待写完成（因为是异步 IO），LGWR 再发送命令写B存储中的 RedoFile。LGWR 只有一个进程，不可能同时发命令写A存储和B存储中的两个 Member，只能逐个来。但因为I/O是异步的，向B存储中写 Redo Member，不必等向A存储中的写操作结束，而是如图中所示，有部分操作是并行的。\n　　从总的时间消耗上看，图 1 中错误的理论，共耗时 1.002 ms， 图 2 中正确的理论，共耗时1.003 ms。当然，时间是我随意加上去的，但对于现代的计算机系统，“发出一条命令”，“接收一个通知”，消耗 0.001 ms 应该是过高的估计了。 写磁盘的 1 ms，应该是差不多了，大部分数据库写日志的响应时间，应该都是几 ms 左右的。\n　　通过上面两个图的分析，可以得出结论，让 LGWR 写两个存储，对性能有影响，但影响不会太大。多了图 2 中最后一阶段的操作：“B存储向 LGWR 发出写完成通知”。\n　　有了这个结果，再后面的容灾架构，如果客户要求不丢数据，我都要求客户准备两套一模一样的存储，每个日志组的两个 Member，分别放在不同的存储中。后来 DBA 逐渐增多，客户那里，会有自己的甲方 DBA，对于灾备系统，当我提出要两台一模一样的存储时，一些客户会有疑问。我会详细解释 LGWR 的原理，其实，向客户解释的过程，也是传播自己思想的过程。向客户解释的原理越多，客户对我的信任感也越强，后面的事情也越好办。\n　　这些经历，也直接促成了我后面的学习习惯 — 重视原理。虽然原理这东西很虚无，但为了更好的说服客户、取得客户的信任，有时我不得不向客户解释这些东西。\n　　说点题外话，总有人问研究内部有什么用，我觉得最重要的作用就是，可以更好的忽悠客户。\n　　哈哈，这是玩笑话，有用没用看自己爱好。有兴趣就去研究，没兴趣就去做别的。这个问题不必纠结。\n　　如果真有兴趣去研究了，也一定会有回报。如果没去研究，也可以当好一名普通的 DBA。\n　　言归正传，能为客户解释这么多东西，有一个网站功不可未，就是 ITPUB。我 2005 年注册了帐号，此后，只要有疑难问题，第一时间先上 PUB 上搜索。PUB 成为了工作、学习必不可少的网站。但是，我很少在 PUB 上发表什么，因为我自己的功力尚不足，怕写出错误的东西，耽心影响大家。但看了哪么多好帖，从来没有回过帖，现在想来，也让我心中不安。于是从去年开始，我开始将这些年的积累逐步总结出来。我相信一个道理，有一个农场主，得到了一种优良小麦种子，但他不懂得分享，只在自家的地里种这上了这种优质小麦。收获季节到来时，结果他的优质小麦表现并不如何的好。他很不理解，就去请教一位专家。专家了解了情况好告诉他，只他自己种优质小麦，面积太小，旁边别人普通小麦的花粉，会被传播到他的优质小麦中，结果，影响了他的优质小麦的质量。第二年，这位农场主将自己的优质小麦种子分享给旁边其他的农场主。由于有了足够大面积优质小麦的花粉，到了收获季节，大家都获得了大丰收。现在时间已经成熟，我会慢慢将一些心得分享出来，\n　　希望和大家一起研究、一起进步、一起丰收。\n　　在乙方工作那段时间，对于工作，我只有一点感触。每天，我并不是为了单位而工作，我是为了自己而工作。只有自己的技能获得提升，才是关键。我会选择个别库做为观察对象，进行深入、细致的分析，以此来煅炼技能。但人的精力是有限的，再加上单位给的福利待遇也不高，所以大部分库，只要客户不找我，我也不去找他们。\n　　从 2007 年开始，单位成立专门的数据库运维团队，决定让我作为团队的 Leader。我的工作重点，从单纯的技术，慢慢变成了开会，参加各种会议。有些人对此乐此不疲，但我很不习惯。大家把活推来推去，把功劳争来争去。不单要开会，还要培养新人。慢慢的，一些库分给其他人管理，使我可以专心去“开会”。很长时间里，我无心从事技术，脑子中之想着明天要参加已经开了好多天的某项目架构大会、要最终确定下来的某事故改进会议、……\n　　我心目中的管理会议是这样：\n\n　　实际上的会议是这样：\n\n　　哈哈，我承认图有点夸张。我实在不适合做扯皮这样的事。或许随着我年龄的进一步增长、技术实力的进一步加强。技术上已经没什么可学的了，活也干不动了。每天开开会，扯扯皮，还有点意义。现在，这绝不是我想要的生活。古人都说，“学而优则仕”，我学还没有优呢，如何去入“仕”呢。\n　　2007年我技术进步缓慢，如果一直这样下去，我不知道，如果有一天单位辞掉我了，我该何去何从。没有了技术优势，一个单位的中下层管理人员，你到 51JOB 上搜索一下，有招聘“技术团队管理者”这样岗位的吗。而且，计算中心是事业单位，从 2005 年开始，我就一直谋求可以转成正式的“在编制”人员。为此，我、包括我们全家人，使用了很多方法。但是，我们的希望最后都落空了。\n　　其实，我本来也没抱太大希望。\n　　2008年初，为了将来的发展，我决定辞职。这个决定或许已经有点晚了，但是，如果不马上行动，将来只会更晚。\n　　在阿里巴巴遇见最好的 DBA 团队\n\n(Alibaba DBA 2011年初全家福，图片来自flickr)\n　　我不喜欢飘泊的生活，也不喜欢新鲜的城市。只想在我家乡那座著名古都中，像被固化在虎珀中一样去生活。但我的人生却注定要去飘泊，而且，是在三十而立之年，才刚刚开始。千万不要刻意去选择自己的生活，因为你只能猜到开头，却猜不到结果。\n　　我的第一站是北京，因为有朋友说可以为我介绍工作，但这份工作是 Oracle 讲师。我的技术还没有达到一定水平，还需要提高。这时候去做讲师，实在非我所愿。我的内心的理想目标，是去阿里系的公司：阿里巴巴、淘宝、支付宝。这些公司“大师”级的人物层出不穷，我想也应该是很多 DBA 的目标。但自己投简历过去，成功可能很小，我一向不喜欢自已投简历过去。所以，在 2009 年初，考完 OCM 之后，我就一直想做点东西出来。正好一个朋友找过来，于是我们合作，很快就有了“Oracle 日志挖掘研究版”这个程序。也很快的，阿里巴巴就给我打了电话。\n　　到阿里面试是很爽的，来回的机票、酒店全部都已经订好，就好像到杭州来个一日游。我是中午到的创业大厦，先被 HR 领到一个大厅里，做了一份笔试卷子，说是 60 分钟，但其实没有人在旁边计时，晚一会儿也无所谓。笔试题难度不高，和网上流传的阿里巴巴笔试题差不多。做完笔试题，就是著名大师 Biti 的面试了。这是第一次见到 Biti，个子不高，但人很精神，说话极有条理。\n　　Biti 面试时的难度也不高，大家聊的很好，就像朋友闲聊一样。所以，这趟杭州之行，让我觉得很完美，既来杭州旅了一日游，又和一些朋友聊了聊技术。\n　　本来我计划当天晚上就回去，Biti 面试完，被告知阿里巴巴 B2B 的技术部老大 Andy 想见见我，如果我时间上没有问题，HR 会退掉当天的订好的机票再重新订，当晚住宿的酒店也已经安排好了。\n　　当时很是受宠若惊，马上告诉 HR 没有问题。\n　　第二天其实还是有点紧张的，不知道 Andy 会问我什么问题。见到 Andy 后才感觉，Andy 人也很随合。Andy 问了两个问题给我留下很深的印象，一是建立一个数据库层和应用层之间的统一中间层，对下可以支持各种数据库是否有必要。还有一个，是如何拆分一个大数据库为多个数据库。\n　　第一个问题，我的回答的很中庸，一个可以忽略下层数据库是什么的中间层，对性能会有影响，对开发效率、代码重用率会有提升，搞一个是有必要的，对于特别要求效率地方，仍可以使用老的方式，一般情况下，使用中间层就可以了。我估计这是 Andy 当时正在考虑的问题，但后来阿里巴巴并没有大张旗鼓的搞这么个东西，我想 Andy 最终还是认为搞这个东西意义不大。\n　　第二个问题，拆分数据库的方法，我曾经主导过一个大库的拆分，要求应用的每张表，都有主键。然后就像 HASH 分区一样，以每个表的主键为准，将数据做个 HASH 运算，分布到多个库中，我直接把我做过这个项目详细说了一下。也是后来我才知道，原来阿里巴巴这边刚刚做过一个大表的拆分，拆分方法和我说的类似。\n　　上午的面试很快就过去了，我专门让 HR 帮我订晚点的机票，这样，下午有时间去西湖游览一下。\n　　这次杭州之行，给我的感觉是，杭州不错，面试很愉快，但打车很难。下午在西湖边打车，用了好久。后来才知道，在那个时间点打车，能打到已经是运气了。\n　　两个月后，我告别待了 10 个月的北京，来到杭州，入职阿里巴巴。\n　　中国的大型互联网企业，有很多相似之处。比如说一样有入职培训，一样每年有年会，一样的有 Outting，一样的嘴上说一套、底下做一套。比如公司一直在讲诚信，但在出了一些事情之后，从公司发给我们员工的邮件来看，没有看到诚信二字。但这很正常，在我们国家，到我这个年龄，如果还相信公司说的什么或老板说的什么，那脑袋就真有点问题了。\n　　阿里的入职培训和其他公司一样，讲一讲企业文化，再把人拉到户外做做拓展运动，结束，没有持续性。和我一起参加入职培训的有几十人，半年内有差不多三分一离开公司，一年内大概只剩三分之一留在公司。我和另外两个入职培训时认识的朋友合租一套三室两厅，一年后，他们都走了，只剩我自己独住一大套房子。大家来阿里的目的很简单，渡金。我的室友之一，半年后顺利跳到了 teradata。另一个是做客服的，一年后跳到另一个规模略小的互联网公司，做了客服经理。当然，我到阿里，最大的目的并不是渡金，而是学习。我的目标是成为 Oracle 大师，阿里孕育了哪么多 Oracle 大师，到了阿里，我就和目标接近了。\n　　但可能是我在面试时忽悠的有点过了头，阿里给了我一个很高的级别：高级数据库专家。这既让我兴奋，又让我感到无比大的压力。在我入职时的 2009 年，整个集团的技术人员，达到这个级别、和这个级别之上的，不过几十人而已。在 B2B，高级专家之上的，只有十几个人。我们 DBA 团队中，只有一个人比我级别高，就是 Biti。这让我的压力，稍微小了点，有什么大事，我前面至少还有 Biti 在扛着。但是，一个月后，Biti 就调到支付宝。我成了阿里巴巴 B2B 级别最高的 DBA。一下子变成了“首席 DBA”，我内心深入无比激动，但是，这也让我无比害怕。\n　　来到阿里，我对自己的定位是学习、经历，我的目标，是成为技术大师，我从不会改变这个目标。但公司对我的期望，显然不是这样的。但这没有关系，这并不会防碍我学习。\n　　在阿里的日子过的很快，好像回到了上学时代。每天三点一线，上班、到食堂、下班。DBA 团队是我见过的最好的团队，几位领导对每个人都很负责，诚心实意的为每个人着想，努力为每个人提供发展机会。大家之间没有争抢，没有钩心斗角，只有努力的做好事情。很高兴在这里渡过了快乐的近三年时光。在此，对领导、对团队中每个兄弟表示感谢。阿里的数据库维护水平，自然是没得说的，用一句通俗的话来形容，我就像掉到了水中的海绵，如痴似渴的吸收着养份。\n　　我到公司时，MySQL 刚刚在公司有第一例非常成功的案例。之后的几年间，公司的 MySQL 团队从无到有，迅速壮大，MySQL 的应用也是遍地开花。再之后 NoSQL 如同凄美的昙花，匆匆一现，却也给公司内 Oracle 的应用带来不小的震动。对于开发，Oracle 有如过街之鼠，几乎人人喊打。之后，一切又都归于平静和理性。NoSQL 出局，MySQL 重点发展，去 Oracle 已成必然。从 2011 年开始，我也面临艰难转型，根据公司情况，我决定转型到 GreePlum 数据仓库。但转型是困难的，几本大部头的书，一看就困。Oracle 是越学越精神，一看 GreePlum 就瞌睡。数次不眠之夜的深思，我决定放弃转型。我知道这对我来说意味着什么，放弃转型，也意味着要放弃这份工作。虽然我很喜欢团队的氛围，我对团队恋恋不舍，但我仍将坚持我的方向。2011年夏天，我开始筹备我的下一份工作，并计划在2012年春节的时候离开。\n　　阿里巴巴二三事\n\n　　在阿里，我见识到了 Biti 留下来的管理制度与管理水平。我们的数据库，很少出莫名其妙的问题。按照托尔斯泰的说法，好的数据库个个相似，差的数据库各有各的不同。好的数据库，无外乎性能尚可，有完善的备份恢复和高可用机制、并定期测试，很少奇奇怪怪的问题，绝大多数报错、性能曲线的波动都可以找到原因，等等。差的数据库总有千奇百怪的问题、林林总总的报错、莫明其妙的当机。\n　　其实，达到阿里数据库的管理水平，DBA 只做了一件事，就是更加关心自己负责的库。\n　　每次性能曲线的波动，都要找到原因，甚至定位到 SQL。对于新上线的 SQL 语句，进行严格的审查。对于大操作，格外小心。Statspack、AWR 报告，要观注、观注、再观注。基本上也就这些了吧。我把这种管理模式，叫做精细化管理。\n　　说到这里，我想起了一件事，姥姥家住在一条古老的小巷里，在小巷南口，相隔不远有两家买锅葵（一种面饼）的，但一家门庭冷落，另一家则客流不断。很多人宁愿多花点时间排队，也要买另外一家店的锅葵。有一次，我跟一位住在这块的老表谈起这事，为啥一家店生意清冷，另一家店生意兴隆。我老表很郑重的告诉我，“这就是用的功夫不一样。”我霎时间明白了。\n　　当然，我见到过很多乙方公司的 DBA，每个人要管几十个库，在这种情况下，根本无暇顾及什么性能指标、AWR 报告，只要数据库不当、只要客户不主动来找就行了。不出事情，哪有什么功夫去看 AWR 报告什么的。至于乙方的这种管理方式，我先称之为粗犷化管理。\n　　这种粗犷化管理试，也是国情所定，我们无法改变环境，但我们可以改变的，是我们自己。我有一个朋友，初中同学。初中时学习不好，技校毕业。毕业后在工程公司做技工，其实干的活和民工没有差别。在体验到现实的残酷后，他没有被生活磨平楞角，反而越战越勇，真正的奋斗起来。他的目标是考取注册监理师认证，很自然的，这个目标成了很多人茶余饭后的笑料。不是说这个目标多不现实，而是，就算你考上了注册监理师，又能怎样呢？你怎么才能找到第一份监理师的工作呢？就算有证书，谁肯要一个民工做监理师呢？面对嘲笑，我们唯一能做的事，就是努力坚持自己的方向，不要去做无谓的争辨。在干完一天烦重的工作后，他回去还要挑灯夜读。几年的坚持，他终于考上了注册监理师。就在为第一份监理师工作发愁时，机会不期然而至，工程公司的一个朋友将他推荐到另一个公司。虽然干的活和民工没区别，但他是技校毕业，算是技工，底层实践经验丰富，又有了注册监理师证书，他成功的跳到另一个工程公司，成为监理师。轻松完成了从民工到工程师这个华丽的脱变。而且，一切又都是如此的自然而然。两年后，他又跳到北京一家更大规模的公司。公司将他派到新 Jiang，在工地上，他巧遇以前的同事，他们还在顶着风沙，在工地上辛苦的工作。目前，他正在自学英语，他的计划是希望跳到外企。我相信他一定可以成功。\n　　自助者天必助之，古人的经验之谈，难道都是骗人的吗。\n　　相信有些乙方的 DBA 也在痛苦中迷茫，如何在粗犷化管理中，实现自己职业生涯的突围。我建议呢，可以选一两个库，以提升自己水平为目标，进行精细化管理。关注这一两个库的细节，你会发现，水平可以更快的增加。\n　　在阿里，我的第一次事故，让我记忆深刻。那是一次加节点操作，前期操作已经成功，最后一步在执行 rootaddnode.sh 脚本时，中途出错，导致 OCR 信息被损坏，所有节点全 HANG。进行 OCR 恢复后，才恢复正常。原因非常奇怪，rootaddnode.sh 要调用 srvctl 向 OCR 中写入新节点信息，而 srvctl 因为缺少个包，执行失败异常退出了，OCR 信息也被写坏了。\n　　在进行这次加节点操作前，我在虚拟机中反反复复测试，做了大量的准备工作，但没想到，最终还是出了大事故。\n　　从这件事后，我再做其他操作都更加仔细，特别是 RAC。RAC 下操作总会调用这个那个一堆的脚本，我会先把脚本看一下，大概了解这些脚本都干点啥。就像加节点，我会先调用 Srvctl config 命令，显示一下配置信息。如果可以显示成功，再进行加节点操作。\n　　“不要在周五做重要的事情，这会让你整个周未都没有好心情”，这是这次加节点操作给我留下的另一个忠告。\n　　在阿里最深刻的，还是职场之道给我的震撼。在此，引用一位 PUBER 的发帖：\n　　A 同学，遇到问题，召集会议写报告搞风险评估，凤凤火火，完事后到处汇报心得，各部门都知道了数据部的功劳。\n　　B 同学，遇到问题，默默一个人搞定。\n　　这B同学确实厉害，很多问题都独立搞定，A同学连 oracle 的 pga 是啥都不知道，但他就是跟公司的高手们关系好，会求助，会推动。\n　　当你有一天听到领导们背后议论A和B的时候，你会发现，他们一致都比较欣赏A。为什么他们会欣赏A呢？不是B是高手么？因为领导们已经长期不做技术了，观察人更喜欢观察人的沟通协调能力，像B默默搞定问题，谁也不知道是咋回事，还以为这问题很简单呢。结果呢？B郁闷离职。。。职场故事无新鲜事，类似故事每天都在发生。\n　　以前一直以为是故事，直到见到一个活生生的、传奇般的“A同学”。除了这位 Puber 提到的，我觉得“A同学”一般还要有一个特长，就是会起名字。一个普普通通的架构，起个好名字，简值是有化腐朽为神奇的作用啊。\n　　看一些中央领导的简历，升迁之迅速，往往让我惊叹。很多人不惑之年，都做到了高级领导，拥有数套房子和无数个情人，成功进级高帅富他爹。我一直很奇怪，人家都是怎么玩的。自从见过“A同学”后，我了然了。“A同学们”的成功是很迅速的，他们身轻如燕，稍有青风拂过，便能乘风而起，一飞冲天。\n　　“A同学们”也要有一定的能力，这是基础。但是，和他们的综合实力相比，他们的能力可以忽略不记。\n　　他们可以把 GDP 搞的很高，但不会把国家搞的很强。\n　　如果一个集体、一个部门甚至一个国家，越来越弱，那一定是“A同学们”太多了。\n　　“A同学”后来跳到另一巨头民企担任很高的职位，依旧是风声水起、威风八面，于是我就知道，那家民企的发展是到头了。如果以释伽“成、住、坏”三阶段发展论来讲，个人认为那家民企的“成”阶段已经过去，进入“住”阶段，如果没有“B同学”大量加入，数年之后，或许就是“坏”阶段了。\n　　个人认为，单以职场发展来论，“A同学”值得效仿。现在的职场，好像春秋战国，即使你所待的“国家”，已经进入“坏”的阶段了，没关系，换一个国家就是。就像春秋战国时一位“士”人的言论，是当大王、诸候好呢，还是做大臣好呢。当然还是大臣好。一个国亡了，王的结局只有死，但大臣呢，换个地方再做大臣就行了。“A同学们”，永远会受到市场追捧的。他们就像漆黑中的萤火虫，那样的鲜明，那样的出众，那样的拉轰。\n　　但我向来没有“A同学”的能耐，只能向“B同学”学习了。\n　　将来做企么无所谓，有一点很关键，就是要认清自己的方向，这很重要。做管理？做技术？都行，这世界上有靠管理成功的，也有靠技术发家致富的。\n　　你的目标可以是成为管理者、领导，但不能是“成为好逸无劳又挣钱”的人。不要幻想着每天什么活都不干，上班喝喝茶、扯扯蛋，每月工资高的让我们这些矮穷丑听到都吓的尿裤子。这样的境界，是要有上一代打下基础才行。如果你进了 ITPUB 这个论坛，又看到我这篇文章，这足以证明你上一代没什么基础，就不要再做梦了，赶快起来跟我一起用 DTrace+GDB 研究 Oracle 原理才是正事。\n　　要想成为管理人员，或是领导，无外乎三种途径：\n　　1、在公司混久了，跟着上级、甚至公司创业者一起打天下，有资历。走这条路，要看运气，跟对了人就行。\n　　2、潜心研究技术细节，深入钻究技术，成为大牛，转而成为领导。这就是学而优则仕了。\n　　3、有关系，家人在有关部门任职。\n　　如果你发现自己没有跟对人，也没有关系，要想成为领导，那就走第二条路吧。我知道很多优秀的领导，都是这样走过来的。比如我们团队的头，还有 Biti，都是如此。其实，就连我所提到的“A同学”，现在的某互联网巨头企业中高级管理人员，也是如此走过来的。\n　　大多数离职的人对以前待过的公司都是颇有微词的。也是啊，如果不是因为待着不爽，谁愿意走呢。但我对阿里，感觉还是非常好的。因为阿里，我来到了杭州，在钱江之畔，生活了近 3 年时光。在阿里，我终于实现了我的目标 —— 让技术更上一层楼。三年时光匆匆而过，正如一部电影所说，年华就是如此，当你不再拥有，你唯一可以做的，就是令自己不要忘记。\n　　尾声\n　　站在远处，最后看了一眼雨中阿里巴巴园区漂亮的大楼，我生命的这一阶段已经过去。这是我生命中目前为止收获最多的一个阶段，感谢阿里、感谢我们的团队！\n\n        ', null);
INSERT INTO `blog` VALUES ('22', '伟大的程序员是怎样炼成的？', '\n            \n \n\n\n　　英文原文：What makes a great software engineer?\n　　原文发布于 2009-8-21\n　　近几周，一份反映&nbsp;Netflix&nbsp;公司企业文化的报告在网上广为流传。 这份报告里列举了很多Netflix公司里令人称赞的做法，包括这个公司是如何的招聘和辞退员工的。 里面有大量的信息是描述Netflix公司是怎样对待员工的，这使Netflix公司变成了一个很有吸引力的工作场所。报告里面提到过有一个关于员工所期望的内容的清单，但没有把清单列出来。 报告的开始部分就谈及了企业价值问题，而且是按照员工的立场角度写的，可惜并没有把这个问题展开。\n　　我并不在Netflix工作 —— 你也知道 (我在&nbsp;Yahoo!工 作) —— 但我深切的感觉到，不管你在哪里工作，成为一个优秀的员工、优秀的软件开发工程师的过程是一样的。 下面所列举的都是伟大的程序员所具有的经验和品质。\n　　只做正确的事\n　　对于软件这一行的人，我们有个很大的挑战，就是如何能够用正确的方法做事情。什么是正确的方法，这依赖于你在做什么和为谁做。而究竟所谓 “正确的方法”里都包括了什么内容，这并不是重点，重点是你是否能坚持按照这种方式做事。初级程序员的问题通常是不能做到坚持，而资历较深的程序员却能始终坚持原则。 也许会有一个“非常紧急”的项目，或者这个项目很特殊，不能按常规过程开发。这只是个假象。 好的程序员知道即使在任何情况和环境下都要坚持做正确的事情。如果说按正确的方式开发将导致不能按时完成任务，那么，他们就会知道，这个项目是不能按时完工的。 不要妥协，工程质量是你作为一个优秀程序员的唯一终极证明。 确保你所有的代码都是在正确的方法下100%正确的写出的。要按一个优秀的程序员的标准来要求自己。\n　　甘愿受苦\n　　听起来很傻，但却是真的，优秀的程序员都乐于承担工作上给他们带来的痛苦。你说出一个伟大的程序员，我都能告诉你，在他或她的职业生涯里，各个阶段，都曾有花好几天时间去解决一个问题的经历。优秀的程序员品味着困难给他们带来的挑战，这让他们日以继夜，他们明白，问题必须要解决掉。\n　　不太优秀的程序员就不一样了，他们在刚刚碰到有麻烦的迹象时就先想到要寻求帮助。在问题面前，他们习惯于去寻求帮助，而不是自己去努力解决这个问题。他们最喜欢的一句话是：“帮我看看这个问题”。伟大的程序员的第一反应是我要自己解决这个问题。解决问题是种技能，是优秀的程序员非常看重的一种技能。\n　　好的程序员是通过痛苦的磨练才成为伟大的程序员的。痛苦的磨练是说当你对这个问题实在无能为力时才去请求外援。求助就意味着认输， 所有尽量减少这种处境的发生。甘愿受苦。和问题做不懈的斗争。这就是你要学会的。\n　　注意: 我并不是说你不能寻求他人的帮助。我说的是，你首先要尝试自己去完成任务，如果你不能完成，再寻求帮助。不要在自己没有努力过前就轻易的求助。你经常会发现，当你知道了解决方法后，你才认识到，你用自己的力量本也能解决这个问题的。\n　　学无止境\n　　如果有人敢声称他不需要再学任何新的知识，我是绝对不愿意和他共事的。在有些行业，你也许很多年不学新的东西也能干的很好，但软件技术革新的如此之快，你不能不时刻关注。你的老板是由于你有某些技能才花钱雇你的，如果你的技能已经落伍、过期了，那你也就没有价值了。 想成为一名伟大的程序员，你首先要承认你不是无所不知，你必须每天都要努力的寻找、学习新的知识。\n　　在你现在的公司里或组织里寻找能让你学习、让你钦佩的人。在复杂的问题上征求他们的意见，看看他们是怎么思考的。向他们介绍你的解决思路，请他们给予批评指点。如果在你的周围你不能找出一个能作为你的导师的人，这要么是你还没有认真的寻找，要么是你留在了一个不该留的公司里。如果你在现在的工作上不能学习进步，那是到了你该换个工作的时候了。\n　　要阅读网上的博客。关注一些研讨会。与其他程序员交流。伟大的程序员从不停止学习。\n　　分享知识\n　　有一些程序员认为，他们的唯一价值所在就是他们所拥有的知识，于是，分享出他们的知识就会让他们的价值降低。这是大错特错了。让你有价值的不是你的知识，而是如何运用你的知识给公司创造价值。难道还会有比分享知识给他人更能给公司创造价值的方法吗?\n　　我曾经面试过一家公司，知识不共享、相互保密、相互提防的理念在这家公司里根深蒂固。在这样的环境里，员工之间形成了一种恶性竞争的关系，这直接导致了勾心斗角和诬陷中伤的产生。我可不想在这样的公司里工作。如果每个人都对自己知道的事情讳莫如深，那你什么都学不到。\n　　伟大的程序员希望他人也能知道自己所掌握的知识。他们并不担心会因此而失去优势，因为他们相信大家都会这样做。伟大的程序员乐意看到他们的同伴成长、成功。一个公司，它应该被一群喜欢知识共享的人组成，就像人们在运动场上，让团队的每个对员都强大起来，整个团队才会强大。\n　　伸出援助之手\n　　伟大的程序员从来不会说“这不关我的事”。他们总是愿意伸出援助之手。他们经常在做自己的工作之余，去帮助那些编程新手。如果有件任务必须按时完成，而又没有其他人能胜任，伟大的程序员会主动承担起这项任务。他们从来不嘲笑来请求帮助的人，即使问题是那么的小、那么无意义、无价值。伟大的程序员重视他们的团队，愿意为团队做任何的事情。不管是要去写1,000行的代码，还是去编辑一个图片，伟大的程序员都会立即站出来帮助完成。\n　　十年磨一剑\n　　伟大的程序员不是天生的，是后天炼成的。他们是本文上面提到的那些因素造就的，加上还要通过努力的工作。如果你是刚刚意识到这些，那还不晚，你仍然有充分的时间来成为一个伟大的程序员。耐心是关键。伟大的程序员不是在旦夕之间就可以成就的。有些人可能要花上数年，有些人则需要十几年。没有人为你写血泪史。好的公司当发现你有成为伟大程序员的潜质时，会帮助你，为你提供舞台。而你会通过你的努力工作、让你的团队进步来证明自己。要坚定，要自律，通往伟大程序 员的道路会很长。\n　　更新 (5 Sep 2009)：针对“甘愿受苦”段内容增加一个声明。好像很多人都误解了我的观点。\n　　声明: 本文里的所有观点和立场都是来自 Nicholas C. Zakas 本人 ，跟&nbsp;Yahoo!,&nbsp;Wrox 出版公司,O’Reilly 出版公司, 或其他人没有任何关系。我只代表我自己，不代表他们。\n\n        ', null);
INSERT INTO `blog` VALUES ('23', '整理下自己这一年的书单', '\n            \n \n《重构，改善既有代码的设计》《代码整洁之道》《javascript: The good Parts》《Effective java》《java : The good parts》《高效程序员的45个习惯》《研磨设计模式》《精通javascript》《spring 框架技术内幕》《spring in action》《spring 3X企业开发》《thinking in java 4》《数据结构与算法分析：java语言版》《maven实战》《高性能的javascript》《web黑客攻防技术宝典》《javascript高级程序设计》\n　卢泽明说过：“无论什么时代，看书总是好的。”感谢这两天送我的《web黑客攻防技术宝典》和《javascript高级程序设计》，很喜欢的书，嘿嘿…\n\n        ', null);
INSERT INTO `blog` VALUES ('24', 'code maker', '\n            \n \n\n对于码农这个称呼，有些人喜爱有加，有些人不以为然。区别在于对待“农”这个字的感觉。农当然是指农民，这个词寓义很丰富，既可以说它伟大，也可以说它渺小。说它伟大，是因为我们的生存离不开农民，而且中国一直是个农业为本的国家，曾经说是百分之八十的人是农民，这意味着往前翻一两代，你我众人皆是农民出身。以此观之，农可谓大哉。说它渺小，则是因为大家的观念里，农民意味着有很多缺点，冠冕堂皇的说法是劣根性，比如目光短浅、思维陈旧、自私小气，等等，总之是为我们受过教育的人群所看不惯的种种毛病——这些毛病虽然我们自己也有，但是我们看不见——于是乎“农民”成为了骂人时常用的字眼。\n其实，把自己的编程生涯与田间地头的锄禾日当午对应起来，确是有那么些相似之处的。你能想象得到，田间整齐栽种的秧苗，与屏幕上显示的错落有致的代码行有几分神似。各种庄稼的种植是有讲究的，正如你要注意编程风格。施肥灌溉，犹如你对代码进行的编译链接。除草除虫，自然是在做着debug。你挑水来我浇园，大概是在小菜园中进行的结对编程。因为靠天吃饭，农民们也要学点云计算，去五道口职业技术学校进修的人也多起来了。收割的季节，活多人少，也常常是要搞外包的，因为deadline很重要，time to market不容错过。\n不过坦率地说，码农这个叫法让人体会更多的是滑稽、搞怪、无厘头。毕竟一个是简单的体力劳动，一个是高智商的脑力劳动，不可同日而语。而程序员却偏爱这样的时空错乱的感觉，自嘲（我就是个农民！）的同时却又自命不凡（我是码农我怕谁？！），特立独行极了。\n码农的草帽底下，是一颗充满创造力的自由不羁的头脑。他们遵从最佳实践而痛恨陈规教条，他们欣赏天才而不迷信权威，他们喜欢思考而不轻易苟同。他们是技术人，却追求人文理想；他们敢于呐喊，说出自己的观点和主张，也更善于脚踏实地，用自己的点滴工作去改变现状。码农们是勤奋的，加班加点的工作是常有的事情，城市夜间的灯火，有多少是在码农们的办公室和居所点燃？周末四处举办的技术交流和讲座，又活跃着多少码农的身影？线下读书，线上讨论，冥思苦想，动手实践，新技术驱动着码农们的脚步，码农们在改变着我们的生活。\n生存离不开农民，生活离不开码农。\n\n        ', null);
INSERT INTO `blog` VALUES ('25', '强烈推荐《王淮：我在Facebook的十点经验分享》', '\n            \n \n\n我是 2007 年初加入 Facebook，那时大概 150 人。2011 年 9 月底离开，当时 3200 多人。经历了很多稀奇古怪但影响很大的项目， 像 Application Platform, Social Ads, News Feed, Gift Shop, Facebook Credits 等等。碰到的很多的问题都是全新的，规模是互联网历史上最大的。当时的心惊肉跳现在回想起来是很让人怀念的旧时光。到我离开 Facebook 的时候，我负责支付安全和工具研发部门，还有部分的支付后台研发组。\n　　现在我在全职做天使投资，给看对眼的团队在早期产品技术团队搭建给予一些力所能及的帮助。有兴趣的朋友可以关注我的微博@王淮 Harry 哥。\n　　在 Facebook 的这些年让我学习感悟了很多东西，很多东西溶在血液中，现在我换了时间来思考最值得分享的 10 点经验和大家分享。希望能给创业的朋友一些启发。\n　　在我们开始之前，先来一段免责声明“\n　　1. 这里所有的东西都是从我自己的亲身体会和实践中获得的。不一定都是新的，但都是真实的。\n　　2. 所有的这些在 Facebook 的文化下能有效，但不代表对你的公司一定有效。好的种子还要有合适的土壤。\n　　3. 不是所有的点都对你有用，但只要有一点对你有用，我就开心了。\n　　OK. 我们开始吧。\n　　1、坚持你的远见， 但灵活的把握细节\n　　作为领导者，在远见上你只有依靠自己，至少在你自己负责的业务范围之内。你是老板，意味着整个公司；你是经理，意味着整个部门。为你卖命的兄弟姐妹们是依靠你来给他们提供远见。什么是远见? 就是对最终状态的一种描述。是让你的团队在疯狂的飞行之后最终着陆的地方。是辛辛苦苦忙忙碌碌之后的新生活。它是北极星，它来指明方向。举一个例子，当我一开始建立支付安全部门的时候，我们只有人工规则引擎。规则是人写的。一条人工规则是有少数变量的简单逻辑，比如“如果(注册在 30 天之内和支出大于 100 美元和是首次支付和用户来自印度尼西亚)，那么 (拒绝交易)” 但这里有个问题 —— 人写的东西容易出错. 人很难有效的处理 10 个以上的变量。我们需要一个更有可扩张性(scalable)的解决方案. 我们希望把很多事情自动化，让机器人做更多机器擅长的事情。因此我们建立了一个共识 —— 将我们绝大部分的规则逐步替换为机器学习获得的判断模型。这一远见让我们组新加了一位机器学习领域的博士和另一位之前有过机器学习体系开发经验的工程师。赌注巨大，但是一个更好的未来需要下这个注。\n　　但你需要对细节灵活把握，永远都有条条大路通罗马. 你需要给团队足够的空间来施展拳脚，只要他们在朝着正确的方向以合适的速度前进。另一个故事：在 classification 算法上一度我对决策树的兴趣比回归要大。但玩算法的工程师告诉它们之间的差别可以忽略。我可以坚持己见（当时我是真心觉得决策树要更合适），但我信任他并让他放手去选合适的算法。同设计师(Facebook 的整个研发有设计师、产品经理、工程师三类物种) 合作的过程中也有趣事发生，他们对于字体、颜色、行距等等都很龟毛。我通常都会忍让， 只要服务于产品的主要功能。我们精力有限， 吵架要选择正确的战争，关乎全局的战争，而不是纠缠于某个局部战斗。\n　　2 、只和最好的人合作\n　　一流的牛人只愿意和牛人厮守。他们聚在一起会更牛逼。一流人才无法容忍二流的人。那什么是“最好的人”？我的理解是能够尽其所知，用其所长，学其所不能， 从而迅速完成目标并远超期望。他们的本能是挑战自己， 超越别人的期望，超越自己的期望。对他们来说，仅仅足够好是不够好。\n　　只有一流人才组成的团队有很多好处。\n　　(1) 这让你更加愿意委托。从我的经验来看，牛人不会轻易信任不熟悉的人。如果你还没有证明自己和他们一样出色甚至更出色，他们宁愿自己独立工作劳累死也不愿接受你的帮助。因为他们担心你会搞砸。但当你证明自己之后，他们会信任你，放心的把事情交给你一起合作。一个互帮互助的牛逼团队才能做到1+1远大于2.\n　　(2) 通过艰巨任务的完成，牛人们互设榜样。你会想“牛，这哥们竟然能把这玩意做出来了，咱得加油了”。这种 peer pressure 合理的利用可以大幅度的提高工作表现并在团队中形成良性循环。\n　　(3) 牛人们喜欢互相挑战。我记得一位工程师总监立下赌约 —— 如果我们在规定时限之前完成网站翻译平台所需的代码修改，他将把头发染成蓝色。这样的挑战把“枯燥”的工作变成了挑战性游戏。在玩游戏中写程序比纯粹的写程序要有趣得多。当然我们也有很多更加认真的挑战。因为牛人们天生(贱命，哈)容易对挑战上瘾， 不管是挑战别人还是接受挑战。\n　　(4) 牛人们相互学到很多. 每个牛人都有自己牛的地方，彼此有很多的互补。如果 Facebook 不是有很多东西可以学习的话，我不会呆 4 年多。对缺乏经验的人来说，这点很给力。我们雇佣非常聪明的毕业生(潜在牛人)，这些人希望引爆自己来证明他们的牛逼之处。他们不愿到一个舒适无挑战的公司过日复一日的生活。他们想学很多来丰富他们的经验，完成不可能完成的任务并在他们的职业生涯上前进。他们想要证明“yes, we can”。和其他牛人一起才能更容易的实现这些。\n　　你不想要二流的人，但如何远离他们？首先，慢点招人 (Hire Slow)。在招人的标准上固执一点。训练你的面试人员让他们明白他们需要招(某些方面)比他们更强至少不会拖后腿的人，如果不是，拒绝平庸，不要屈就。我曾好几次在招聘决策会议上发现黄金履历者无法拿到 Offer, 只因为某个面试官觉得这人无法给他深刻印象没有让他惊讶。但在另外一些例子当中，那些获得一致通过的候选人仍被放弃因为大家都只是觉得他仅仅符合要求而已， 没有出彩的地方。在招人问题上，绝大多数情形下，你要小心不要冒进。（顺便提一下我们也会雇用那些没有全票通过的候选人，只要有一两票是强烈推荐 —— 因为对于已有员工的强烈推荐你是不应轻易忽视的，这时可以冒险）其次，炒鱿鱼要快 (Fire Fast).。使用二流人才就像服用慢性毒药，一天一点， 迟早咯屁。Facebook 要求所有的管人经理对于员工的表现要特别敏感。经理发现员工分配的任务或者答应的事情经常没有做到，如果是客观原因，一定要尽力帮助解决；如果判断为人才质量问题，走法律允许的程序迅速将人炒掉。我见过几次炒的比较慢，那对团队造成的负面作用可不是闹着玩的。\n　　3、树立高的期望值并加以衡量\n　　作为领导者，你需要设定足够高但仍合理的期望. 足够高使得你的团队不会感到无聊。仍合理使得他们不至于油尽灯枯。你要给他们创造一段经历，使得在旅程结束时，他们回过头来看会说 —— &quot;他妹的， 我都没想到我居然做到了这个，这个屌爆了。&quot; 在 Facebook, 和其他硅谷高技术公司一样，期望同薪酬相结合。每半年 Facebook 都有5-6个公司级的大目标，所有人的奖金算法中都会考虑该目标的完成情况。因此树立明确的期望本身就至关重要。\n　　另外， 你需要找到一个不容争辩的途径来衡量期望。我花了大量时间和团队一起制定下季度里最重要的3-5个目标并有数据化的衡量指标(一个目标背后可以有多个指标)。根据工作量把目标分别委派给单个或多个攻城狮，或者让他们自己揽。在这一情况下，我们不仅有可衡量的目标，使得我们可以迅速地说出来我们在做什么做到哪了，同时也知道每个具体目标后面的负责人是谁。团队的表现和个体表现挂钩，所以他们失败了我即不成功。例如， 当年我们团队最大的成果就是在一年时间里，通过每季度不同的指标，让信用卡支付的投诉率降低了75%.\n　　有一点要强调的是 —— 期望还是要基于现实要合理。在你只有 10% 的市场份额的时候却幻想 10 几倍的收入增长无疑不现实。Steve Jobs 乔老爷是这方面的老手，非常善于推动他的团队超越潜能但同时也榨干他们（虽然他们后来还是为他们所做到的而自豪一辈子）99.9% 的领导者不是乔老爷，也不需要是。更可行的是在团队的真实极限中找到一个可持续性的驱动来激励团队超越自我。\n　　4、重视数据而不盲从数据\n　　决定产品方向时， 要的是想象力， 激情和胆量， 而不是数据。数据能让你的团队沿着正确的方向前进而不出轨，也有助于产品从“一开始是什么样”到“最后应该是什么样”的逐渐优化成型。但数据不能帮你决定方向。举个例子，当我们在人工智能(机器学习)上压上我们团队所有的资源的时候，我们忐忑不安。但是我们坚信一点，现有的基于人工规则引擎的防欺诈系统会很快成为死胡同，因为它太死板而且不易规模化以处理大数据。所以，就像在电影指环王中 Frodo 明知通向 Mordor 的道路很黑很冷很危险，但那是一条他必须要选择去走的路；我们选择了在机器学习上压上所有的宝。失败，整个团队会很难看；但我们决定走艰难但我们认为是正确的路。这种思路同样应用在如何设计用于用户报告(外部工具)和案例审查(内部工具)的工具来应对潜在的欺骗行为。我们最后决定的方向是“进行自动处理”和“建立反馈机制”。直接抛给人工来处理总是很容易被选的一条路， 因为只要建立一个人多人傻的客户支持团队即可。Lame! 我们希望通过自动处理来解决大部分的欺诈案例，而把精力则放在那些确实需要单独处理的特殊案例上，同时把从业务支持团队(即客户支持部门)的处理意见自动采集并集成到下一轮的机器学习中去。由此，我们的机器判断会越加精确和聪明且与时俱进.\n　　但你不能忽视数据。没有数据的支撑而一味靠直觉走黑路， 很容易走岔道， 甚至大错特错。有一段时间我们认为爬行工具(通过分析关联的cookie, 信用卡)可能可以找到很多欺诈的同伙。通过实验结果却发现， 这种预期是否成立很大程度上取决于当前流行的欺诈行为的特点。比如，当失窃或贩卖信用卡的案例非常普遍的时候，关联分析是一种有效的方法。但如果主要情况是帐户被黑或小宝们冒用妈妈的信用卡去网游消费时，关联分析就作用不大。直觉在现实前面碰了一脸的灰。不过幸运的是我们很快意识到这点且把这个项目叫停了， 所以没有浪费太多的资源。\n　　另外， 顺带提一下A/B测试。A/B测试并不会告诉你去做什么产品，但它可以帮你确定实现产品时的哪个细微版本更能揪住用户大爷们的心。\n　　5、避免无谓的时间浪费\n　　刚进 Facebook 做工程师的时候，我非常享受那种日夜泡在码海中的感觉。后来慢慢的承担的项目责任越来越大越来越多，写代码的时间越来越少(但绝大多数时候仍占大头)。有时候更多的是把时间花在决定产品的方向和设计上。很多事情是和产品经理设计人员一起搞的。但在 Facebook 攻城狮们有很大的发言权，甚至有些时候是拍板的权力。Facebook 希望攻城狮们有王者风范。Facebook 希望攻城狮能决定自己要做什么应该做什么，而不是总是&quot;被决定&quot;做什么(一种流行的说法是，write your own job description). 因此，我花了大量的时间在思考这些问题 —— 哪些功能需要添加，哪些功能需要删掉，需要开始或停掉哪些测试，我们正在流血流汗的是不是现在最最最重要的问题，我们是该花时间优化用户交互流程呢，还是减少出错率， 还是让系统更快，等等。这些问题很伤脑筋，答案经常不确定，比一个劲码到手抽筋要难。但这些问题很重要， 甚至可能决定了你熬的日日夜夜究竟有没有必要。建议所有的攻城狮思考思考代码之外的这些问题，团队领导者就更有必要了。当然，攻城狮的大多数时间还是应该花在代码上。\n　　那究竟哪些时间不应该被浪费呢？\n　　很多，但我只举两个我认为最重要的例子。\n　　邮件。不是所有邮件都发而平等。有些邮件纯粹打酱油的，有些邮件是不需要马上处理的。我尝试使用过滤规则来踢掉打酱油的邮件，突出需要马上处理的重要邮件。对此，分享两点。\n　　1) 建立一个适合你的邮件过滤系统。我会对重要和紧急的邮件做即刻回复，而暂缓处理那些可以等到晚上再回复的邮件（尤其是发自我自己的团队，产品经理，兄弟连和顶头的不顶头的上司们的邮件）。但是，我要确保在我挣扎的爬到床上之前，把这些邮件全部处理掉， 读的读， 回的回。对于那些仅供参考的邮件，过滤系统会将其塞到某个固定的角落，我隔三差五去瞅瞅。此类邮件诸如某酒鬼询问 Napa Valley 哪个酒窖比较正点等等. 这些邮件通常比较有趣， 挖的坑很大很深所以也很耗时间， 我通常不跳或者不马上跳。\n　　2) 广而告之你的个人邮件处理策略。我让我身边的战友们知道我是如何处理邮件的， 并把这个政策放到我所有的邮件末端。如是说 —— “正在尝试个人邮件处理策略 —— 为了戒掉 Email 瘾， 我将强迫自己每隔三小时或以上查看一次 Email，急事请电话/短信/IM 我”，这么做更多的是让别人明白不要指望马上得到回应。其实我查 email 比每 3 小时要频繁，但至少不用马上逼得去回每个 email 了，我可以憋着悠着点。因为如果真的很急，我的 iPhone 应该已经响过了。而且，批量处理真的效率要高很多。不骗你。\n　　会议。开会太容易变成一群人互相在扯对方的蛋。浪费时间而且开完后发现没有结论且很蛋疼。但开会对于 teamwork 很多时候是必要的。如何主持会议是门学问，这里不细谈。不过，你不可能也不需要参加每个邀请你的会议。当你认为你参加某会议于己于人都无太多价值的时候，建议你考虑不去。如果想要有礼貌一点， 那就写个 email 问问主持人你是否可以缺席。通常当你想过这个问题决定发这样的邮件时，答案通常都会是 yes。有些时候我也会很可耻的让我的产品经理替我去开会。当然，我会鼓励他也争取不要去。Only make the meetings you really have to. 同样，我要求我自己的团队在组织和参加会议的时候要慎重，也经常问他们想想看自己花在会议上的时间是不是多了。一个做法是把可能的会议都整合在一起。有一个例子。早些时候，我们会经常收到来自支持团队的比较随意的会面请求。这让攻城狮的一天被会议分割得支离破碎。写代码的都知道没有3-4个小时的连续时间是不容易高潮的。而且这种会议通常效率很低。于是，我们改变了做法，每周安排固定的答疑时间(office hour)和支持团队嗑想法然后 follow up。当然， 紧急的问题另当别论应当马上处理.\n　　有一个被经常忽略的原则 ——&nbsp;有意识地去思考哪些事情不应该做并且马上不做。例如，哪些是无谓的争论可以避免介入，哪些功能可以放弃，哪些关系不应该发展， 哪些人应该开掉，等等。我经常问自己一个很简单的问题，我现在正在做的是否对我的目标很重要。如果你清楚自己正在做的和自己想要的，答案会明了。Go for it。\n　　6、增进亲密感是减少紧张关系的有效方式\n　　工程师和支持团队之间有着纠结的合作竞争关系(注意， 合作在前)。互联网技术公司中很多人(尤其是聪明人)总是期望工程师对所有问题给出一个让人会心一笑的解决方案。但现实是，不是每一个问题都可以或者应该在技术框架下解决。对于一些具体的问题， 客户支持和运营部门会有一些非常深刻独到的见解。工程师未必行，毕竟很多见解需要不同的专业知识， 依靠实地经验。没错， 工程师可以在代码中自动 log 大量的原始数据，但从原始数据中提炼可靠的判断却并不总能如愿。和很多其他公司的客户或支持部门不同，我们的支持部门招募了质量相当好的员工(很多来自美国名校 —— 在我直接接触的反欺诈支持组 20 来人中就有 3 名斯坦福校友)。因此，当两群都很聪明的人观点相左时，该听谁的呢? 紧张关系再所难免。\n　　不同的工程师团队也存在着合作竞争关系。 反垃圾邮件、安全和反欺诈（我的团队）这几个团队之间存在密切的工作协作关系。这些团队也都尽可能地相互学习，分享经验和技术。但是，有时候各团队独立处理类似但不同的一些问题时，都试图向对方推销自己的解决方案和理念。\n　　如何让合作竞争保持在一种健康有序的状态?&nbsp;我觉得关键是促进人与人之间的亲密感。把人搞近了，事情就容易了。我花大量时间用在建立和其他团队的关系上面。例如两周一次或者一月一次和其他团队老大们的 1 对 1 碰头会。越相关的团队，头碰得越频繁。我自己或者我的团队成员会有选择性的经常参加一些其他团队的会议 (我们称之为 Friends &amp; Family meeting)。当为一个共同的大项目工作时，我曾安排不同的部门成员（工程师、支持、数据分析、金融财务）坐到一起进行项目冲刺。这是拉近相互之间距离的非常有效的一个做法， 尤其对于减少扯皮的机会。因为互相之间经常会请或被请喝咖啡 (可称之为&quot;咖啡外交&quot;)。我也会经常和一些人约定吃工作午餐， 经常聊的是家常， 增的是感情。有的时候一次长距离的散步也更能让人畅所欲言。而这样的紧密关系，在我们面对一个极具挑战性的项目的关键时刻，会帮助大家紧紧的抱团闯关。\n　　7、习惯委托， 但不要盲目， 请谨慎\n　　分配任务委托别人的重要性比较容易理解。因为你不是超人，不能端茶倒水什么都做吃喝拉撒什么都管。有些时候，你往往还不是最适合的人选。当团队一大，事情一多，你一定要学会委托别人来负责合适的任务。对有些领导者而言， 委托别人一个重要的目标可能不是很放心，觉都睡不好；但我非常习惯委托别人，有时候可能太习惯了。这是我一位前老板给我指出来的一个问题。有一次我给一位组员分配了一个既有技术难度又有协调挑战的难题，进程比较缓慢。但我给了他太多的时间空间来折腾， 而事实上他在某些方面需要一些加强，有些方面需要我更多的主动的帮助。我老板指出来，如果我要让别人随便折腾的话，前提是我需要有足够的信心。我需要有事实来逐渐证明我的决定是正确的。需要谨慎委托，因为如果项目失败， 对他而言， 最终负责的人还是我，不是别人。所以我不能以别人不行来给失败的委托埋单。\n　　如果你有一个重要的任务需要委托给别人， 你要么：\n　　1) 已经对此人非常了解，知道他战斗力非凡可以搞定，或者相信他可以迅速学习提高打鸡血搞定；\n　　要么\n　　2) 需要在一开始手把手教他，时不时问他，直到你对他有足够的信心。\n　　具体我是这么做的。项目开始时，我让被委托人给我一个整体计划以及几天内可以完成的任务。一开始经常会面跟进，然后确定后几天的任务。根据每次完成状况来估计他能不能“高快狠”地完成最终的目标。信心逐渐建成后可以减少关于该项目的细节讨论，此时的委托可以放得更开。但有一点要注意，如果跟的太紧的话， 可能让人觉得你对他不放心，他也会做得畏首畏尾，这可能比盲目的委托还更差。所以在委托和谨慎之间， 有一个微妙平衡。\n　　我觉得在这一点上我还要加强，这里也和大家提个醒。\n　　8、意见反馈应该一个持续性的， 而不是一年一次或两次的活动\n　　一年一度或两度的意见反馈在硅谷公司是非常常见的。它的目的不是设置起来给员工难堪，让他们互相责难的。它的目的是希望员工对自己对他人有更全面的认识，以助进步。意见反馈有自我反馈和同事反馈两部分。自我反馈是自己评定自己，完成了哪些目标，错失了哪些目标，哪些方面做好了，哪些方面还待进步。但由于是自己踢球兼裁判，难免有偏颇。同事反馈，就像一枚镜子，让你看到 180 度之外的自己。在 Facebook, 360 度的正式意见反馈是一年两次，并且和薪酬挂钩。但近年来，意见反馈和薪酬评定逐渐分开。比如我做的一件事就是季度性的意见反馈，时间和正式评定错开。在那几天中，我请求所有相关组的同事在自愿的前提下给我写写关于我直属组员的意见反馈，短短几句都行。我会收集，综合，最后在1-1碰头会时反馈给我的组员。\n　　如果需要等半年才来收集意见的话，很多相关故事早以忘得一干二净。故事越久远，记忆越模糊，意见越空洞， 说了等于没说。而且，意见反馈和薪酬绑在一起，正常人(即使是牛人)都会很自然的把心眼更多的放到薪酬上，而不是意见本身。\n　　除了季度性的轻型意见反馈， 日常的意见反馈如果有的话应当立马传递，趁热打铁效果更好。\n　　如何有效传递整理好的意见也很重要，有句话是说&quot;it\'s not what you say that matters, it\'s how you say it&quot;. 我没那么极端，我觉得如何传递意见也同样重要。有两种方式我都试过，不确定哪种更有效。这里都谈一谈。一种是以问为主逐渐深入促其思考，比如&quot;how did you think about the meeting you hosted yesterday&quot;; 另外一种是赤裸裸的直入主题， &quot;hey, let\'s talk about the meeting you held yesterday&quot;， 然后开始谈我自己的感觉.不管哪种方式，一定要给对方一个解释自己行为的机会；永远假设并告诉他我相信他的意愿是好的。为了避免陷入“你昨天做了 xxx”，“&quot;没有， 我做的是 yyy”，“我觉你是做了 xxx”的死循环式的争论，我首先争取和他们在&quot;我们感知的即是事实&quot;这一点上达成共识。基于这点前提， 我们把讨论的重点放在如何做能改变别人的感受，最后让事情能顺利完成， 毕竟大多数重要的事都有很多人一同协作完成。当他们认识到自己想要改进某个方面的时候，如何改是一个相对容易很多的问题 —— 聪明人一向能够找出改进的办法，我所做的就是配合他们做头脑风暴。最终谈话的目的是产生一个下次如何能做的更好的具体方案。\n　　关于有效传递意见反馈， 另有 4 点提一下。\n　　1) 意见反馈不见得都是负面的。它可以是别人的一个长处，你很欣赏，你希望他这方面坚持做，做得更多。比如一句&quot;hey, I really love your weekly summary email with the key metrics at the top. Please keep them coming&quot;，可能产生很好的激励效果。\n　　2) 意见反馈必须摆事实和讲道理。如果你只是告诉别人他很烂，但不说什么时候烂过了以及为什么，除了给他添点火气之外无他用。所以我在相关人员包括自己写意见反馈的时候要求提供实例，比如一句 &quot;I think he could make meetings transparent and shorter by having an agenda, like the weekly data review meeting on last Friday&quot;比&quot;his meeting is too long&quot;，更有血有肉有效。\n　　3) 意见反馈必须是可操作的。让人无从下手的意见意义不大。如果在提意见的同时提出一个方案以供参考就有意义的多。但注意，绝不能是命令的方式 (那是中青宝…)，比如前面的例子&quot;I think he could make meetings transparent and shorter by having an agenda sent ahead of time…&quot;就很容易操作。\n　　4) (个人偏好) 在最近的两个评价周期中，我给 15 个左右的同事(一半不直属我)写过意见反馈。我把我写的直接分享给他们。出于这种想法，在我下笔时就少了很多冲动。因为他们会读，所以我无法做到背后捅刀。因为他们要读，所以我需要写得有意义，容易理解，并且加上很多例子。并且，我欢迎他们和我直接讨论。如此一来，他们也明白我写这些反馈的一片苦心是为了他们进步。\n　　9、你可以比你想象的做得刚好\n　　这不是说说而已。我自己就有一个亲身的例子，我们曾经认为把一个高得离谱的欺诈率降到所允许的范围内会很难，的确很难。但想想看我们最终牛逼了一把，把它降到了比允许上限的一半还要低，感觉很爽，很长一段时间内整个团队士气高昂信心爆棚做事像开了外挂。\n　　牛人们总是不断的超越自己。给他们一个离谱的目标，配以应有的工具，适当的帮助，足够的信心还有一定的时间，他们会让你大吃一惊，也会让自己大吃一惊。这一点，乔帮主是行家，屡试不爽。\n　　但做到这一点有一个前提 ——&nbsp;不能害怕犯错。如果犯错是被要严惩的，失败是不允许的话，牛人们只能在框框中被圈养，没有办法实现突破。有一句话我经常挂在嘴上&quot;ask for forgiveness, not for permission&quot;. 在 Facebook, 大胆行事犯错是容易被原谅的。\n　　但反过来，有一点要小心，就像第 7 点所说的 —— 你不能随便把一个离谱的目标交给一个人，然后期待他来给你惊喜，盲目带来的可能是惊吓。你需要真正的牛人，至少是潜在牛人。而作为一个领导者，你的一个任务是帮助他们，鼓励他们，来引爆自己的潜力点。Facebook 不缺此类待引爆的牛人。\n　　10、不要过多设计或者过早优化\n　　有些工程师有一股出于本能的冲动想把自己的程序规模化，甚至在这些程序还没看到大规模使用的曙光之前。我在 Facebook 开始的时候，也是冲动型工程师一类。但经历过几次失败的产品之后，我牢记了这个教训。不要过多设计或者过早优化，把核心功能设计的简单精炼。只有在看到产品有被大规模使用的趋势后， 才来增加功能或增加规模量。有一个我做的产品使用的上限是 200 万月用户(当时 Facebook 整个月用户群是 4000 万左右)，但我的实现已经做了很多额外的功来满足更多的用户，做的时候感觉很爽(感觉自己很牛，感觉再多人用产品也不会崩溃)， 之后感觉很惨。\n　　但这一点不一定能适用于架构上的工作，比如 Friendster 这个网站的失败就是其基础架构的性能长期无法应对急速增长的用户以致网站很慢甚至崩溃。在用户增长高潮来临之前，你应该已经在架构上做了足够多的前戏，否则搞不好就要像 Friendster 收摊子散伙。但同时也要意识到，你所看到的用户访问模式，你的网站功能，在你只有 10 万用户的时候，可能和你有 1 亿用户的时候会很不一样。所有太多太早太频繁的架构上的大动作可能会适得其反。这一点上，你要小心判断。\n　　结语:\n　　在 Facebook 的 4 年半很好玩，我学到的感受到的远多于以上的十项，但希望这个分享能对朋友们有点帮助。同时祝所有的朋友在自己现在扮演的角色上都有好运。\n\n        ', null);
INSERT INTO `blog` VALUES ('26', '程序员推荐简单有效的科学健脑方法', '\n            \n \n\n勤练脑力可使记忆力增强，勤做有氧运动可使大脑灰质增加，勤于思考可使理智与情感有机互补。\n　　这些措施看上去很美，但美中不足的是，它们对大脑的训练都不够彻底，这也是越来越多此类研究的通病。记忆训练对大脑的好处当然比看真人秀什么的要靠谱得多，但这些训练充其量也就能够让你更容易想起已经储存在大脑皮层周围的零散信息，对于增长知识、提高智商意义不大。\n　　它们不会告诉你美联储是怎么运作的、南北战争时期输的为什么是南方、毕加索的名画《亚维农的少女》有什么了不起、Word为什么会崩溃。它们更不会给你带来改善日常生活的宝典秘籍。试想，如果有一种健脑方法能够帮助你打通任督二脉，获得非凡的理解力和记忆力（从而在年金投资这类领域避免风险）、掌握驰骋职场的小窍门（比如制作动感十足的PPT)、锻炼整合信息的能力（从而更好地揣摩老板的心思），那岂不是一法在手，天下我有？\n　　人们热衷于健脑，无非是想让自己知识更渊博、理解更透彻、思维更灵活、记忆更深刻、眼界更开阔。一言以蔽之，就是想变聪明，而不仅仅是要高效管理已有的知识储备。智力训练的好处在于你能一眼看出公司年报中的关键数字，一听便知商家和广告是不是在坑人（使用XX装瓶机，“增强鱼缸水的分子架构”，让您的宠物暹罗斗鱼更加健康？去你的），稍加琢磨便可读懂有关致病因子的医学研究，稍加点拨便可想通欧元解体对我们的养老金折子有什么影响，稍事思考便可参透职场、情场、沙场上的正确抉择。\n　　去年的一项研究引起了我们的注意。传统观念认为，人的智商在幼儿期就已定型，此后要想改变非常困难；但此项研究表明，智商不仅可以提升，而且还不是一两分的小数目。根据《自然》杂志去年9月刊载的这篇独具开创性的学术论文，4年的功夫就足以让人的智商提升21分（弄不好的话也可以降低18分）。\n　　高智商所带来的，不仅仅是门萨俱乐部的船票和令人艳羡的相亲资本。智商测试考验的是人的工作记忆力（短期记忆力）、空间感知力、图像识别力等一系列重要能力，全方位反映了一个人在空间、语言、分析乃至更深层次领域的认知技能。在这个测试中，“能进步20分就已经很了不起了，”上述研究的领导者、伦敦大学学院认知科学家凯茜&middot;普莱斯表示，“如果一个人的智商能从110分升到130分，他就能从‘智力平平之辈’一跃成为‘智力超群者’。\n　　相反，如果他的智商从104分降到84分，原来还是‘中等偏上’的智力水平一下子就成了‘中等偏下’。”普莱斯虽然只在12-20岁的人群中做过研究，但她认为自己的成果适用于所有人，因为最近也有一些新研究表明，即便到了花甲之年，人的大脑依然具有可塑性——即根据外界环境改变自身结构的能力。“我觉得人的智商在成年之后也可能发生显著的改变，”她说，“（青少年时期表现出来的）大脑可塑性可能不会随着年龄的增长而衰退。”\n　　智商的增减与大脑结构的改变究竟存在着怎样的联系？普莱斯及其研究小组对这一问题进行了探究。根据脑扫描结果，39%的受试者在语言智商发生显著改变的同时，左脑运动皮质的部分区域灰质密度和灰质体积都发生了相应改变（即神经元的数量有所增减），这些区域在人们阅读、说话、辨识事物的过程中会被激活；21%的受试者在非语言智商（即空间推理等非语言能力）有所升降的同时，小脑前叶控制手部运动的区域灰质密度也发生了相应改变。虽然人们通常以为运动技能与认知技能如同油与水互不相溶，但事实上有不少研究表明，感觉-运动能力的提高对于增强认知能力颇有益处。其中的原因尚不明确，但足以说明，人脑两大系统之间的联系可能比人们想象的更加紧密。因此，学做针线活、欣赏古典音乐、掌握一门杂耍可能都是行之有效的健脑益智活动。\n　　虽然人们一直认为，作为“大脑便签本”的短期记忆只不过是智商衡量标准的一个方面，然而近几年一项研究表明，单是提升了短期记忆力可能就足以提升综合智商。2008年，密歇根大学的苏珊娜&middot;耶吉领导的一项智力研究震惊了业界，该研究表明，短期记忆力对智力的直接促进作用可能超乎任何人的想象。\n　　研究人员对一批成年志愿者做了培训，让他们完成一项颇具挑战性的短期记忆任务：一边听研究人员说的一连串字母，一边同时看好几个电脑屏幕上显示的蓝色方框的位置，每个屏幕的蓝框位置各不相同，每个字母对应一组蓝框的位置。接着研究人员打乱顺序重念字母、重放蓝框的位置，要求志愿者说出听到的字母是否与蓝框的位置对应，或者蓝框的位置是否与之前相符（这项测试的合理之处在于采用了渐进式矩阵考察人的智商：给出三个几何图形，让人找出其中的规律，再从众多图形中选出第四个，使之符合这一规律）。研究人员发现，短期记忆力的训练强度越大，脑力最直接的表现形式——流体智力的改善越大。流体智力是根据已有知识独立理清问题、解决问题的能力。同年7月，苏珊娜的研究小组在学龄儿童身上进行了同样的试验，结果相同，说明记忆力与智商具有直接关联，记忆训练可能是提升智商的最可靠途径。\n　　埃里克&middot;坎德尔曾因发现记忆的细胞分子机制而成为2000年诺贝尔生理学与医学奖得主之一，这位来自哥伦比亚大学的神经学家表示：“科学界对脑力训练能否增强认知能力还有争议，但如果你真的下狠功夫去练记忆力，比方说背莎士比亚十四行诗什么的，你可能真能改善某些方面的认知功能。”\n　　神经影像可以帮助人们认识记忆训练对智力的直接影响。脑扫描结果显示，在记忆训练的过程中，外侧前额皮质、顶叶皮质下区、前扣带回、基底神经节呈现出活跃的状态，说明这些区域与记忆有关。有趣的是，这些区域在人们推理、思考的时候同样会被激活。“最近的一些研究已经开始显现出实实在在的效果，我对此持谨慎乐观的态度，”天普大学心理学家杰森&middot;钱表示。他本人也参与了一项研究，结果显示，成年人在经过4周充满挑战的工作记忆（短期记忆）训练后，其阅读理解能力也会显著提升。\n　　坎德尔说，取得这些进步的关键在于扎扎实实的“高强度训练，”而不是投机取巧的旁门左道。智商不是简简单单地吃点蓝莓、喝点石榴汁就能提升的。智商的高低取决于神经元及神经元之间的突触数量。学习的过程就是神经发生（神经元形成）和突触生成的过程。\n　　除了短期记忆力，注意力也是提高智商的突破口。神经学家已经一再强调，良好的注意力是学习能力出类拔萃的基石，其对智商的重要性也可想而知。在人潮熙攘的宴会上，只有用心倾听别人的介绍，你才会知道初次见面的心仪之人姓甚名谁。正因为注意力对人如此重要，“利他林”“阿德拉”这类神经兴奋药才有如此广阔的市场。这些“聪明药”到了考验记忆的关键时刻尤其管用，在临时抱佛脚的考生中大受追捧。\n　　它们能提升大脑多巴胺的水平，使人动力倍增，成就感油然而生，因此更容易全心全意地完成手头的任务。同样的道理，玩游戏有时也会出现相同的效果。研究表明，《太空堡垒》这类动作游戏和《国家的崛起》这类战略游戏有助于提升玩家的记忆力和一心多用的能力。至于提升智商的另一法宝，用普莱斯的话说，就是“狂热”。一个人如果对所读的书本和平日的见闻兴味索然，提不起劲来，学到了什么自然也不会上心。\n　　虽然健脑不在一朝一夕，但所幸我们也并非毫无头绪。常做有氧运动，锻炼的不仅仅是四头肌。每天行走30分钟，一周五次，能促进脑源性神经营养因子的分泌，这种分子能促进神经元和突触的生成，提高人的学习能力。伊利诺大学香槟分校的专家亚瑟&middot;克莱默领导的研究小组在进行神经影像研究的过程中发现，运动健身能使海马区的灰质增加，而海马区主要负责处理大脑接收的新知识，将其传递给额皮质永久储存。虽然这不能直接提升智商，但也能使大脑皮质储存更多的信息，增强人的知识储备。\n　　如果半小时的行走令你疲乏不堪，中午正好可以美美睡上一番。午休不仅能养精蓄锐，还能增强脑力。2010年加州大学伯克利分校的心理学教授马修&middot;沃克领导的一项研究证明了这一结论。研究人员首先让学生们完成一项考验大脑海马区的任务——记住120多张生面孔的名字，接着将学生分为两组，一组从下午两点开始午睡90分钟，另一组不午休。结果发现，第一组学生记住的名字更多。更令人吃惊的是，下午六点新一轮任务开始后，这组学生的表现更加突出。“忙了一上午，人的记忆力会下降，中午如果能睡上一会儿，记忆力不仅能复原，还会比睡前更好，”沃克说。因此，赞美耐克、谷歌这些人性化的公司吧，它们为员工提供了午休室。\n　　午睡为什么能增强脑力？我们可以从记录大脑活动的脑电图中一探究竟。人在进入睡眠状态后，大脑产生睡眠纺锤波，用沃克的话说，这就好比“香槟发酵时产生的白色泡沫”。这种脑电活动的活跃次数能够预示人在睡醒后学习能力的进步程度。据沃克猜测，睡眠纺锤波可能反映了信息从海马区转移到皮质永久储存的过程，好比U盘中的数据转存到了硬盘中。这样“不仅巩固了记忆，还释放了海马区的‘内存’，便于接收更多的信息”，沃克说。信息从海马区（缓存区）转移到皮质的能力越强，人的记忆力就越好。\n　　即便不午休，大脑也有办法走出精力衰退的低谷，这里就要提到一个神经学概念——“默认模式神经网络”，也就是人在放空状态下的大脑活动。日本东北大学的研究人员利用核磁共振成像测量了63名志愿者在放空状态下的脑血流量。他们发现，连接神经元的白质血流量越大，志愿者就越能在考验创造力的任务中快速提出新奇的点子。这一研究成果于去年11月发表在《科学公共图书馆&middot;综合》杂志上。创造力无非是看到他人看不见的联系，当大脑在默认模式下得以充分休息，白质血流量升高，使神经元之间的信息交流更加通畅，思维就会更加活跃，创造力也随之提升。所以说，没事不要老盯着手机看，发发呆其实也是“无为而无不为”的明智之举。\n　　要是觉得浑身是劲，根本无心发呆怎么办？那就喝杯咖啡，激奋起来吧！虽然这无助于提升创造力，但却能使头脑更加敏锐。这不仅仅是数万亿爪哇咖啡爱好者的心声，而且还经过了科学的论证。2011年，国立环境卫生研究所的塞丽娜&middot;杜德克等人在《自然神经科学》上发表论文，他们发现，给小鼠注射相当于两杯咖啡的咖啡因之后，小鼠海马神经元之间的钙离子浓度上升，生物电活动更加旺盛，神经元之间的连接更紧密，这也意味着大脑的学习能力和记忆力变得更强。\n　　要想改善大脑的高级认知功能，有一种方法最可靠，也最困难，那就是学外语。根据加拿大约克大学的认知学家艾伦&middot;比亚威斯托等人去年2月发布的研究成果，当一个人精通两种语言，他就要时不时在二者之间做出取舍，根据特定的情况使用特定的语言。比方说对于“人”这个词，是该说英语的man，还是说法语的homme？在这种情况下，与两种语言相关的皮质回路都会被激活，前额皮质必须介入其中做出正确的选择。由于前额皮质同时掌管着大脑的高级认知功能，双语训练在造就发达的前额皮质的同时，也在无形中锻炼了一系列高智商人士不可或缺的本领，如解决问题的能力、一心多用的本领等等。此外，研究人员还发现，学外语或可将痴呆症的发作时间推迟5年。\n　　健脑训练大多耗时耗力，更不要说掌握一门外语了，因此，人们自然而然地希望能有一些健脑益智的美味佳肴，毕竟，吃东西多简单呀！然而，天上不会掉馅饼。2010年，杜克大学循证医学中心对数百项研究进行分析后发现，许多备受推崇的所谓“健脑益智食谱”实则徒有虚名。那些富含维生素B6、B12、维生素E、叶酸的营养品根本无助于维持认知功能，更别说加以改善。\n　　以鱼类、果蔬、橄榄油为主的地中海式饮食虽有益健康，但要说它益智也没什么科学依据。总而言之，目前尚无证据表明，富含抗氧化剂、黄酮类化合物的食物能使人变聪明，但科学家对某些异国食材仍然抱有一丝希望。一些小范围的研究表明，石榴汁和印度烹饪中常用的香辛料姜黄根可能具有增强记忆力或改善其他认知能力的功效。\n　　健脑益智三部曲：品一杯味苦香浓的热咖啡，全身心投入高强度的记忆训练中，酣战过后的午间小憩使身心得到充分休整，训练之余的有氧运动让大脑得到充分呼吸；闲暇时玩玩动作游戏和战略游戏，培养骨灰级玩家的专注力；兴之所至，体验读书、观影、手工之乐，健脑休闲两相宜，心烦意乱之时，更可暂时放下缠身的杂务，任思绪天马行空地肆意驰骋。高智商养成于劳逸结合、有条不紊的修炼之中，只要内化于心，践之于行，您定能在崭新的一年乃至崭新的岁月开启无尽的智力宝库。\n\n        ', null);
INSERT INTO `blog` VALUES ('27', 'Javascript定义类(class)的三种方法（更好的继承手法）', '\n            \n \n\n作者：&nbsp;阮一峰\n　　日期：&nbsp;2012年 7 月 9 日\n　　将近 20 年前，Javascript 诞生的时候，只是一种简单的网页脚本语言。如果你忘了填写用户名，它就跳出一个警告。\n\n　　如今，它变得几乎无所不能，从前端到后端，有着各种匪夷所思的用途。程序员用它完成越来越庞大的项目。\n　　Javascript 代码的复杂度也直线上升。单个网页包含 10000 行 Javascript 代码，早就司空见惯。2010年，一个工程师透露，Gmail 的代码长度是 443000 行！\n\n　　编写和维护如此复杂的代码，必须使用模块化策略。目前，业界的主流做法是采用&quot;面向对象编程&quot;。因此，Javascript 如何实现面向对象编程，就成了一个热门课题。\n　　麻烦的是，Javascipt 语法不支持&quot;类&quot;（class），导致传统的面向对象编程方法无法直接使用。程序员们做了很多探索，研究如何用 Javascript 模拟&quot;类&quot;。本文总结了 Javascript 定义&quot;类&quot;的三种方法，讨论了每种方法的特点，着重介绍了我眼中的最佳方法。\n　　==============================================\n　　Javascript 定义类（class）的三种方法\n　　作者：阮一峰\n\n　　在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称&quot;实例&quot;）共有的属性和方法。\n　　Javascript 语言不支持&quot;类&quot;，但是可以用一些变通的方法，模拟出&quot;类&quot;。\n　　一、构造函数法\n　　这是经典方法，也是教科书必教的方法。它用构造函数模拟&quot;类&quot;，在其内部用 this 关键字指代实例对象。\nfunction Cat () {\n\n this.name = &quot;大毛&quot;;\n}\n　　生成实例的时候，使用 new 关键字。\nvar cat1 =\nnew Cat ();\nalert (cat1.name);\n//\n 大毛\n　　类的属性和方法，还可以定义在构造函数的 prototype 对象之上。Cat.prototype.makeSound =\nfunction (){\n alert (&quot;喵喵喵&quot;);\n}\n　　关于这种方法的详细介绍，请看我写的系列文章《Javascript 面向对象编程》，这里就不多说了。它的主要缺点是，比较复杂，用到了 this 和 prototype，编写和阅读都很费力。\n　　二、Object.create ()法\n　　为了解决&quot;构造函数法&quot;的缺点，更方便地生成对象，Javascript 的国际标准&nbsp;ECMAScript&nbsp;第五版（目前通行的是第三版），提出了一个新的方法&nbsp;Object.create ()。\n　　用这个方法，&quot;类&quot;就是一个对象，不是函数。\nvar Cat = {\n name: &quot;大毛&quot;,\n makeSound:\nfunction (){ alert (&quot;喵喵喵&quot;); }\n};\n　　然后，直接用 Object.create ()生成实例，不需要用到 new。\nvar cat1 = Object.create (Cat);\nalert (cat1.name);\n//\n 大毛\ncat1.makeSound ();\n//\n 喵喵喵\n　　目前，各大浏览器的最新版本（包括 IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署。\nif (!Object.create) {\n Object.create =\nfunction (o) {\n\nfunction F () {}\n F.prototype = o;\n\nreturn\nnew F ();\n };\n}\n　　这种方法比&quot;构造函数法&quot;简单，但是不能实现私有属性和私有方法，实例对象之间也不能共享数据，对&quot;类&quot;的模拟不够全面。\n　　三、极简主义法\n　　荷兰程序员 Gabor de Mooij 提出了一种比 Object.create () 更好的新方法，他称这种方法为&quot;极简主义法&quot;（minimalist approach）。这也是我推荐的方法。\n　　3. 1 封装\n　　这种方法不使用 this 和 prototype，代码部署起来非常简单，这大概也是它被叫做&quot;极简主义法&quot;的原因。\n　　首先，它也是用一个对象模拟&quot;类&quot;。在这个类里面，定义一个构造函数 createNew ()，用来生成实例。\nvar Cat = {\n createNew:\nfunction () {\n\n//\n some code here\n }\n};\n　　然后，在 createNew ()里面，定义一个实例对象，把这个实例对象作为返回值。\nvar Cat = {\n createNew:\nfunction () {\n\nvar cat = {};\n cat.name = &quot;大毛&quot;;\n cat.makeSound =\nfunction () { alert (&quot;喵喵喵&quot;); };\n\nreturn cat;\n }\n};\n　　使用的时候，调用 createNew ()方法，就可以得到实例对象。\nvar cat1 = Cat.createNew ();\ncat1.makeSound ();\n//\n 喵喵喵\n　　这种方法的好处是，容易理解，结构清晰优雅，符合传统的&quot;面向对象编程&quot;的构造，因此可以方便地部署下面的特性。\n　　3. 2 继承\n　　让一个类继承另一个类，实现起来很方便。只要在前者的 createNew () 方法中，调用后者的 createNew ()方法即可。\n　　先定义一个 Animal 类。\nvar Animal = {\n createNew:\nfunction () {\n\nvar animal = {};\n animal.sleep =\nfunction () { alert (&quot;睡懒觉&quot;); };\n\nreturn animal;\n }\n};\n　　然后，在 Cat 的 createNew () 方法中，调用 Animal 的 createNew () 方法。\nvar Cat = {\n createNew:\nfunction () {\n\nvar cat = Animal.createNew ();\n cat.name = &quot;大毛&quot;;\n cat.makeSound =\nfunction () { alert (&quot;喵喵喵&quot;); };\n\nreturn cat;\n }\n};\n　　这样得到的 Cat 实例，就会同时继承 Cat 类和 Animal 类。\nvar cat1 = Cat.createNew ();\ncat1.sleep ();\n//\n 睡懒觉\n　　3. 3 私有属性和私有方法\n　　在 createNew () 方法中，只要不是定义在 cat 对象上的方法和属性，都是私有的。\nvar Cat = {\n createNew:\nfunction () {\n\nvar cat = {};\n\nvar sound = &quot;喵喵喵&quot;;\n cat.makeSound =\nfunction () { alert (sound); };\n\nreturn cat;\n }\n\n};\n　　上例的内部变量 sound，外部无法读取，只有通过 cat 的公有方法 makeSound ()来读取。\nvar cat1 = Cat.createNew ();\nalert (cat1.sound);\n//\n undefined\n　　3. 4 数据共享\n　　有时候，我们需要所有实例对象，能够读写同一项内部数据。这个时候，只要把这个内部数据，封装在类对象的里面、createNew ()方法的外面即可。\nvar Cat = {\n sound: &quot;喵喵喵&quot;,\n createNew:\nfunction () {\n\nvar cat = {};\n cat.makeSound =\nfunction () { alert (Cat.sound); };\n cat.changeSound =\nfunction (x) { Cat.sound = x; };\n\nreturn cat;\n }\n};\n　　然后，生成两个实例对象：\nvar cat1 = Cat.createNew ();\n\nvar cat2 = Cat.createNew ();\ncat1.makeSound ();\n//\n 喵喵喵\n　　这时，如果有一个实例对象，修改了共享的数据，另一个实例对象也会受到影响。cat2.changeSound (&quot;啦啦啦&quot;);\ncat1.makeSound ();\n//\n 啦啦啦\n\n        ', null);
INSERT INTO `blog` VALUES ('28', '软件工程过程之文档标准', '\n            \n \n\n软件开发的标准过程包括六个阶段，而六个阶段需要编写的各类文件达14种之多。本文简单介绍了在每个阶段需要编写哪些文件，以及这些文件的主要内容。\nAD：\n\n标准的软件开发过程\n软件开发的标准过程包括六个阶段，而六个阶段需要编写的各类文件达14种之多，在每个阶段需要编写哪些文件，以及这些文件的主要内容见下：\n1.可行性与计划研究阶段\n可行性研究报告：在可行性研究与计划阶段内，要确定该软件的开发目标和总的要求，要进行可行性分析、投资一收益分析、制订开发计划，并完成应编制的文件。\n项目开发计划：编制项目开发计划的目的是用文件的形式，把对于在开发过程中各项工作的负责人员、开发进度、&nbsp;所需经费预算、所需软、硬件条件等问题作出的安排记载下来，以便根据本计划开展和检查本项目的开&nbsp;发工作。\n2.需求分析阶段\n软件需求说明书：软件需求说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，&nbsp;使之成为整个开发工作的基础。内容包括对功能的规定对性能的规定等。\n数据要求说明书：数据要求说明书的编制目的是为了向整个开发时期提供关于被处理数据的描述和数据采集要求的技术信息。\n初步的用户手册：用户手册的编制是要使用非专门术语的语言，充分地描述该软件系统所具有的功能及基本的使用方法。使用户（或潜在用户）通过本手册能够了解该软件的用途，并且能够确定在什么情况下，如何使用它。\n3.设计阶段\n概要设计说明书：概要设计说明书又可称系统设计说明书，这里所说的系统是指程序系统。编制的目的是说明对程序&nbsp;系统的设计考虑，包括程序系统的基本处理流程、程序系统的组织结构、模块划分、功能分配、接口设计。&nbsp;运行设计、数据结构设计和出错处理设计等，为程序的详细设计提供基础。\n详细设计说明书：详细设计说明书又可称程序设计说明书。编制目的是说明一个软件系统各个层次中的每一个程序&nbsp;（每个模块或子程序）的设计考虑，如果一个软件系统比较简单，层次很少，本文件可以不单独编写，有关&nbsp;内容合并入概要设计说明书。\n数据库设计说明书：数据库设计说明书的编制目的是对于设计中的数据库的所有标识、逻辑结构和物理结构作出具体的设计规定。\n测试计划初稿：这里所说的测试，主要是指整个程序系统的组装测试和确认测试。本文件的编制是为了提供一个对该软件的测试计划，包括对每项测试活动的内容、进度安排、设计考虑、测试数据的整理方法及评价准则。\n4.实现阶段\n模块开发卷宗（开始编写）：模块开发卷宗是在模块开发过程中逐步编写出来的，每完成一个模块或一组密切相关的模块的复审时编写一份，应该把所有的模块开发卷宗汇集在一起。编写的目的是记录和汇总低层次开发的进度和结果，以便于对整个模块开发工作的管理和复审，并为将来的维护提供非常有用的技术信息。\n用户手册完工\n操作手册：操作手册的编制是为了向操作人员提供该软件每一个运行的具体过程和有关知识，包括操作方法的细节。\n测试计划终稿：\n5.测试阶段\n模块开发卷宗(此阶段内必须完成)\n测试分析报告：测试分析报告的编写是为了把组装测试和确认测试的结果、发现及分析写成文件加以记载。\n项目开发总结报告：项目开发总结报告的编制是为了总结本项目开发工作的经验，说明实际取得的开发结果以及对整个开发工作的各个方面的评价。\n6.运行与维护阶段\n开发进度月报的编制目的是及时向有关管理部门汇报项目开发的进展和情况，以便及时发现和处理开发过程中出现的问题。一般地，开发进度月报是以项目组为单位每月编写的。如果被开发的软件系统规模比较大，整个工程项目被划分给若干个分项目组承担，开发进度月报将以分项目组为单位按月编写。\n对于一项软件而言，有些文件的编写工作可能要在若干个阶段中延续进行。\n鉴于软件开发是具有创造性的脑力劳动，也鉴于不同软件在规模上和复杂程度上差别极大，本指南认为在文件编制工作中应允许一定的灵活性，并不是14种文件每种都必须编写。\n文件编制的衡量因素\n◆在因素总和较低的情况下,项目开发总结报告的内容应包括：程序的主要功能、基本流程、测试结果和使用说明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◆测试分析报告应该写，但不必很正规。◆数据要求说明和数据库设计说明是否需要编写应根据所开发软件的实际需要来决定。\n例2：为了避免在软件开发中文件编制的不足或过分，一个简便的办法是把对软件文件的编制要求同软件的规模大小联系起来，这就是本例的出发点。软件的规模不妨分为四级：\n1．小规模软件源程序行数小于5&nbsp;000的软件；2．中规模软件源程序行数为&nbsp;10&nbsp;000～&nbsp;50&nbsp;000的软件；3．大规模软件源程序行数为&nbsp;100&nbsp;000?500&nbsp;000的软件；4．特大规模软件源程序行数大于500&nbsp;000的软件。\n对上述的四级软件的文件编制要求分别列于表O3。&nbsp;\n至于源程序行数为&nbsp;5&nbsp;000～&nbsp;10&nbsp;000，&nbsp;50&nbsp;000～&nbsp;100&nbsp;000的软件，其文件编制要求介于两级之间，可根据一个软件产品的具体情况，由项目负责人参照表O3的规定，确定需要编制的文件种类。\n对于源程序行数大于500&nbsp;000的特大规模软件，可进一步把本指南规定的十四种文件按实际需要扩展成更多种类。\n原文：http://developer.51cto.com/art/200612/36689.htm\n\n        ', null);
INSERT INTO `blog` VALUES ('29', '2012-06-18', '\n            \n \n写一部小说就像在黑夜里开车。你只能看到车灯照亮的部分，但是你却可以走完整个旅程。你不必看清你去往何处。不必看清你的目的地和沿途的一切。你只需要看清面前的一两米即可。\n\n        ', null);
INSERT INTO `blog` VALUES ('30', 'iframe自适应滚动条JS处理方法', '\n            &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; &nbsp;&nbsp;\nfunction iFrameHeight() { &nbsp;&nbsp;\nvar ifm= document.getElementById(&quot;iframepage&quot;); &nbsp;&nbsp;\nvar subWeb = document.frames ? document.frames[&quot;iframepage&quot;].document : ifm.contentDocument; &nbsp;&nbsp;\nif(ifm != null &amp;&amp; subWeb != null) {\n &nbsp;&nbsp;ifm.height = subWeb.body.scrollHeight + &quot;px&quot;;\n} &nbsp;&nbsp;\n} &nbsp;&nbsp;\n&lt;/script&gt;\n&lt;iframe id=&quot;iframepage&quot; src=&quot;${ctx}/text/list&quot; name=&quot;main&quot; frameBorder=0 scrolling=no width=&quot;100%&quot; onLoad=&quot;iFrameHeight()&quot;&gt;&lt;/iframe&gt;\n        ', null);
INSERT INTO `blog` VALUES ('31', 'solr3.5在tomcat下的部署', '\n            \n首先到solr官网http://mirror.bjtu.edu.cn/apache/lucene/solr/3.5.0/ 下载apache-solr-3.5.0.zip &nbsp;，同时需要准备一个tomcat，我在我的机器G盘上新建了一个tomcat-solr文件夹，然后分别把解压开的solr和tomcat放进去，改文件夹名字为solr和tomcat，好了，准备工作完毕\n一、在 G:\\tomcat-solr\\solr\\example\\webapps下有一个solr.war文件，讲它拷贝到G:\\tomcat-solr\\tomcat\\webapps 目录下\n二、拷贝 G:\\tomcat-solr\\solr\\example目录下的solr文件夹，整个拷贝到G:\\tomcat-solr\\tomcat\\webapps目录下\n在G:\\tomcat-solr\\tomcat\\conf\\Catalina\\localhost路径下新建一个solr.xml文件，如果这条路径不存在的话需要自己手动建立Catalina和localhost文件夹，在新建的solr.xml文件中添加 \n&lt;Context docBase=&quot;G:\\tomcat-solr\\tomcat\\webapps\\solr.war&quot; debug=&quot;0&quot; crossContext=&quot;true&quot;&gt;\n&lt;Environment name=&quot;solr/home&quot; type=&quot;java.lang.String&quot; value=&quot;G:\\tomcat-solr\\solr\\example\\solr&quot; override=&quot;true&quot;/&gt;\n&lt;/Context&gt; &nbsp;内容\n到此配置完成，启动G：\\tomcat-solr\\tomcat\\bin\\start.bat，在浏览器中输入http://localhost:8080/solr就可以看到solr完美启动了，8080端口可以在tomcat中更改，具体步骤网上有很多，记录完毕。 \n\n        ', null);
INSERT INTO `blog` VALUES ('32', '2012-06-09', '\n            \n \n谁都无知过谁都菜B过。\n何必老带着偏见呢？\n本是同根生，相煎何太急。\n何苦呢？\n\n不要老在那里泼冷水。\n也不要老把别人不当人看。\n我信奉一句话：有仇不是不报，只是时候未到。\n总有那么一天的。\n再牛的人也有不牛的时候。\n再怎么富有也会有落魄的时候。\n不过，话说回来，也是因为有这么一些人，年轻人才那个花枝招展啊！！！\n很简单，活着也就是那么一口气。\n\n我就碰到过这种人啦。\n不过，幸好，我跟他不熟。\n\n小程序员，只想证明自己是有价值的。\n小程序员，只想证明来过活过。\n小程序员，有纯洁的心。\n小程序员，有大大的梦想。\n\n        ', null);
INSERT INTO `blog` VALUES ('33', 'javascript中的闭包', '\n            \n \n\n由于Javascript中的函数是对象，对象的属性是集合，而属性的值又可以是对象，所以可以再函数内定义一个函数。如果在函数内部声明函数，然后在函数的外部调用，这个过程就产生了一个闭包。1、闭包的特性：\n下面来看一个例子说明闭包的特性：\nvar outter = [];function processor(){    for(var i=0; i&lt;4; i++){        var temp = {};        temp.id = i;        temp.invoke = function(){            alert(i);        };        outter.push(temp);    }}processor();  //执行到这里并不会输出outter[0].invoke();  //输出4outter[1].invoke();  //输出4outter[2].invoke();  //输出4outter[3].invoke();  //输出4\n在每次循环的时候，temp.invoke并不会被执行，只是在这里构造了一个函数而已，循环退出时，再用外部的数组outter的元素去访问invoke函数，这是，i已经是4了，所以所有的函数调用都输出为4。\n为了在循环中可以执行invoke函数，可以在里面声明一个匿名函数并立刻执行它：\nvar outter = [];function processor(){    for(var i=0; i&lt;4; i++){        var temp = {};        temp.id = i;        temp.invoke = function(no){            return function(){                alert(no);            }        }(i);        outter.push(temp);    }}processor();  //依次输出0,1,2,3可以看出，闭包允许你引用存在于外部函数中的变量，但是，并不是引用该变量创建时的值，而是使用该外部函数中该外部变量最后的值。2、闭包的作用：2.1、使用匿名函数自动执行，减少全局对象属性\n如果变量不加上var就会默认成为全局变量，即添加到全局对象的属性上去。如果别的函数误用了这些变量，造成全局对象过于庞大，影响了访问速度（从原型链上遍历获取变量的时间开销增加）。所以，爱实际情况中，如果有些函数只需要执行一次，如一些初始化函数，那么我们可以使用闭包让他自动执行，由于外部无法引用它内部的变量，所以在执行完后很快就会被释放，从而不会影响到全局变量：\nvar target = {    image :[&quot;01&quot;,&quot;02&quot;,&quot;03&quot;]}var screenBg = [];//使用target初始化screenBg的函数(function(tg){    for(var i=0; i&lt;tg.image.length; i++){        screenBg[i] = tg.image[i];    }})(target);alert(screenBg.join(&quot;,&quot;));2.2、使用闭包创建缓存：2.3、使用闭包实现封装：\n下面是使用闭包特性的一个封装例子：\nvar user = function(){    var name = &quot;default&quot;;  //局部变量外部无法访问    return{        setName : function(username){            name = username        },        getName : function(){            return name;        }    }}();alert(user.name);  //无法直接访问，输出为undefinedalert(user.getName());  //输出为default\n使用闭包，可以模拟实现面向对象中的对象。下面就改造上面的例子，实现一个类：\nvar User = function(){    var name = &quot;default&quot;;  //局部变量外部无法访问    return{        setName : function(username){            name = username        },        getName : function(){            return name;        }    }};//创建一个User对象var user1 = new User();user1.setName(&quot;arthinking&quot;);alert(user1.name);  //无法直接访问，输出为undefinedalert(user1.getName());  //输出为arthinking\n在函数式编程中，会大量用到闭包。3、使用闭包需要注意的问题：3.1、内存泄露：\n类似于Java，Javascript中的解释器提供了垃圾回收机制，一般是通过引用计数的形式。在闭包中，有些局部变量可能在将来的某些时刻要被使用，所以来及回收器不会处理这些被外部引用的局部变量。如果出现了引用循环，即，对象A引用了对象B，B引用了C，C又引用了A，这样引用计数就不会为0了，从而造成了内存泄露。3.2、上下文的引用：\nJavascript中的this指针表示的是调用对象的引用。在闭包中比较容易误用this指针。下面就举个例子：\n$(function(){    var con = $(&quot;#panel&quot;);    this.id = &quot;content&quot;;    con.click(function(){       alert(this.id);//panel     });});\n这里click中的函数this.id由于该函数是在click事件中的，所以this表示的是触发该click事件的组件，所以不会输出上面定义的id，而是输出该组件的id，如果想要在这个函数中输入上面的id可以这样处理：\n$(function(){    var con = $(&quot;#panel&quot;); this.id = &quot;content&quot;; var self = this;    con.click(function(){       alert(self.id);//content    });});除了文章中有特别说明，均为IT宅原创文章，转载请以链接形式注明出处。\n本文链接：\nhttp://www.itzhai.com/javascript-notes-javascript-closures.html\n\n        ', null);
INSERT INTO `blog` VALUES ('34', '再次找到新的面向对象的Javascript编程的好例子', '\n            \n \n\n\n\n\nJavascript本身是基于对象的（改正下，基于原型对象），而不是基于类的。而Javascript的函数语言特性使其本身是可编程的，它可以编程你想要的任何形式。\n下面来介绍如何使用Javascript进行面向对象风格的编程。1、原型继承：\nJavascript中级继承可以通过原型链来实现。在查找某个属性时，解释器会先在对象内部查找该属性，如果没有找到，则到其内部对象prototype上去查找，这样一直回溯整个原型链，直到找到该属性。下面举个例子：\n//原型继承function Base(){    this.baseFunc = function(){        alert(&quot;baseFunc&quot;);    }}function SubClass(){    this.subFunc = function(){        alert(&quot;subFunc&quot;);    }}SubClass.prototype = new Base();var subClass = new SubClass();subClass.subFunc();subClass.baseFunc();\n这种继承风格与传统的面向对象语言很不一样。2、引用：\nJavascript中的引用始终指向最终的对象：\n//引用var obj = {};var ref = obj;obj.name = &quot;object&quot;;  //通过obj引用修改了实际的对象alert(ref.name);    //显然ref引用的对象也添加了nameobj = [&quot;ab&quot;,&quot;cd&quot;];  //obj指向了新的对象obj.name = &quot;newObject&quot;;  //为新的对象添加name属性alert(ref.name);  //ref还指向原来的对象\n上面的obj只是指向了一个匿名对象，所以ref也不是直线obj，而是这个匿名对象。3、new操作符\n在Javascript中使用new操作符，和传统的OO编程不一样，不是通过构造器直接创建一个对象，而是首先创建了一个空的对象，然后调用Function的apply方法，将这个空对象作为第一个参数以及上下文参数传入apply方法，这样函数内部的this将会被这个空的对象所替代。\nfunction User1(username){    this.username = username || &quot;arthinking&quot;;    this.getUsername = function(){        return this.username;    }}var user = new User1(&quot;Jason&quot;);alert(user.getUsername());\n上面的new User1()其实相当于下面两句代码：\nvar user = {};User1.apply(user, [&quot;Jason&quot;]);4、封装：\n通过使用var定义局部变量封装属性，this.func定义公开的方法：\nfunction User2(username){    //私有属性    var info = &quot;User Info&quot;;    //公有方法    this.getInfo = function(){        return info;    }    //公有属性    this.username = username;}var user2 = new User2(&quot;arthinking&quot;);alert(user2.getInfo());alert(user2.username);5、为类添加静态变量：\nUser2.Flag = &quot;Constant&quot;;\n在访问User2.Flag时，不需要实例化User2类，这一点与传统的面向对象的静态变量是一样的。6、Base工具包：\nhttp://dean.edwards.name/base/Base.js\nBase是由Dean Edwards开发的一个Javascript的面向对象的基础包。该工具包只有140行代码，支持类的定义，封装，继承，子类调用父类的方法。不少项目都在使用Base作为底层的支持。\n使用Base创建类时，需要给Base.extend方法传入一个JSON对象。该对象包括一个constructor构造方法。\n//创建一个武器类var Weapon = Base.extend({    constructor : function(name){        this.name = name;    },    name : null,    handle : function(){        alert(&quot;使用&quot;+ this.name +&quot;攻击&quot;);    }});//创建一个角色类var Role = Base.extend({    constructor : function(roleName){        this.roleName = roleName;    },    roleName : null,    weapon : null,    attack : function(){        alert(this.roleName);        this.weapon.handle();    },    setWeapon : function(weapon){        this.weapon = weapon;    }});//实例化武器和角色var sword = new Weapon(&quot;剑&quot;);var role1 = new Role(&quot;剑士&quot;);role1.setWeapon(sword);role1.attack();除了文章中有特别说明，均为IT宅原创文章，转载请以链接形式注明出处。\n本文链接：\nhttp://www.itzhai.com/javascript-note-object-oriented-javascript-programming.html\n\n\n\n        ', null);
INSERT INTO `blog` VALUES ('35', '2012-06-16', '\n            \n \n我不做研究，也自知没有做研究的底子。嗯，我现在更确定这个想法。谢谢。\n\n        ', null);
INSERT INTO `blog` VALUES ('36', '史上最全的熬粥方法-留下慢慢学', '\n            \n \n史上最全的熬粥方法\n1、浸泡：煮粥前先将米用冷水浸泡半小时，让米粒膨胀开。这样做的好处：a、熬起粥来节省时间；b、搅动时会顺着一个方向转；c、熬出的粥酥、口感好。\n2、开水下锅：大家的普遍共识都是冷水煮粥，而真正的行家里手却是用开水煮粥，为什么？你肯定有过冷水煮粥糊底的经验吧？开水下锅就不会有此现象，而且它比冷水熬粥更省时间。\n3、火候：先用大火煮开，再转文火即小火熬煮约30分钟。别小看火的大小转换，粥的香味由此而出！\n4、搅拌：原来我们煮粥之所间或搅拌，是为了怕粥糊底，现在没了冷水煮粥糊底的担忧，为什么还要搅呢？为了“出稠”，也就是让米粒颗颗饱满、粒粒酥稠。搅拌的技巧是：开水下锅时搅几下，盖上锅盖至文火熬20分钟时，开始不停地搅动，一直持续约10分钟，到呈酥稠状出锅为止。\n5、点油：煮粥还要放油？是的，粥改文火后约10分钟时点入少许色拉油，你会发现不光成品粥色泽鲜亮，而且入口别样鲜滑。\n6、底、料分煮：大多数人煮粥时习惯将所有的东西一股脑全倒进锅里，百年老粥店可不这样做。粥底是粥底，料是料，分头煮的煮、焯的焯，最后再搁一块熬煮片刻，且绝不超过10分钟。这样熬出的粥品清爽不浑浊，每样东西的味道都熬出来了又不串味。特别是辅料为肉类及海鲜时，更应粥底和辅料分开。\n\n其次，就是根据个人口味、季节和功效来熬制各种自己喜爱的粥！参考资料如下：\n\n1.皮蛋瘦肉粥:\n主料：大米、里脊肉、皮蛋、青豌豆。\n调配料：葱、姜、料酒、盐、生抽、鸡精、香油。\n做法：\n1、大米淘洗干净，和平时一样熬粥就好（我加入了几颗泡好的青豌豆）。\n2、里脊肉先用一勺料酒腌一会，去腥。\n3、然后入锅焯一会，七八成熟就可以捞出来，切成小丁，用一点盐和生抽腌一下入味。\n4、皮蛋切好后，入锅蒸一下，因为生的皮蛋有一股特殊味道，蒸一下就好了。\n5、粥好后，将皮蛋和瘦肉放入，放入葱姜蒜末，继续小火熬煮。\n6、直至所有材料完全熬好了，放鸡精，几滴香油，就可以出锅了。\n\n\n长沙醉味小吃技术培训\nwww.cszuiwei.com 您身边的健康饮食顾问\n\n\n2.八宝粥：\n八种配料：大米、糯米、小米、黄豆、绿豆、红豆、红枣、桂圆。\n做法：\n1、各种豆类浸泡一夜，米类浸泡半天，红枣洗净，干桂圆去壳。\n2、所有材料加入适量水和冰糖，放砂锅中，大火烧开，小火煮到粥软烂粘稠即可。\n\n\n\n长沙醉味小吃技术培训\nwww.cszuiwei.com 您身边的健康饮食顾问\n\n3.腊八粥：\n材料：红枣、核桃、黑米、香米、玉米、葡萄干、红豆、小米。\n\n\n做法：\n1、红豆，玉米提前泡3-4小时。\n2、其他材料混合洗净。\n3、所有材料混合放入锅内，加足量水，烧开小火熬成粥即可。\n\n\n\n\n\n\n4.百合莲子羹：\n材料：\n银耳花3朵&nbsp;&nbsp; 莲子20克&nbsp;&nbsp; 干百合20克&nbsp;&nbsp; 冰糖100克&nbsp;&nbsp; 枸杞10克&nbsp;&nbsp; 清水适量\n作法：\n1、把银耳用温水泡发约半小时后洗净，剪去根部，然后用手撕成小片；莲子、百合和枸杞也分别用温水泡发。\n2、把撕成小片的银耳放入砂煲内，倒入足够多的清水，开大火煮开后盖上盖子转文火煲2个半小时（注意不要溢锅哟）。\n3、待银耳煮至浓稠后，放入冰糖搅拌均匀、然后倒入莲子，盖上锅盖小火煮半小时\n4、最后放入百合和枸杞再煮15分钟左右即可熄火，将煮好的银耳羹放入冰箱冷藏后食用口感超级赞哟。\n\n\n\n小贴士：\n1、银耳要煮很长的时间才会粘稠，所以建议家里有高压锅的用高压锅来煮，排气后用最小火再焖半个小时才可以哟。\n2、莲子、百合煮的时间不能太长，不然就化成粉末了，但是莲子要在百合前入锅，枸杞最后才放入，枸杞放入过早会产生酸味。\n\n\n\n5.养颜木瓜粥：\n用料：红枣，桂圆，枸杞，红葡萄干，木瓜，泰国糯米，黄冰糖\n做法：\n1、煮红枣。红枣我事先没泡好，它需要煮的时间最长，所以先煮。煮的这个时间就可以把桂圆，枸杞，红葡萄干（用青葡萄干一样可以的）用清水泡上。如果事先泡好了红枣，这一步就可以省了，直接下米锅里得了。\n2、红枣煮得有点发胀就可以放糯米了，但不要放多，糯米会发开，再就是还得给剩下的食材留点地方。\n3、糯米煮出浆了直接把桂圆，枸杞，木瓜，黄冰糖放进去煮到满意为止，呵，，葡萄干在粥煮好后再放，经过长时间煮的葡萄干会有点酸味。\n\n\n长沙醉味小吃技术培训\nwww.cszuiwei.com 您身边的健康饮食顾问\n百合红枣粥：\n\n原料：江米30克勤克俭，百合9克，红枣10枚，白糖适量。\n\n1、先将百合用开水泡一次，以沏支一部分苦味。\n2、江米淘净，和百合、红枣用文火缓熬成粥，加白糖适量即成\n鸡肉粥：\n（1）鸡胸肉切成细丝，用盐和油腌一会儿；煮白米粥，半熟时倒入鸡丝，搅匀了再煮；粥快好时，放些姜丝和其它调味绿色菜，加盐。起锅，喝。\n（2）非常要点（加了菜的粥和白米粥的最大区别）：加菜粥绝对不可以长时间煮。米淘洗后必须用水泡十分钟，然后用擀面杖碾碎，控制在大都半粒的样子。这样煮粥的时间短，口感好，所谓&quot;生滚&quot;嘛。\n（3）重要小贴士（可能大家都知道）：煮粥加水一次加够，不得加两次水。\n（4）如果用鸡肉切成小丁，出锅后加点小葱丝，就接近广州&quot;鸡粒粥&quot;了。\n\n\n鱿鱼粥：\n\n把鱿鱼丝，蒜末，都先在锅里煸炒一下，煸出香味。\n等到粥好了的时候先放鱿鱼丝，等一会儿，再放煸好的蒜末，香菜末，为了漂亮还可以放些葫萝卜丁，很细小的，那个味道非常香，对了，别忘了放盐和鸡精。\n\n广州的粥其实就是&quot;生滚粥&quot;\n\n意思就是先要熬好一锅粥，然后就把一部分的粥倒在小锅里煮，等到粥煮沸后就把调好味的材料放进去一起煮，直到再沸腾时就可以了。\n\n至于材料就随个人爱好（如：牛肉片、猪肉片、鱼片等，如果喜欢的话可以加一点姜丝和葱花）\n\nPS;每次煮的时候最好分量不要太多，一两碗就好，分量多了煮的时间长材料就会过火了。\n\n先用骨头煲汤,再用那个汤来熬粥,会特别的好吃,也很有营养.\n\n皮蛋粥就加入碎的皮蛋,起锅时加入盐、葱花、还有胡椒粉，看个人口味吧。重点就是粥要熬得好。\n\n\n红枣粥：\n\n红枣具有良好的补益作用，其性平和，能养血安神，适用于久病体虚、脾胃功能薄弱者服食。\n\n红枣粥香甜可口，可治疗体弱，病后身虚、气血两亏、营养不良、脾胃虚弱、贫血等，并有保护肝脏的作用。\n\n红枣粥对美容护肤也是大有益处的。\n\n方法：取红枣50克，粳米100克，同煮为粥，早、晚温热服食。\n长沙醉味小吃技术培训\nwww.cszuiwei.com 您身边的健康饮食顾问\n\n\n山药粥：\n\n山药味甘平，是一种性质平和的滋补脾、肺、肾的食物。据近代医学研究，山药含有淀粉酶、胆碱、粘液质、糖蛋白和自由氨基酸、脂肪、碳水化合物、维生素C及碘、钙、磷等。山药中所含的淀粉酶，有人称之为“消化素”。\n\n因为它能分解蛋白质和碳水化合物，所以有滋补效果。中老年人在春季里经常食用山药粥，补益颇多。\n\n方法：取干山药片45～60克，或鲜山药100～200克，洗净切片，与粳米100克同煮粥，早、晚餐食用。\n\n\n芝麻粥\n黑芝麻适量，淘洗干净、晾干炒熟研碎，每次取30g，与大米lOOg同置锅中加水煮成粥，此粥具有补肝肾、润五脏的功效，适合身体虚弱、头发早白、大便干燥、慢性便秘者食用。\n\n龙眼粥：\n龙眼肉30e，粳米100eI同煮作粥。龙眼又称桂圆，具有大补气血、养气安神的作用，人们常将其作为冬令进补佳品，用以补虚疗损。\n\n牛奶粥：大米100日淘洗干净，入锅加水按常法煮粥，当米将煮烂时，倒入300g牛奶稍煮即成。牛奶含有丰富的蛋白质及多种维生素与矿物质，与米做粥同食具有特殊的奶香。\n\n\n白木耳粥\n材料：白木耳60克，糯米100克。\n白木耳先用清水发泡洗净。糯米淘净后，置入锅内加水烧开，再放入银耳，熬煮成粥，调入一些冰糖即成。\n此粥滋阴生津、润肺养胃、益气和血，可治虚劳咳嗽、痰中带血、阴虚口渴。\n\n鸡粥。\n\n材料：小母鸡一只，姜片，米。\n做法：水开放鸡，煮到水再次开，舀掉上层鸡油，下米下姜。煮到鸡肉骨分离，米绵软。\n绝对香！！！\n\n\n豆粥：\n\n材料：各种豆类。可以是眉豆，小麦，绿豆，芝麻等。\n做法：和米同放，煲。\n\n冰糖莲子粥\n\n原料：\n主料：江米250克\n配料：净莲子100克\n调料：冰糖200克\n做法：①江米用清水淘清，沥水，入沸水中将米煮制成粥。\n②净莲子经过初步加工，去掉红衣，捅莲心、再上屉蒸熟\n③锅置旺火虽加入清水2500克，江米、蒸熟莲子，一起放入锅内加入冰糖，小火熬制熟烂成粥。\n\n甘草绿豆粥—本品清热解毒，可凉吃或热吃。\n\n原料：\n主料：大米150克\n配料：绿小豆50克，甘草50克\n调料：白糖适量\n做法：①大米用清水淘净、沥水\n②绿小豆去掉杂质，用清水洗净沥水\n③甘草洗净用沙布包成小包\n④锅置旺火上放入清水甘草包，将水熬制成金黄色，放入绿豆再烧沸，放入大米熬煮，成粥后加入白糖，调匀即可食用。\n特点：色泽黄绿；清香宜人；甜香味美。\n\n小米红糖粥\n\n原料：\n主料：小米100克\n配料：红糖适量\n做法：①选用优质小米用清水淘洗干净，沥水。\n②锅置旺火上，加入小米和清水，烧沸后改用小火慢慢熬煮成粥，加入红糖调匀，再烧沸即成。\n\n\n山莲葡萄粥\n\n原料：\n主料：糯米100克，香米50克，大米50克。\n配料：山药30克葡萄干30克，调料：冰糖（白糖）适量。\n做法：\n①糯米、香米、大米、用清水淘净，沥水。\n②山药用清水刷洗干净，削去外皮，切成米粒丁，莲子去掉外衣膜，捅出莲心，葡萄干先用清水洗净；再用清水稍泡、洗净。\n③锅置旺火上，加入糯米，香米、大米，山药丁，莲子肉，和清水烧沸后改用小火熬煮，五成熟时加入葡萄干，冰糖（白糖）调均溶化即成。\n\n红枣莲子粥\n\n原料：\n主料：糯米100克，香米50克\n配料：红枣30枚，莲子50克\n调料：冰糖（白糖）适量\n做法：\n①糯米、香米用清水淘净、沥水\n②红枣用清水稍泡胀，莲子经加工捅出莲芯洗净。\n③锅置旺火上，加入清水5000克，糯米、香米、莲子一起烧煮，烧沸后小火熬煮，至米五成熟时加入红枣，冰糖（白糖）待糖调均熔化即可。\n\n阿胶红枣粥\n\n原料：\n主料：糯米60克\n配料：阿胶30克，红枣30枚\n调料：白糖适量。\n做法：\n①糯米用清水淘净，沥水。\n②阿胶放入研体中，捣成碎块，锅置微火上，加入清水和阿胶碎块，熬制成汁。\n③锅置旺火上，加入糯米和清水，烧沸后改用小火熬煮至八成熟时加入阿胶汁和红枣、白糖，继续熬煮成粥。\n\n冰糖银耳粥\n\n原料：\n主料：糯米100克\n配料：银耳50克，调料：冰糖适量。\n做法：\n①糯米用清水淘洗干净，沥水。\n②因而放入盆里加温水浸泡，泡发后摘净杂质和耳根，再用清水冲洗干净，沥水，切成小块。\n③锅置旺火上加入糯米和银耳、清水，烧沸后用小火熬煮至块成粥时加入冰糖，再煮至糖溶汁，糯米成粥\n\n皮蛋瘦肉粥\n\n原料:\n主料：大米350克\n配料：皮蛋6只，猪瘦肉500克，香菜\n调料：精盐、葱、姜段、大料\n做法：\n①猪精肉用清水洗净，剔去筋膜，切成薄片，用精盐、葱、姜、大料煮熟。\n②皮蛋去掉外壳，洗净后切成碎末，香菜叶切成小段。\n③大米用清水淘洗干净、沥水。\n④锅置旺火上，加入清水，烧沸后下入大米，烧煮20分钟成粥，加入肉丁，皮蛋粒，精盐、调匀，出匙加入香菜段即可食用\n\n虾 仁 米 粥\n\n原料:\n主料：大米250克\n配料：净虾仁150克，菠菜段少许\n调料：精盐、葱段、姜片、大料\n做法：\n①大米用清水淘净沥水\n②净虾仁用清水冲洗干净，挑去泥肠，再用清水冲净、沥水，放入微火锅中，加入清水虾仁，葱、姜、大料，煮至半熟\n③锅置旺火上，加入清水，烧沸后下入大米，再沸后改用小火熬煮至快熟时加入煮至半熟得虾仁，再烧沸时，加入少许精盐调好味即成。\n\n蟹 肉 粥\n\n原料:\n主料：富硒大米100克，河蟹3只\n调料：精盐适量\n做法：\n①大米用清水淘洗干净，沥水。\n②鲜河蟹，洗净后去壳，去腮，切除脚，把蟹黄取出，蟹脚的一端用刀切去，再用圆棒把蟹肉擀出。\n③锅置旺火上加入大米，烧沸后改用小火熬煮成粥，加入蟹肉和蟹黄，调制均匀，带快熟时加入少许精盐，食用时稍放香菜。\n\n\n甲 鱼 粥\n\n原料:\n主料：富硒大米100克\n配料：甲鱼一只\n调料：姜片、葱段、料酒、吉糖、精盐、胡椒粉各适量\n做法：\n①大米用清水淘洗干净，沥水\n②甲鱼背朝下放在砧板上，待其头伸出立即卡住，剁去头、剁去尾计脚爪，用八成熟的水稍烫，刮去黑皮，取出内脏，用清水清洗干净，再切成小块。\n③锅置旺火上，加入甲鱼块和鸡汤，料酒、姜片，葱段，煨至甲鱼肉熟烂时，再加入大米，再沸后用小火熬煮成粥，再加入精盐、胡椒粉即成。\n\n蔬菜牛肉粥\n\n蔬菜牛肉粥 原料：牛肉--40克，米饭--1/4碗，菠菜--1棵，肉汤--1/2杯，土豆、胡萝卜、洋葱--1/5 个，盐--若\n干\n\n制法（1） 准备牛肉精肉并磨碎。 （2） 将菠菜、胡萝卜、洋葱、土豆炖熟并捣碎。 （3） 将米饭、蔬菜和肉末放入锅中煮，并用盐调味。\n\n\n02 豆腐粥\n原料：米饭--1/6碗，肉汤--1/2杯，豆腐1/10块，盐--若干\n制法（1） 将豆腐切成小块。\n（2） 将米饭、肉汤、豆腐加水放在锅中同煮。\n（3） 煮至粘稠时加入适量的盐调味。\n\n03 鸡蛋粥\n原料：鸡蛋--1/2个，胡萝卜--1/5个，菠菜--1棵，米饭--1/4碗，肉汤--1/2杯，盐--若\n干\n制法（1） 将胡萝卜和菠菜炖熟切碎。\n（2） 将米饭、肉汤和切碎的胡萝卜、菠菜倒入锅中同煮。\n（3） 煮开之后放入捣好的蛋糊并搅开，加盐调味。\n\n04 蔬菜鱼肉粥\n原料：鱼白肉--30克，胡萝卜--1/5个，海带清汤--1/2杯，萝卜--20克，酱油--若干，米\n饭--1/4碗\n制法（1） 将鱼骨剔净，鱼肉炖熟并捣碎。\n（2） 将萝卜、胡萝卜用擦菜板擦好。\n（3） 将米饭、海带清汤及鱼肉、蔬菜等倒入锅内同煮。\n（4） 煮至粘稠时放入酱油调味。\n\n05 干酪粥\n原料：米饭--1/6碗，水--1/2杯，干酪--5克\n制法（1） 将干酪切碎。\n（2） 将米饭入锅加适量水煮。\n（3） 煮至粘稠时中入干酪，干酪开始溶化时将火关掉。\n\n06 豌豆粥\n原料：米饭--1/4碗，豌豆--5个，牛奶--1/4杯，盐--若干\n制法（1） 将豌豆用开水煮熟，捣碎并过滤。\n（2） 在米饭中加适量水用小锅煮沸。\n（3） 之后放入牛奶和豌豆，并用文火再煮。\n（4） 加盐调味。\n\n07 胡桃粥\n原料：糯米--1/3杯，胡桃--5个，红枣--1个，盐--若干\n制法（1） 将胡桃夹开把瓤取出，泡在水里，将其薄皮剥去并捣碎。\n（2） 将红枣去核并用水浸泡后捣碎。\n（3） 将胡桃、红枣、糯米加适量水放在小锅里煮。\n（4） 煮好后用盐调味。\n\n08 苹果麦片粥\n原料：燕麦片--3大匙，牛奶--1/4杯，苹果--1/6个，胡萝卜--1/3个\n制法（1） 将苹果和胡萝卜洗净并用擦菜板擦好。\n（2） 将燕麦片及擦好的1大匙胡萝卜放入锅中，倒入牛奶及1/4杯水用文火煮。（3） 煮\n开后再放入2大匙擦好的苹果直至煮烂。\n\n09 鱼肉牛奶粥\n原料：鱼白肉--1/6块，牛奶--1大匙，盐--若干\n制法（1） 将鱼肉抬掇干净，炖熟并捣碎。\n（2） 将鱼肉放在小锅里加牛奶煮，之后加盐调味。\n\n10 芋头粥\n原料：芋头--1/2个，肉汤--1大匙，酱油--若干\n制法（1） 将芋头皮剥掉切成小块，用盐腌一下再洗净。\n（2） 将芋头炖烂后捣碎并过滤。\n（3） 将肉汤及芋头放在小锅里煮，并不时地搅一下。\n（4） 煮至粘稠后加酱油调味。\n\n11 土豆粥\n原料：土豆--1/3个，牛奶--2大匙，熟蛋黄--1/4个，盐--若干\n制法（1） 将土豆去皮，炖烂，捣碎并过滤。\n（2） 将土豆加牛奶用文火煮，并轻轻搅拌，粘稠后加盐。\n（3） 将蛋黄捣碎放在土豆泥里。\n\n12 干酪面包粥\n原料：主食面包--1片，牛奶--2/3杯，干酪粉--1/2匙\n制法（1） 将主食面包的边沿剪掉之后撕成碎片。\n（2） 把撕碎的面包加牛奶用文火煮，煮成糊状后撒上干酪粉。\n也可以用蛋糕来代替面包做成蛋糕粥。\n\n13 胡萝卜酸奶粥\n原料：胡萝卜--1/10个，面粉--1小匙，卷心菜--10克，酸奶--1大匙，肉汤--3大匙，黄\n油--若干\n制法（1） 将卷心菜和胡萝卜要成细丝炖烂。\n（2） 用黄油将面粉略炒一下，加入肉汤、蔬菜煮，并轻搅。\n（3） 将炖好的材料冷却后与酸奶拌好\n\n14 番茄粥\n原料：番茄--1/8个，米饭--1/4碗，海带清汤--1/2杯，盐--若干\n制法（1） 将番茄泡在开水里，随即取出去皮去瓤，切碎。\n（2） 将米饭和海带清汤倒入小锅是煮。\n（3） 煮好后加入番茄，加盐调味。\n\n15 鸡肉粥\n原料：鸡胸脯肉--10克，米饭--1/4碗，海带清汤--1/2杯，菠菜--10克，酱油、白糖--若\n干\n制法（1） 将鸡胸脯肉去筋，切成小块，用酱油和白糖腌一下。\n（2） 将菠菜炖熟并切碎。\n（3） 米饭用海带清汤煮一下，再放入菠菜鸡肉同煮。\n\n16 裙带菜红蛤粥\n原料：干红蛤--2个，干裙带菜--20克，大米--1/4杯\n制法（1） 将红蛤和裙带菜用水泡开之后拧净水分并切碎。\n（2） 将泡好的米加适量的水一起倒入粉碎机磨碎。\n（3） 以1：10的比例将米和水调好，加入裙带菜和红蛤同煮。\n（4） 煮好之后用盐调味。\n\n17 红薯鸡蛋粥\n原料：红薯--1/6块，鸡蛋--1个，牛奶--2大匙\n制法（1） 将红薯去皮，炖烂，并捣成泥状。\n（2） 将鸡蛋煮熟之后把蛋黄捣碎。\n（3） 红薯泥加牛奶用文火煮，并不时地搅动。\n（4） 粘稠时放入蛋黄，搅匀。\n\n18 栗子粥\n原料：栗子--5个，海带清汤--1/2杯\n制法（1） 将栗子煮熟之后去皮，捣碎。\n（2） 海带清汤煮沸后加栗子同煮。\n栗子可强肠胃功能，有助于消化。婴儿腹泻时食用栗子，效果较好。\n\n19 蔬菜粥\n原料：牛肉--20克，大米--1/3杯，胡萝卜、洋葱--若干，香油、酱油--若干\n制法（1） 大米洗净用水泡好，牛肉、胡萝卜、洋葱切碎。\n（2） 用香油把牛肉在锅里炒一下，再入泡好的大米炒制。\n（3） 将大米炒至一定程度后加入胡萝卜和水，用文火煮烂，再用酱油调味。\n\n20 大酱粥\n原料：米粥--1小碗，大酱--1/2小匙，胡萝卜、洋葱、菠菜--若干\n制法（1） 将胡萝卜、洋葱、菠菜切成碎块。\n（2） 蔬菜加清汤煮制，随后放入米粥同煮。\n（3） 煮好之后放大酱调味。\n\n21 胡萝卜粥\n原料：准备胡萝卜(红萝卜)适量\n制作：把胡萝卜洗净去除根须 放入蒸锅内上米蒸熟蒸烂 取出晾凉捣烂成泥\n如果小孩喜吃甜食也可稍加白糖\n特点：清香适口胡萝卜味甘性平 有健脾助消化之功 并含有胡萝卜素B族维生素\n脂肪糖类其中含大量果胶 有收敛和吸附作用 患儿腹泻食用后可以抑制肠道蠕动\n对抑制消化不良 所引起的腹泻非常合适\n\n22 脊肉粥\n猪脊肉是指猪脊背上的精肉\n古代人已作为药用 其性味甘咸平 猪瘦肉含有丰富的蛋白质 并含有较多的碳水\n化合物 钙磷铁等营养成分 可防止发生营养不良\n原料： 猪脊肉100克粳米100克 食盐香油川椒粉各少许\n制作： 先将猪脊肉洗净切成小块 放锅内用香油炒一下然后 加入粳米煮粥待粥\n将烂熟时 加入盐胡椒粉调味再煮沸即成\n特点： 粥有肉香油等调味品 味道极好 此粥补益人体 小儿常食可防止发生\n贫血\n\n\n莲子桂圆粥\n\n[原料]莲子20克、龙眼肉10克、糯米50克。\n[做法]取莲子、龙眼肉、糯米同煮成粥。\n[用法]每日2次，温热食用。\n[作用]补心脾，益气血。适用于失血性贫血。\n[评注]桂圆大补、不宜久用；莲子能平补不峻、可以久服。伏案诵读、劳伤心脾、记忆减退、纳谷不香者，可常吃莲子粥。&nbsp;&nbsp;\n\n柏子仁粥\n\n[原料]柏子仁15克、粳米100克、蜂蜜适量。\n[做法]先将柏子仁去除皮、壳、杂质，捣烂，与粳米煮粥，待粥将时，兑入蜂蜜，稍煮开锅即可。\n[用法]每日2次，连服3天。\n[作用]润肠通便、养心安神。适用于心悸、失眠、健忘、长期便秘或老年性便秘。\n[评注]柏子仁甘平、有养心安神、滋阴养肝、舒脾润肠、美颜乌发等作用。柏子仁含脂肪油14%、少量挥发油、皂甙等物质，为常用的滋补安神药。\n\n酸枣仁粥\n\n[原料]酸枣仁末15克、粳米100克。\n[做法]先以粳米加水煮粥至将熟，加入酸枣仁末再煮片刻即可。\n[用法]早晚温服。\n[作用]养心、安神、敛汗。适用于神经衰弱、心悸、失眠、多梦、黑眼圈。\n[评注]酸枣仁末入粥中酸甘适口，深受欢迎。酸枣仁生用炒用均可，炒时间过常能破坏有效成分。可取酸枣仁微炒片刻研末，家庭可用擀面杖研磨。\n\n\n小米枣仁粥\n\n[原料]小米100克、酸枣仁末15克、蜂蜜40克。\n[做法]将小米加水煮粥至将熟，加入酸枣仁末，搅匀煮开即可。\n[用法]每日2次，加蜂蜜温服。\n[作用]补脾润燥，宁心安神。主治纳食不香、夜寐不宁、大便干燥。\n[评注]酸枣仁能宁心安神，小米可补脾养心。酸枣仁在锅内微炒片刻研末，家庭可用擀面杖研磨。\n. 绿豆粥\n[原料]\n绿豆30g，粳米100g\n[做法]\n1．将绿豆、粳米淘洗干净。\n2．把绿豆、粳米放入锅内，加水约500g，煮至米烂汁黏时即可离火食用。每日服食1-2次。\n[营养]\n内含蛋白质13.6g，脂肪0.65g，碳水化合物95.7g，钙39mg，磷25.9mg，铁2.7mg，维生素A0.20国际单位，维生素B10.2mg，维生素B21.5mg，尼克酸0.6mg，能产热453kcal。\n[功能]\n绿豆是一种非常好的解暑食品，能清热消暑、解毒消痛、利尿除湿，与粳米相搭配，煮成粥，又可健脾益气、养血生津，确为夏季解暑佳品，且因本品并非过于寒凉，不会滞胃凉脾，是产后防暑、解暑佳品。\n\n七. 银杏粥：\n益元气、补五脏、抗衰老，老年、体弱多病者尤佳。正常人食之健体。宜家庭食用。\n做法：\n银杏仁（去壳后用沸水烫去内种皮）6-10粒，冰糖少量，粳米2两，水适量，同时放入锅中，文火煮熟即成。以粳米成糊糜状即可。\n银杏宜与其他淡甜低糖的米粥类相配，如银杏八宝粥、银杏绿豆粥、银杏沙参莲子粥等，糖以冰糖、白糖为宜。\n\n\n        ', null);
INSERT INTO `blog` VALUES ('37', '关于Java异常处理', '\n            \n \n\n六种异常处理的陋习\n你觉得自己是一个Java专家吗？是否肯定自己已经全面掌握了Java的异常处理机制？在下面这段代码中，你能够迅速找出异常处理的六个问题吗？&nbsp;\n1 OutputStreamWriter out = ...&nbsp;2 java.sql.Connection conn = ...&nbsp;3 try { // ⑸&nbsp;4 Statement stat = conn.createStatement();&nbsp;5 ResultSet rs = stat.executeQuery(&nbsp;6 &quot;select uid, name from user&quot;);&nbsp;7 while (rs.next())&nbsp;8 {&nbsp;9 out.println(&quot;ID：&quot; + rs.getString(&quot;uid&quot;) // ⑹&nbsp;10 &quot;，姓名：&quot; + rs.getString(&quot;name&quot;));&nbsp;11 }&nbsp;12 conn.close(); // ⑶&nbsp;13 out.close();&nbsp;14 }&nbsp;15 catch(Exception ex) // ⑵&nbsp;16 {&nbsp;17 ex.printStackTrace(); //⑴，⑷&nbsp;18 }\n\n\n作为一个Java程序员，你至少应该能够找出两个问题。但是，如果你不能找出全部六个问题，请继续阅读本文。&nbsp;本文讨论的不是Java异常处理的一般性原则，因为这些原则已经被大多数人熟知。我们要做的是分析各种可称为“反例”（anti-pattern）的违背优秀编码规范的常见坏习惯，帮助读者熟悉这些典型的反面例子，从而能够在实际工作中敏锐地察觉和避免这些问题。&nbsp;反例之一：丢弃异常&nbsp;代码：15行-18行。&nbsp;这段代码捕获了异常却不作任何处理，可以算得上Java编程中的杀手。从问题出现的频繁程度和祸害程度来看，它也许可以和C/C++程序的一个恶名远播的问题相提并论??不检查缓冲区是否已满。如果你看到了这种丢弃（而不是抛出）异常的情况，可以百分之九十九地肯定代码存在问题（在极少数情况下，这段代码有存在的理由，但最好加上完整的注释，以免引起别人误解）。&nbsp;这段代码的错误在于，异常（几乎）总是意味着某些事情不对劲了，或者说至少发生了某些不寻常的事情，我们不应该对程序发出的求救信号保持沉默和无动于衷。调用一下printStackTrace算不上“处理异常”。不错，调用printStackTrace对调试程序有帮助，但程序调试阶段结束之后，printStackTrace就不应再在异常处理模块中担负主要责任了。&nbsp;丢弃异常的情形非常普遍。打开JDK的ThreadDeath类的文档，可以看到下面这段说明：“特别地，虽然出现ThreadDeath是一种‘正常的情形’，但ThreadDeath类是Error而不是Exception的子类，因为许多应用会捕获所有的Exception然后丢弃它不再理睬。”这段话的意思是，虽然ThreadDeath代表的是一种普通的问题，但鉴于许多应用会试图捕获所有异常然后不予以适当的处理，所以JDK把ThreadDeath定义成了Error的子类，因为Error类代表的是一般的应用不应该去捕获的严重问题。可见，丢弃异常这一坏习惯是如此常见，它甚至已经影响到了Java本身的设计。&nbsp;那么，应该怎样改正呢？主要有四个选择：&nbsp;1、处理异常。针对该异常采取一些行动，例如修正问题、提醒某个人或进行其他一些处理，要根据具体的情形确定应该采取的动作。再次说明，调用printStackTrace算不上已经“处理好了异常”。&nbsp;2、重新抛出异常。处理异常的代码在分析异常之后，认为自己不能处理它，重新抛出异常也不失为一种选择。&nbsp;3、把该异常转换成另一种异常。大多数情况下，这是指把一个低级的异常转换成应用级的异常（其含义更容易被用户了解的异常）。&nbsp;4、不要捕获异常。&nbsp;结论一：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。&nbsp;反例之二：不指定具体的异常&nbsp;代码：15行。&nbsp;许多时候人们会被这样一种“美妙的”想法吸引：用一个catch语句捕获所有的异常。最常见的情形就是使用catch(Exception ex)语句。但实际上，在绝大多数情况下，这种做法不值得提倡。为什么呢？&nbsp;要理解其原因，我们必须回顾一下catch语句的用途。catch语句表示我们预期会出现某种异常，而且希望能够处理该异常。异常类的作用就是告诉Java编译器我们想要处理的是哪一种异常。由于绝大多数异常都直接或间接从java.lang.Exception派生，catch(Exception ex)就相当于说我们想要处理几乎所有的异常。&nbsp;再来看看前面的代码例子。我们真正想要捕获的异常是什么呢？最明显的一个是SQLException，这是JDBC操作中常见的异常。另一个可能的异常是IOException，因为它要操作OutputStreamWriter。显然，在同一个catch块中处理这两种截然不同的异常是不合适的。如果用两个catch块分别捕获SQLException和IOException就要好多了。这就是说，catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。&nbsp;另一方面，除了这两个特定的异常，还有其他许多异常也可能出现。例如，如果由于某种原因，executeQuery返回了null，该怎么办？答案是让它们继续抛出，即不必捕获也不必处理。实际上，我们不能也不应该去捕获可能出现的所有异常，程序的其他地方还有捕获异常的机会??直至最后由JVM处理。结论二：在catch语句中尽可能指定具体的异常类型，必要时使用多个catch。不要试图处理所有可能出现的异常。&nbsp;反例之三：占用资源不释放&nbsp;代码：3行-14行。&nbsp;异常改变了程序正常的执行流程。这个道理虽然简单，却常常被人们忽视。如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，也要正确释放占用的资源。为此，Java提供了一个简化这类操作的关键词finally。&nbsp;finally是样好东西：不管是否出现了异常，Finally保证在try/catch/finally块结束之前，执行清理任务的代码总是有机会执行。遗憾的是有些人却不习惯使用finally。&nbsp;当然，编写finally块应当多加小心，特别是要注意在finally块之内抛出的异常??这是执行清理任务的最后机会，尽量不要再有难以处理的错误。&nbsp;结论三：保证所有资源都被正确释放。充分运用finally关键词。\n反例之四：不说明异常的详细信息&nbsp;代码：3行-18行。&nbsp;仔细观察这段代码：如果循环内部出现了异常，会发生什么事情？我们可以得到足够的信息判断循环内部出错的原因吗？不能。我们只能知道当前正在处理的类发生了某种错误，但却不能获得任何信息判断导致当前错误的原因。&nbsp;printStackTrace的堆栈跟踪功能显示出程序运行到当前类的执行流程，但只提供了一些最基本的信息，未能说明实际导致错误的原因，同时也不易解读。&nbsp;因此，在出现异常时，最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。&nbsp;结论四：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。&nbsp;反例之五：过于庞大的try块&nbsp;代码：3行-14行。&nbsp;经常可以看到有人把大量的代码放入单个try块，实际上这不是好习惯。这种现象之所以常见，原因就在于有些人图省事，不愿花时间分析一大块代码中哪几行代码会抛出异常、异常的具体类型是什么。把大量的语句装入单个巨大的try块就象是出门旅游时把所有日常用品塞入一个大箱子，虽然东西是带上了，但要找出来可不容易。&nbsp;一些新手常常把大量的代码放入单个try块，然后再在catch语句中声明Exception，而不是分离各个可能出现异常的段落并分别捕获其异常。这种做法为分析程序抛出异常的原因带来了困难，因为一大段代码中有太多的地方可能抛出Exception。&nbsp;结论五：尽量减小try块的体积。&nbsp;反例之六：输出数据不完整&nbsp;代码：7行-11行。&nbsp;不完整的数据是Java程序的隐形杀手。仔细观察这段代码，考虑一下如果循环的中间抛出了异常，会发生什么事情。循环的执行当然是要被打断的，其次，catch块会执行??就这些，再也没有其他动作了。已经输出的数据怎么办？使用这些数据的人或设备将收到一份不完整的（因而也是错误的）数据，却得不到任何有关这份数据是否完整的提示。对于有些系统来说，数据不完整可能比系统停止运行带来更大的损失。&nbsp;较为理想的处置办法是向输出设备写一些信息，声明数据的不完整性；另一种可能有效的办法是，先缓冲要输出的数据，准备好全部数据之后再一次性输出。&nbsp;结论六：全面考虑可能出现的异常以及这些异常对执行流程的影响。&nbsp;改写后的代码&nbsp;根据上面的讨论，下面给出改写后的代码。也许有人会说它稍微有点?嗦，但是它有了比较完备的异常处理机制。&nbsp;\nOutputStreamWriter out = ...&nbsp;java.sql.Connection conn = ...&nbsp;try {&nbsp;Statement stat = conn.createStatement();&nbsp;ResultSet rs = stat.executeQuery(&nbsp;&quot;select uid, name from user&quot;);&nbsp;while (rs.next())&nbsp;{&nbsp;out.println(&quot;ID：&quot; + rs.getString(&quot;uid&quot;) + &quot;，姓名: &quot; + rs.getString(&quot;name&quot;));&nbsp;}&nbsp;}&nbsp;catch(SQLException sqlex)&nbsp;{&nbsp;out.println(&quot;警告：数据不完整&quot;);&nbsp;throw new ApplicationException(&quot;读取数据时出现SQL错误&quot;, sqlex);&nbsp;}&nbsp;catch(IOException ioex)&nbsp;{&nbsp;throw new ApplicationException(&quot;写入数据时出现IO错误&quot;, ioex);&nbsp;}&nbsp;finally&nbsp;{&nbsp;if (conn != null) {&nbsp;try {&nbsp;conn.close();&nbsp;}&nbsp;catch(SQLException sqlex2)&nbsp;{&nbsp;System.err(this.getClass().getName() + &quot;.mymethod - 不能关闭数据库连接: &quot; + sqlex2.toString());&nbsp;}&nbsp;}&nbsp;if (out != null) {&nbsp;try {&nbsp;out.close();&nbsp;}&nbsp;catch(IOException ioex2)&nbsp;{&nbsp;System.err(this.getClass().getName() + &quot;.mymethod - 不能关闭输出文件&quot; + ioex2.toString());&nbsp;}&nbsp;}&nbsp;}\n\n\n\n本文的结论不是放之四海皆准的教条，有时常识和经验才是最好的老师。如果你对自己的做法没有百分之百的信心，务必加上详细、全面的注释。&nbsp;另一方面，不要笑话这些错误，不妨问问你自己是否真地彻底摆脱了这些坏习惯。即使最有经验的程序员偶尔也会误入歧途，原因很简单，因为它们确确实实带来了“方便”。所有这些反例都可以看作Java编程世界的恶魔，它们美丽动人，无孔不入，时刻诱惑着你。也许有人会认为这些都属于鸡皮蒜毛的小事，不足挂齿，但请记住：勿以恶小而为之，勿以善小而不为。------------------------------------------------------------------下面是一些java异常集-------------------------------------------------------------------------------------------\n\n\n\n算术异常类：ArithmeticExecption\n空指针异常类：NullPointerException\n类型强制转换异常：ClassCastException\n数组负下标异常：NegativeArrayException\n数组下标越界异常：ArrayIndexOutOfBoundsException\n违背安全原则异常：SecturityException\n文件已结束异常：EOFException\n文件未找到异常：FileNotFoundException\n字符串转换为数字异常：NumberFormatException\n操作数据库异常：SQLException\n输入输出异常：IOException\n方法未找到异常：NoSuchMethodException\njava.lang.AbstractMethodError\n抽象方法错误。当应用试图调用抽象方法时抛出。\njava.lang.AssertionError\n断言错。用来指示一个断言失败的情况。\njava.lang.ClassCircularityError\n类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。\njava.lang.ClassFormatError\n类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。\njava.lang.Error\n错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。\njava.lang.ExceptionInInitializerError\n初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。\njava.lang.IllegalAccessError\n违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。\njava.lang.IncompatibleClassChangeError\n不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。\njava.lang.InstantiationError\n实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.\njava.lang.InternalError\n内部错误。用于指示Java虚拟机发生了内部错误。\njava.lang.LinkageError\n链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。\njava.lang.NoClassDefFoundError\n未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。\njava.lang.NoSuchFieldError\n域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。\njava.lang.NoSuchMethodError\n方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。\njava.lang.OutOfMemoryError\n内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。\njava.lang.StackOverflowError\n堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。\njava.lang.ThreadDeath\n线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。\njava.lang.UnknownError\n未知错误。用于指示Java虚拟机发生了未知严重错误的情况。\njava.lang.UnsatisfiedLinkError\n未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。\njava.lang.UnsupportedClassVersionError\n不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。\njava.lang.VerifyError\n验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。\njava.lang.VirtualMachineError\n虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。\njava.lang.ArithmeticException\n算术条件异常。譬如：整数除零等。\njava.lang.ArrayIndexOutOfBoundsException\n数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。\njava.lang.ArrayStoreException\n数组存储异常。当向数组中存放非数组声明类型对象时抛出。\njava.lang.ClassCastException\n类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。\njava.lang.ClassNotFoundException\n找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。\njava.lang.CloneNotSupportedException\n不支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。\njava.lang.EnumConstantNotPresentException\n枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。\njava.lang.Exception\n根异常。用以描述应用程序希望捕获的情况。\njava.lang.IllegalAccessException\n违法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。\njava.lang.IllegalMonitorStateException\n违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。\njava.lang.IllegalStateException\n违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。\njava.lang.IllegalThreadStateException\n违法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。\njava.lang.IndexOutOfBoundsException\n索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。\njava.lang.InstantiationException\n实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。\njava.lang.InterruptedException\n被中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。\njava.lang.NegativeArraySizeException\n数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。\njava.lang.NoSuchFieldException\n属性不存在异常。当访问某个类的不存在的属性时抛出该异常。\njava.lang.NoSuchMethodException\n方法不存在异常。当访问某个类的不存在的方法时抛出该异常。\njava.lang.NullPointerException\n空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。\njava.lang.NumberFormatException\n数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。\njava.lang.RuntimeException\n运行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。\njava.lang.SecurityException\n安全异常。由安全管理器抛出，用于指示违反安全情况的异常。\njava.lang.StringIndexOutOfBoundsException\n字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。\njava.lang.TypeNotPresentException\n类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。\njava.lang.UnsupportedOperationException\n不支持的方法异常。指明请求的方法不被支持情况的异常。\n异常javax.servlet.jsp.JspException: Cannot retrieve mapping for action /Login （/Login是你的action名字） &nbsp;\n可能原因action没有再struts-config.xml 中定义，或没有找到匹配的action，例如在JSP文件中使用 &lt;html:form action=&quot;Login.do&quot;.将表单提交给Login.do处理，如果出现上述异常，请查看struts-config.xml中的定义部分，有时可能是打错了字符或者是某些不符合规则，可以使用strutsconsole工具来检查。-----------------------------------------------------------------------------------------------------------------异常org.apache.jasper.JasperException: Cannot retrieve definition for form bean null\n可能原因 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个异常是因为Struts根据struts-config.xml中的mapping没有找到action期望的form bean。大部分的情况可能是因为在form-bean中设置的name属性和action中设置的name属性不匹配所致。换句话说，action和form都应该各自有一个name属性，并且要精确匹配，包括大小写。这个错误当没有name属性和action关联时也会发生，如果没有在action中指定name属性，那么就没有name属性和action相关联。当然当action制作某些控制时，譬如根据参数值跳转到相应的jsp页面，而不是处理表单数据，这是就不用name属性，这也是action的使用方法之一。-----------------------------------------------------------------------------------------------------------------异常No action instance for path /xxxx could be created\n可能原因特别提示：因为有很多中情况会导致这个错误的发生，所以推荐大家调高你的web服务器的日志/调试级别，这样可以从更多的信息中看到潜在的、在试图创建action类时发生的错误，这个action类你已经在struts-config.xml中设置了关联（即添加了&lt;action&gt;标签）。\n在struts-config.xml中通过action标签的class属性指定的action类不能被找到有很多种原因，例如：定位编译后的.class文件失败。Failure to place compiled .class file for the action in the classpath (在web开发中，class的的位置在r WEB-INF/classes，所以你的action class必须要在这个目录下。例如你的action类位于WEB-INF/classes/action/Login.class,那么在struts-config.xml中设置action的属性type时就是action.Login).拼写错误，这个也时有发生，并且不易找到，特别注意第一个字母的大小写和包的名称。&nbsp;-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: No getter method for property username of bean org.apache.struts.taglib.html.BEAN\n可能原因没有位form bean中的某个变量定义getter 方法\n这个错误主要发生在表单提交的FormBean中，用struts标记&lt;html:text property=”username”&gt;时，在FormBean中必须有一个getUsername()方法。注意字母“U”。-----------------------------------------------------------------------------------------------------------------异常java.lang.NoClassDefFoundError: org/apache/struts/action/ActionForm\n可能原因这个错误主要发生在在classpath中找不到相应的Java .class文件。如果这个错误发生在web应用程序的运行时，主要是因为指定的class文件不在web server的classpath中（/WEB-INF/classes 和 /WEB-INF/lib）。在上面的错误中，原因是找不到ActionForm类。-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Exception creating bean of class org.apache.struts.action.ActionForm: {1}\n可能原因Instantiating Struts-provided ActionForm class directly instead of instantiating a class derived off ActionForm. This mightoccur implicitly if you specify that a form-bean is this Struts ActionForm class rather than specifying a child of this classfor the form-bean.\nNot associating an ActionForm-descended class with an action can also lead to this error.-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Cannot find ActionMappings or ActionFormBeans collection\n可能原因不是标识Struts actionServlet的&lt;servlet&gt;标记就是映射.do扩展名的&lt;sevlet-mapping&gt;标记或者两者都没有在web.xml中声明。\n在struts-config.xml中的打字或者拼写错误也可导致这个异常的发生。例如缺少一个标记的关闭符号/&gt;。最好使用struts console工具检查一下。\n另外，load-on-startup必须在web.xml中声明，这要么是一个空标记，要么指定一个数值，这个数值用来表servlet运行的优先级，数值越大优先级越低。\n还有一个和使用load-on-startup有关的是使用Struts预编译JSP文件时也可能导致这个异常。-----------------------------------------------------------------------------------------------------------------异常java.lang.NullPointerException at org.apache.struts.util.RequestUtils.forwardURL(RequestUtils.java:1223)\n可能原因在struts-config.xml中的forward元素缺少path属性。例如应该是如下形式：&lt;forward name=&quot;userhome&quot; path=&quot;/user/userhome.jsp&quot;/&gt;-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Cannot find bean org.apache.struts.taglib.html.BEAN in any scope\n\nProbable Causes试图在Struts的form标记外使用form的子元素。这常常发生在你在&lt;/html:form&gt;后面使用Struts的html标记。另外要注意可能你不经意使用的无主体的标记，如&lt;html:form … /&gt;，这样web 服务器解析时就当作一个无主体的标记，随后使用的所有&lt;html&gt;标记都被认为是在这个标记之外的，如又使用了&lt;html:text property=”id”&gt;还有就是在使用taglib引入HTML标记库时，你使用的prefix的值不是html。-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Missing message for key xx.xx.xx\nProbable Causes这个key的值对没有在资源文件ApplicationResources.properties中定义。如果你使用eclipse时经常碰到这样的情况，当项目重新编译时，eclipse会自动将classes目录下的资源文件删除。\n资源文件ApplicationResources.properties 不在classpath中应将资源文件放到 WEB-INF/classes 目录下，当然要在struts-config.xml中定义)-----------------------------------------------------------------------------------------------------------------异常Cannot find message resources under key org.apache.struts.action.MESSAGE\n可能原因很显然，这个错误是发生在使用资源文件时，而Struts没有找到资源文件。\nImplicitly trying to use message resources that are not available (such as using empty html:options tag instead of specifyingthe options in its body -- this assumes options are specified in ApplicationResources.properties file)\nXML parser issues -- too many, too few, incorrect/incompatible versions-----------------------------------------------------------------------------------------------------------------异常Strange and seemingly random characters in HTML and on screen, but not in original JSP or servlet.\n可能原因混和使用Struts的html:form标记和标准的HTML标记不正确。\n使用的编码样式在本页中不支持。-----------------------------------------------------------------------------------------------------------------异常&quot;Document contained no data&quot; in Netscape\nNo data rendered (completely empty) page in Microsoft Internet Explorer\n可能原因使用一个Action的派生类而没有实现perform()方法或execute()方法。在Struts1.0中实现的是perform()方法，在Struts1.1中实现的是execute()方法，但Struts1.1向后兼容perform()方法。但你使用Struts1.1创建一个Action的派生类，并且实现了execute()方法，而你在Struts1.0中运行的话，就会得到&quot;Document contained nodata&quot; error message in Netscape or a completely empty (no HTML whatsoever) page rendered in Microsoft Internet Explorer.”的错误信息。\n---------------------------------------------------------------------------------------------------------------------------异常ServletException: BeanUtils.populate解决方案在用Struts上传文件时,遇到了javax.servlet.ServletException: BeanUtils.populate异常。我的ActionServlet并没有用到BeanUtils这些工具类。后来仔细检查代码发现是在jsp文件里的form忘了加enctype=&amp;quot;multipart/form-data&amp;quot; 了。所以写程序遇到错误或异常应该从多方面考虑问题存在的可能性，想到系统提示信息以外的东西。----------------------------------------------------------------------------------------------------------------------------1. 定义Action后, 如果指定了name, 那么必须要定义一个与它同名的FormBean才能进行form映射.2. 如果定义Action后, 提交页面时出现 &quot;No input attribute for mapping path...&quot; 错误, 则需要在其input属性中定义转向的页面.3. 如果插入新的数据时出现 &quot;Batch update row count wrong:...&quot; 错误, 则说明XXX.hbm.xml中指定的key的类型为原始类型(int, long),因为这种类型会自动分配值, 而这个值往往会让系统认为已经存在该记录, 正确的方法是使用java.lang.Integer或java.lang.Long对象.4. 如果插入数据时出现 &quot;argument type mismatch&quot; 错误, 可能是你使用了Date等特殊对象, 因为struts不能自动从String型转换成Date型,所以, 你需要在Action中手动把String型转换成Date型.5. Hibernate中, Query的iterator()比list()方法快很多.6. 如果出现 &quot;equal symbol expected&quot; 错误, 说明你的strtus标签中包含另一个标签或者变量, 例如:&lt;html:select property=&quot;test&quot; onchange=&quot;&lt;%=test%&gt;&quot;/&gt;或者&lt;html:hidden property=&quot;test&quot; value=&quot;&lt;bean:write name=&quot;t&quot; property=&quot;p&quot;/&gt;&quot;/&gt;这样的情况...&nbsp;---------------------------------------------------------------------------------------------------------------------------错误：Exception in thread &quot;main&quot; org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update原因与解决： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为Hibernate Tools（或者Eclipse本身的Database Explorer）生成*.hbn.xml工具中包含有catalog=&quot;***&quot;（*表示数据库名称）这样的属性,将该属性删除就可以了---------------------------------------------------------------------------------------------------------------------------错误：org.hibernate.ObjectDeletedException: deleted object would be re-saved by cascade (remove deleted object from associations)原因与解决：方法1 删除Set方的cascade方法2 解决关联关系后，再删除方法3 在many-to-one方增加cascade 但值不能是none最后一招：检查一下hashCode equals是否使用了id作为唯一标示的选项了；我用uuid.hex时是没有问题的；但是用了native，就不行了，怎么办？删除啊！----------------------------------------------------------------------------------------------------------------------------问题：今天用Tomcat 5.5.12，发现原来很好用的系统不能用了，反复测试发现页面中不能包含 taglib，否则会出现以下提示：HTTP Status 500 -type Exception reportMessage description The server encountered an internal error () that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: /index.jsp(1,1) Unable to read TLD &quot;META-INF/tlds/struts-bean.tld&quot; from JAR file&quot;file:*****/WEB-INF/lib/struts.jar&quot;:原因：更新了工程用的lib文件夹下的jar，发布时也发布了servlet.jar和jsp-api.jar。解决：把jsp-api.jar删除就解决这个问题了。-----------------------------------------------------------------------------------------------------------------------------错误： java.lang.NullPointerException原因： 发现 dao 实例、 manage 实例等需要注入的东西没有被注入（俗称空指针异常）解决：这个时候，你应该查看日志文件；默认是应用服务器的 log 文件，比如 Tomcat 就是 [Tomcat 安装目录 ]/logs ；你会发现提示你：可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'sf\' defined in ServletContextresource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xmlorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xml……………………….Caused by: java.io.FileNotFoundException: src\\hibernate.cfg.xml可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'sessionFactory\' defined inServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not foundorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not found然后你就知道原因是因为配置文件的解析出了错误，这个通过 Web 页面是看不出来的。更多的是持久化影射文件出的错误；导致了没有被解析；当然你需要的功能就无法使用了。----------------------------------------------------------------------------------------------------------------------------错误：StandardWrapperValve[action]: Servlet.service() for servlet action threw exceptionjavax.servlet.jsp.JspException: Cannot retrieve mapping for action /settlementTypeManage或者： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type Status report &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message Servlet action is not available &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description The requested resource (Servlet action is not available) is not available.原因： 同 上----------------------------------------------------------------------------------------------------------------------------错误StandardWrapperValve[jsp]: Servlet.service() for servlet jsp threw exceptionjava.lang.ClassNotFoundException: org.apache.struts.taglib.bean.CookieTei界面错误具体描述：org.apache.jasper.JasperException: Failed to load or instantiate TagExtraInfo class: org.apache.struts.taglib.bean.CookieTei&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因与解决： &nbsp;&nbsp;&nbsp;&lt;方案一&gt;你的“html:”开头的标签没有放在一个&lt;html:form&gt;中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;方案二&gt;重新启动你的应用服务器，自动就没有这个问题\n\n        ', null);
INSERT INTO `blog` VALUES ('38', '面向对象的思维方法', '\n            \n \n\n面向对象的思维方法&nbsp;\n\n作者：范凯\n\nE-mail:&nbsp;robbin_fan@yahoo.com.cn\n\n\n我是从学习Java编程开始接触OOP(面向对象编程)，刚开始使用Java编写程序的时候感觉很别扭，因为我早以习惯用C来编写程序，很欣赏C的简洁性和高效性，喜欢C简练而表达能力丰富的风格，特别忍受不了Java运行起来慢吞吞的速度，相对冗长的代码，而且一个很简单的事情，要写好多类，一个类调用一个类，心里的抵触情绪很强。\n\n\n我对Java的面向对象的特性琢磨良久，自认为有所领悟，也开始有意识的运用OOP风格来写程序，然而还是经常会觉得不知道应该怎样提炼类，面对一个具体的问题的时候，会觉得脑子里千头万绪的，不知道怎么下手，一不小心，又会回到原来的思路上去。\n\n\n举个例子，要发广告邮件，广告邮件列表存在数据库里面。倘若用C来写的话，一般会这样思考，先把邮件内容读入，然后连接数据库，循环取邮件地址，调用本机的qmail的sendmail命令发送。\n\n\n然后考虑用Java来实现，既然是OOP，就不能什么代码都塞到main过程里面，于是就设计了三个类：\n\n\n一个类是负责读取数据库，取邮件地址，调用qmail的sendmail命令发送；\n\n一个类是读邮件内容，MIME编码成HTML格式的，再加上邮件头；\n\n一个主类负责从命令读参数，处理命令行参数，调用发email的类。\n\n\n把一件工作按照功能划分为3个模块分别处理，每个类完成一件模块任务。\n\n\n仔细的分析一下，就会发现这样的设计完全是从程序员实现程序功能的角度来设计的，或者说，设计类的时候，是自低向上的，从机器的角度到现实世界的角度来分析问题的。因此在设计的时候，就已经把程序编程实现的细节都考虑进去了，企图从底层实现程序这样的出发点来达到满足现实世界的软件需求的目标。\n\n\n这样的分析方法其实是不适用于Java这样面向对象的编程语言，因为，如果改用C语言，封装两个C函数，都会比Java实现起来轻松的多，逻辑上也清楚的多。\n\n\n我觉得面向对象的精髓在于考虑问题的思路是从现实世界的人类思维习惯出发的，只要领会了这一点，就领会了面向对象的思维方法。\n\n\n举一个非常简单的例子：假使现在需要写一个网页计数器，客户访问一次页面，网页计数器加1，计数器是这样来访问的\n\n\nhttp://hostname/count.cgi?id=xxx\n\n\n后台有一个数据库表，保存每个id（一个id对应一个被统计访问次数的页面）的计数器当前值，请求页面一次，对应id的计数器的字段加1(这里我们忽略并发更新数据库表，出现的表锁定的问题)。\n\n\n如果按照一般从程序实现的角度来分析，我们会这样考虑：首先是从HTTP GET请求取到id，然后按照id查数据库表，获得某id对应的访问计数值，然后加1，更新数据库，最后向页面显示访问计数。\n\n\n现在假设一个没有程序设计经验的人，他会怎样来思考这个问题的呢？他会提出什么样的需求呢？他很可能会这样想：\n\n\n我需要有一个计数器，这个计数器应该有这样的功能，刷新一次页面，访问量就会加1，另外最好还有一个计数器清0的功能，当然计数器如果有一个可以设为任意值的功能的话，我就可以作弊了。\n\n\n做为一个没有程序设计经验的人来说，他完全不会想到对数据库应该如何操作，对于HTTP变量该如何传递，他考虑问题的角度就是我有什么需求，我的业务逻辑是什么，软件应该有什么功能。\n\n\n按照这样的思路(请注意，他的思路其实就是我们平时在生活中习惯的思维方式)，我们知道需要有一个计数器类 Counter，有一个必须的和两个可选的方法：\n\n\ngetCount() &nbsp;// 取计数器值方法\n\nresetCounter() &nbsp;// 计数器清0方法\n\nsetCount() &nbsp;// 设计数器为相应的值方法\n\n\n把Counter类完整的定义如下：\n\n\npublic class Counter {\n\n&nbsp;public int getCount(int id) {}\n\n&nbsp;public void resetCounter(int id) {}\n\n&nbsp;public void setCount(int id, int currentCount) {}\n\n}\n\n\n解决问题的框架已经有了，来看一下如何使用Counter。 在count.cgi里面调用Counter来计数，程序片断如下：\n\n\n&nbsp;// &nbsp;这里从HTTP环境里面取id值\n\n&nbsp;...\n\n&nbsp;Counter myCounter = new Counter(); &nbsp;// 获得计数器\n\n&nbsp;int currentCount = myCounter.getCount(id); &nbsp;// 从计数器中取计数\n\n&nbsp;// &nbsp;这里向客户浏览器输出\n\n&nbsp;...\n\n\n程序的框架全都写好了，剩下的就是实现Counter类方法里面具体的代码了，此时才去考虑具体的程序语言实现的细节，比如，在getCount()方法里面访问数据库，更新计数值。\n\n\n从上面的例子中看到，面向对象的思维方法其实就是我们在现实生活中习惯的思维方式，是从人类考虑问题的角度出发，把人类解决问题的思维方式逐步翻译成程序能够理解的思维方式的过程，在这个翻译的过程中，软件也就逐步被设计好了。\n\n\n在运用面向对象的思维方法进行软件设计的过程中，最容易犯的错误就是开始分析的时候，就想到了程序代码实现的细节，因此封装的类完全是基于程序实现逻辑，而不是基于解决问题的业务逻辑。\n\n\n学习JDBC编程的经典错误问法是：“我怎样封装对数据库的select操作？”\n\n\n面向对象的设计是基于解决业务问题的设计，而不是基于具体编程技术的设计。我不会去封装select语句的，我只封装解决问题的业务逻辑，对数据库的读取是在业务逻辑的编码实现阶段才去考虑的问题。\n\n\n回过头看上面那个发广告邮件的例子，应该如何应用面向对象的思维方法呢？\n\n\n对于一个邮件来说，有邮件头，邮件体，和邮件地址这三个属性，发送邮件，需要一个发送的方法，另外还需要一个能把所有邮件地址列出来的方法。所以应该如下设计：\n\n\n类JunkMail\n\n\n属性：\n\n&nbsp;head\n\n&nbsp;body\n\n&nbsp;address\n\n方法：\n\n&nbsp;sendMail() &nbsp;&nbsp;&nbsp;// 发送邮件\n\n&nbsp;listAllMail() // 列邮件地址\n\n\n用Java来表示：\n\n\npublic class JunkMail {\n\n&nbsp;private String head;\n\n&nbsp;private String body;\n\n&nbsp;private String address;\n\n&nbsp;public JunkMain() { &nbsp;// 默认的类构造器\n\n&nbsp;&nbsp;&nbsp;// 从外部配置文件读邮件头和邮件体\n\n&nbsp;&nbsp;&nbsp;this.head=...;\n\n&nbsp;&nbsp;&nbsp;this.body=...;\n\n&nbsp;}\n\n\n&nbsp;public static boolean sendMail(String address) {\n\n&nbsp;&nbsp;&nbsp;// &nbsp;调用qmail，发送email\n\n&nbsp;}\n\n\n&nbsp;public static Collection listAllMail() {\n\n&nbsp;&nbsp;&nbsp;// &nbsp;访问数据库，返回一个邮件地址集合\n\n&nbsp;}\n\n}\n\n\n当把JunkMail设计好了以后，再调用JunkMail类完成邮件的发送，将是非常轻松的事情。\n\n\n如果说传统的面向过程的编程是符合机器运行指令的流程的话，那么面向对象的思维方法就是符合现实生活中人类解决问题的思维过程。\n\n\n在面向对象的软件分析和设计的时候，要提醒自己，不要一上来就去想程序代码的实现，应该抛开具体编程语言的束缚，集中精力分析我们要实现的软件的业务逻辑，分析软件的业务流程，思考应该如何去描述和实现软件的业务。毕竟软件只是一个载体，业务才是我们真正要实现的目标。\n\n\n但是在设计过程中，心里却往往在担心，如果我完全不去考虑程序代码的实现的话，那么我怎么知道我的设计一定合理呢？我怎么知道我设计的类、接口一定可以实现呢？（是个问题：（）所以经常可以看到的现象就是：\n\n\n在设计过程中，虽然知道不能过早考虑代码实现，但是每设计一个类，一个接口，心里都要不知不觉的用自己熟悉的编程语言大概的评估一下，看看能否编出来，因此，一不小心，就会又回到按照程序功能实现的思路进行设计的老路上去了。\n\n\n举个例子来说明，在做Web程序设计的时候，经常要遇到分页显示数据的情况。比如说需要把系统中所有的用户都列出来这样的功能。假设使用User类来表示用户，增加用户addUser()，删除用户deleteUser()，查询所有用户listUsers()方法。而数据库中有一个user表，一条记录是一个用户的信息。下面考虑一下User类的方法的实现：\n\n\naddUser()和deleteUser()方法都好实现，就是对数据库增加记录和删除记录。对于listUsers()方法，其实就是对user表的select，取出一个记录集。但是该怎么从listUsers()方法中得到所有用户的列表呢？\n\n\n一个方法调用的返回值只有一个，没有多个，所以很多情况下采用的办法就是返回值定义为集合类型，比如Vector。这样就可以在listUsers()方法的具体代码实现的时候，从数据库依次取出一个个记录，插入到Vector里面来。在主程序里面，调用listUsers()方法可以返回一个Vector，然后再对Vector遍历操作，就可以得到用户列表了。\n\n\npublic class User {\n\n\n&nbsp;public static void addUser(...) {\n\n&nbsp;&nbsp;&nbsp;// &nbsp;数据库insert一条记录\n\n&nbsp;}\n\n\n&nbsp;public static void deleteUser(...) {\n\n&nbsp;&nbsp;&nbsp;// &nbsp;数据库delete一条记录\n\n&nbsp;}\n\n\n&nbsp;public Vector listUsers(...) {\n\n&nbsp;&nbsp;&nbsp;// &nbsp;数据库select结果放到一个集合里面\n\n&nbsp;}\n\n}\n\n\n这样的设计基本合理，但是仍然有点小问题。因为在设计的时候，就考虑到了用Java的集合类Vector来实现对不定长数据集的存放，因而违反了面向对象设计的一个原则：在设计的时候不应过早的考虑具体程序语言的实现。所以必须用抽象的方法，和具体实现无关的方法来表达业务逻辑。\n\n\n我们知道，通常对具有集合特征的数据结构进行遍历通常可以使用next和hasNext方法，next实现取下一个用户，hasNext判断是否还有元素。 因此我们定义一个接口Iterator，这个接口中定义两个方法next和hasNext：\n\n\npublic interface Iterator {\n\n&nbsp;public boolean hasNext() {}\n\n&nbsp;public Object next() &nbsp;{}\n\n}\n\n\n而User类的listUses方法返回值改为Iterator接口的实现类:\n\n\npublic class User {\n\n&nbsp;...\n\n&nbsp;public Iterator listUsers() {\n\n&nbsp;}\n\n&nbsp;...\n\n}\n\n\n这样就把User类的设计和具体的实现方法分离开了，因为此时任何实现了next()和hasNext()方法的类都可以做为listUsers的返回值，都可以被用来表达“用户列表”，而不仅仅可以使用Vector而已。比如，我可以用ArrayList来表达用户列表，因为ArrayList也实现了Iterator，当然我也可以自己专门写一个类来存放用户列表，只要实现next()和hasNext()方法就行了。\n\n\n这样在具体的编写代码的时候，程序员具有了最大的灵活性，可以根据具体的情况，采用不同的编程方法来存放用户列表。特别是降低了程序的耦合度，提高了程序的可移植性。对于上面那个JunkMail的listAllMail()方法也同样应该改为接口类型。\n\n\n然后，在主程序里面就这样来使用User类的listUsers方法：\n\n\nUser myUser = new User();\n\nIterator iterator = myUser.listUsers();\n\nwhile (iterator.hasNext()) {\n\n&nbsp;iterator.next();\n\n}\n\n\n这样就可以完全不用考虑程序代码实现了，从高层次上把功能抽象出来，定义成为接口，同时又可以把系统设计的很合理，完全根据业务的需求来进行设计。\n\n\n结语\n\n\n通过上面的几个例子的设计说明，使用面向对象的思维方法，其实是一个把业务逻辑从具体的编程技术当中抽象出来的过程，而这个抽象的过程是自上而下的，非常符合人类的思维习惯，也就是先不考虑问题解决的细节，把问题的最主要的方面抽象成为一个简单的框架，集中精力思考如何解决主要矛盾，然后在解决问题的过程中，再把问题的细节分割成一个一个小问题，再专门去解决细节问题。\n\n\n因而一旦牢牢的抓住了这一点，你就会发现在软件设计和开发过程中，你自己总是会不知不觉的运用面向对象的思维方法来设计和编写程序，并且程序的设计和开发也变得不再那么枯燥，而一个合理运用面向对象技术进行设计和架构的软件，更是具备了思维的艺术美感。\n\n\n最后，愿面向对象的思维方法也能给您的程序设计之路带来创作的乐趣。\n\n        ', null);
INSERT INTO `blog` VALUES ('39', '面向对象设计原则', '\n            \n \n\n面向对象设计原则是OOPS（Object-Oriented Programming System，面向对象的程序设计系统）编程的核心，但大多数Java程序员追逐像Singleton、Decorator、Observer这样的设计模式，而不重视面向对象的分析和设计。甚至还有经验丰富的Java程序员没有听说过OOPS和SOLID设计原则，他们根本不知道设计原则的好处，也不知道如何依照这些原则来进行编程。\n众所周知，Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计。查看Apache和Sun的开放源代码能帮助你发现其他Java设计原则在这些代码中的实际运用。Java Development Kit则遵循以下模式：BorderFactory类中的工厂模式、Runtime类中的单件模式。你可以通过Joshua Bloch的《Effective Java》一书来了解更多信息。我个人偏向的另一种面向对象的设计模式是Kathy Sierra的Head First Design Pattern以及Head First Object Oriented Analysis and Design。\n虽然实际案例是学习设计原则或模式的最佳途径，但通过本文的介绍，没有接触过这些原则或还在学习阶段的Java程序员也能够了解这10个面向对象的设计原则。其实每条原则都需要大量的篇幅才能讲清楚，但我会尽力做到言简意赅。\n原则1：DRY（Don\'t repeat yourself）\n即不要写重复的代码，而是用“abstraction”类来抽象公有的东西。如果你需要多次用到一个硬编码值，那么可以设为公共常量；如果你要在两个以上的地方使用一个代码块，那么可以将它设为一个独立的方法。SOLID设计原则的优点是易于维护，但要注意，不要滥用，duplicate 不是针对代码，而是针对功能。这意味着，即使用公共代码来验证OrderID和SSN，二者也不会是相同的。使用公共代码来实现两个不同的功能，其实就是近似地把这两个功能永远捆绑到了一起，如果OrderID改变了其格式，SSN验证代码也会中断。因此要慎用这种组合，不要随意捆绑类似但不相关的功能。\n原则2：封装变化\n在软件领域中唯一不变的就是“Change”，因此封装你认为或猜测未来将发生变化的代码。OOPS设计模式的优点在于易于测试和维护封装的代码。如果你使用Java编码，可以默认私有化变量和方法，并逐步增加访问权限，比如从private到protected和not public。有几种Java设计模式也使用封装，比如Factory设计模式是封装“对象创建”，其灵活性使得之后引进新代码不会对现有的代码造成影响。\n原则3：开闭原则\n即对扩展开放，对修改关闭。这是另一种非常棒的设计原则，可以防止其他人更改已经测试好的代码。理论上，可以在不修改原有的模块的基础上，扩展功能。这也是开闭原则的宗旨。\n原则4：单一职责原则\n类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。\n原则5：依赖注入或倒置原则\n这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。\n原则6：优先利用组合而非继承\n如果可能的话，优先利用组合而不是继承。一些人可能会质疑，但我发现，组合比继承灵活得多。组合允许在运行期间通过设置类的属性来改变类的行为，也可以通过使用接口来组合一个类，它提供了更高的灵活性，并可以随时实现。《Effective Java》也推荐此原则。\n原则7：里氏代换原则（LSP）\n根据该原则，子类必须能够替换掉它们的基类，也就是说使用基类的方法或函数能够顺利地引用子类对象。LSP原则与单一职责原则和接口分离原则密切相关，如果一个类比子类具备更多功能，很有可能某些功能会失效，这就违反了LSP原则。为了遵循该设计原则，派生类或子类必须增强功能。\n原则8：接口分离原则\n采用多个与特定客户类有关的接口比采用一个通用的涵盖多个业务方法的接口要好。设计接口很棘手，因为一旦释放接口，你就无法在不中断执行的情况下改变它。在Java中，该原则的另一个优势在于，在任何类使用接口之前，接口不利于实现所有的方法，所以单一的功能意味着更少的实现方法。\n原则9：针对接口编程，而不是针对实现编程\n该原则可以使代码更加灵活，以便可以在任何接口实现中使用。因此，在Java中最好使用变量接口类型、方法返回类型、方法参数类型等。《Effective Java》 和《head first design pattern》书中也有提到。\n原则10：委托原则\n该原则最典型的例子是Java中的equals() 和 hashCode() 方法。为了平等地比较两个对象，我们用类本身而不是客户端类来做比较。这个设计原则的好处是没有重复的代码，而且很容易对其进行修改。\n总之，希望这些面向对象的设计原则能帮助你写出更灵活更好的代码。理论是第一步，更重要的是需要开发者在实践中去运用和体会。\n\n&nbsp;\n\n\n        ', null);
INSERT INTO `blog` VALUES ('40', '2012-05-31', '\n            \n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 这几天都是自己一个人负责做一个意见反馈系统，本来昨天就已经基本都完成了等美工给页面过来就可以了，今天上午才了解到要加多一个投票的功能，怪自己没把需求了解清楚，一口气从早上开始一直重复着写CRUD到下午三四点，顺手把页面上的JS脚本也封装处理了下，手指都有发麻的感觉，然后在走廊看风景想投票功能的处理方案，突然听到市场部的经理走出来在电话吼着说今天开了几十万的单，对比着，我觉得彼此之间的距离，就好像是我站在这座山的山顶，他在对面那座山的山顶，彼此远远的看着，脚下却有万里之遥的沟沟壑壑。。。\n\n        ', null);
INSERT INTO `blog` VALUES ('41', '面向对象与领域建模', '\n            \n \n\n板桥里人&nbsp;http://www.jdon.com 2006/12/6（转载请保留）多变且复杂的需求\n　　如果没有多变的需求，也许就没有今天的面向对象软件，我们曾经试图通过需求管理、需求跟踪等等管理方式约束和减少需求频繁更新带给软件的冲击，可是这样下去的结果只有一个：使得软件更加僵化；或者程序员更加 劳累。\n　　需求不但多变，而且经常是不可能第一次就能掌握，需求反映了某个领域的专业知识，例如数学、管理、财务或 电子商务等等，每个特定案例需求又有其特别复杂之处，几乎没有人能够第一次接触就可以深入掌握这些专业领域的 需求本质，就是专门的建模专家也不例外。\n　　既然需求是多变而且复杂的，所以，就不能使用“堵”式方法对其进行控制和管理，只能顺势而为，通过灵活多变的 以及迭代反复的方式逐步抓住需求，并且作为需求的实现软件系统必须能够迅速应对需求变化，需求变化有多快，软件 变化就有多快。\n　　因此，对于多变的需求，我们的解决之道是：引入灵活多变的架构，面向对象OO架构正是应对多变需求而生，强调软件的可维护性 和拓展性，OO可能不是最好方式，但是目前是最合适的；对于复杂的需求，我们的解决之道是：委派专门的建模专家跟踪理解需求， 在需求和需求实现之间搭建桥梁，项目方法上采取多次迭代的敏捷软件开发方式，逐步了解学习掌握需求。\n　　在这里稍微说明一下，很多人总是将软件和数学、管理、财务混为一谈，其实软件本身就是一门独立的专业，是为 数学、管理。财务等专业领域服务的，不能期望软件人员也是其他领域专业人员，可是在中国现实中，很多人总是 无法分辨，例如某局长将整个机关考核信息化的任务交给电脑中心，这就是将考核管理专业和软件专业混同的例子， 在考核管理和软件之间需要一个领域建模专家，由他来理解或者设计考核管理体系，然后通过模型，表达成 软件人员能够看懂的符号，软件人员通过模型了解领域。\n　　曾经有需求专家呼吁：最好将需求给所有软件人员都了解，需求专家和一般软件人员一起工作，这些想法的本质是 好的，但是不可能实现的，不可能每个软件人员不但了解软件架构和OO思想；还能够掌握另外一个专业领域的艰深知识， 所以，现在我们提出：将领域专家建立的统一领域模型让所有软件人员都了解，让一般软件人员围绕领域模型工作，这样 的方式才切实可行。\n需求分析方法演变\n　　历史上，对需求分析方法可以说经过三个阶段：　　第一阶段：围绕数据库的驱动的分析设计，新软件项目总是从设计数据库及其字段开始。这个阶段特征就是围绕数据库编程，典型的是 DBase/Foxpro，以及后来的Delphi/VB技术。　　这种围绕数据库分析设计的缺点非常明显：首先，不能迅速有效全面认识反映需求，世界不只是由简单的关系数据组成，而且 使用关系数据来反映现实需求，不符合人类自然思维（OO才是），是一种扭曲的分析方法，特别对于初学者，他们接受数据库分析方法的难度反而可能会大于OO分析方法，现在很多职业学校和社会培训，基础课程从数据库开始，从某种程度上，是历史倒退， 严重阻碍中国软件发展的进程。　　围绕数据库分析极其容易导致过程化设计编程，围绕数据分析和过程化编程是一对恶魔，数据库结构确立后，就让普通程序员写SQL 语句，SQL语句执行有明显的先后顺序，在这样顺序过程编程思维中，OO思维就难以生存。长此以往，成为习惯后，就很难改变到 OO设计上，所以，传统编程经验越丰富，转变到OO设计就越难。　　在运行性能方面：围绕数据库分析设计容易导致软件运行时负载集中在数据库端，系统性能难于扩展（走上集中式、昂贵的、高风险的大型机模式）， 闲置了中间件J2EE服务器分布式集群处理能力，就是使用了集群，也分担不了负载。　　最后，我们必须认识到：对象和关系数据库存在阻抗，本身是矛盾竞争的，他们是两种分析看待需求的流派，可以说是水火不容， 要么你采取数据库分析设计以及过程化编程，要么完全采取OO，现在使用.NET和Java这样OO语言的人很多，但是70%左右都是使用OO语言编写传统过程化系统，在Java中这样做，会有极差性能；而这种现象在.NET中又极容易得到纵容，.NET是一个系列阵营，正如Windows系列一样， 当你和别人说，你在使用Windows，别人可能觉得你没有落后时代，但是他们哪里知道你在使用Windows 3.1呢？　　第二阶段：面向对象的分析设计方法诞生后，有了专门的分析和设计阶段之分，我们使用UML符号来表达分析设计思想，分析设计进入了一个相对更高的层次，拥有了自己一套科学且艺术的方法论。但是有一个致命缺点：分析阶段和设计阶段是断裂的，互相不能很好衔接，为什么？　　首先，我们看看分析人员和设计人员在职责重点工作是什么？　　分析人员的职责：是负责从需求领域中收集基本概念。而设计人员的职责：必须指明一组能北项目中适应编程工具构造的组件，这些组件必须能够在目标环境中有效执行，并能够正确解决应用程序出现的问题 两个阶段两者目标不一致，分析人员只管需求分析，至于是否适合设计，或者能够导出适宜设计的分析结果，这个尺度很难衡量和把握；　　而设计人员因为照顾代码可运行，因此，经常可能会抱怨分析员给出的结果过于粗糙，不适合设计，这样分析设计两个阶段就导致分裂，项目失败。\n　　在这个阶段，虽然有UML帮助，但是UML不是思想，打个比喻：会CAD的绘图员就是建筑师吗？很显然，UML就是CAD图符号，UML不等于分析设计思想。 所以，有人说UML不是银弹，这些就象说中医不是科学一样绕人（中医就不是西医，当然就不是科学）。\n　　第三阶段：融合了分析阶段和设计阶段的领域驱动设计（Evans: DDD）。2004年Eric Evans 发表Domain-Driven Design –Tackling Complexity in the Heart of Software （领域驱动设计 ）简称Evans DDD， 领域建模是一种艺术的技术，它是用来解决复杂软件快速应付变化的解决之道，所以，从Evans DDD通篇文章中，你找不到科学象征的定理和公式，当然如果 你试图寻找这样寻找，你也就陷入了“中医是不是科学”怪圈了。\n　　Evans DDD抛弃了分裂分析模型与设计的做法，使用单一的模型来满足这两方面的要求。这就是领域模型。 单一的领域模型同时满足分析原型和软件设计 ，如果一个模型实现时不实用，重新寻找新模型。如果模型没有忠实表达领域关键概念时，也必须重新寻找新的模型。 建模和设计成为单个迭代循环。将领域模型和设计紧密联系。因此，建模专家必须懂设计。\n领域建模的重要性\n　　如果你说一个软件开发需要经过需求、分析和设计三个阶段的话，那么可能反映你的思想已经落伍，软件开发现在是 经过需求、建模阶段，混合了分析和设计阶段，可以更激进地说：我们国家的系统分析员和系统设计员考试也许应该合并了， 合并成建模专家的考试，否则，这些都是中国软件落后世界十年的证据，可悲的是：我们自己可能都不知道。　　Evans DDD可以说是近期与SOA相提并论的两大重要技术思想，SOA是着重于软件集成方面；而EvansDDD才是着重我们软件开发上， 在大部分情况下，软件开发重要程度不亚于软件集成，但是因为软件开发方面开源力量冲击，软件集成上工业厂商利润最高， 所以，工业厂商在SOA叫得最响，我们参加得各种会议几乎都是SOA，当心被误导，工业厂商从来不会告诉你事实得争相。\n　　 没有面向对象的分析设计，哪里面向对象的构件或组件？过去经验不是证明：我们使用大量的构件组件，却在编制面向过程的体系？　　以EJB2为例子，在EJB2过去大部分系统中，我们常常以数据库为中心，实体Bean因为特殊技术原因，僵硬一块，变成数据库 的代名词，我们围绕实体Bean编制出大量的值对象Vale Obejct，或称为DTO（Data Transfer Object），在这样系统中，从对象 的名称也可以看出，对象是为数据服务的，对象从属于数据库的。　　现在，要彻底改变过来，OO就是以对象为主，数据库是从属对象设计的，如果说EJB2的实体bean技术让你不得不走上传统过程化编程歧路，那么 EJB3已经更正了实体Bean设计缺陷，从EJB发展可以看到一个侧面：工业厂商更多关心的是功能，而不是设计？　　只有谁才真正关心你的软件设计和代码质量？只有你自己。我不是提倡都不要参加工业厂商的会议，而是需要每个人冷静想想： 到底谁是自己代码的主人？\n　　领域建模属于与具体.NET或Java技术无关的设计思想，有人总是说：.NET比Java简单，其实这又是一个大误区，如果都达到同样设计水准，无论使用.NET或Java，都需要付出同样的努力；那为什么有人觉得.NET简单，那是因为设计要求降低了，参见这篇.NET的DDD文章。分层架构\n　　分层架构是现代OO软件企业系统的基本架构，只有分层才能达到良好的可拓展性和维护性。基本三层：表现层、业务层和持久层 ;J2EE中表现层和持久层有成熟框架支持，应用重点在业务层。\n　　业务层根据Evans DDD，可以再细分为应用层和领域层两种，在业务层设计编码中，大量应用OO设计原则和设计模式。领域层定义：负责表达业务领域概念、业务状态以及业务规则，是整个业务软件核心和重点。 应用层定义：负责完成功能，并且协调丰富的领域对象来实现功能，不能包括业务规则，无业务状态；\n　　每个层都是内聚的，并且只依赖它的下层，为了实现各层的最大解耦，IOC/DI容器是当前Java业务层的最好选择 。\n　　 没有分层架构的快速开发基本是旁门左道，不如返回Foxpro和Delphi/VB两层时代。将本属于业务层的逻辑交由表现层来处理的快速UI方式也是一种旁门左道。快速开发必须基于良好的质量，虽然良好的分层架构带来开发效率的降低，但是这些也是可以有方法解决。\n建模与项目管理　　 在我们大多数从软件项目管理上寻找软件永恒解决之道时，他们可能没有意识到又在范“缘木求鱼”老毛病了， 打个比喻很容易明白这个道理：冷兵器时代（也就是火枪没有没有发明之前），各种排兵布阵可能在作战指挥时 很有效；但是到了火器时代，所有的过去作战方式就落伍了；当然到了现在信息化战争时代，更是天壤之别。\n　　 Evans DDD领域驱动建模的诞生，对过去传统的项目管理都提出挑战，当我们还在争论RUP好还是敏捷好的时候， 谁会想到我们应该采取围绕统一领域模型的迭代驱动开发呢？\n　　 有人可能还在疑惑？我接到一个大项目，那么我的建模和架构设计时间应该是5个月还是5年呢？当然应该回答他：都不行，需求是多变且复杂的，计划赶不上变化，现在就应该开始DDD建模。(以上文字源自板桥本人的第四届中国软件技术大会“领域设计建模”演讲稿 )\n\n        ', null);
INSERT INTO `blog` VALUES ('42', '2012-05-25', '\n            \n \n\n&nbsp;\n\n&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 首先，贴上从明哥空间copy过来的明哥形象图，默默膜拜两分钟。。。&nbsp; &nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 礼毕。。。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 最近这段时间在负责修复之前同事留下的特产网的bug，也在这段时间体会到一些之前在书上看到的很多关于技术关于做事方面的东西，包括开发时对项目的细节调整，深刻体会到上百行的if{do something...}else{do something...}的过程化代码和项目版本控制对项目维护来说意味着什么，明哥说，当你在指责别人代码写得不好的时候，要想想如果换成自己，会怎么写？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 今天下班的时候终于内测通过重新部署上线了，老实说，我心里对它没底，毕竟人家留下的那些不知所云的代码就是那样健健康康的运转着，刚看了下，数据还没有更新过来，明天把那些数据也更新下，如果一切正常的话，之后就想把整个项目的代码完完整整的重构下，当练练手也行，当对以后维护的同事负责也行，就是不喜欢看到这种代码跑得那么健康让心里没底它什么时候会发作。下班前升哥说部署上去没事了，今晚也就可以好好睡个安稳觉了，好吧，希望晚上不会梦到它报错。。。阿门。。。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 最后，大家可以访问下这个站点 http://techan.youboy.com &nbsp;，如果发现问题了，请不要给我留言，It wasn\'t my fault ! thank...\n&nbsp;\n\n        ', null);
INSERT INTO `blog` VALUES ('43', '清除代码异味', '\n            \n \n\n本文是从 Cleaning up code smells: Venkat Subramaniam @ Chennai 这篇文章翻译而来。 今天，Venkat Subramaniam 就关于清除代码异味的话题给我们做了一个非常有趣的演讲。下面就是我记录的一些他的话。\n\n为什么我们需要有质量的代码？\n\n 敏捷开发方法是用来应付那些要求代码做大量改动的反馈信息的方法。 \n 如果程序没有用一种好的表达方式来表现，那程序会很难读，难维护，难修改。 \n\n什么是代码异味？\n\n 代码异味是一种由写的很差的代码引起的一种有臭味的感觉，一种程序什么地方会有问题的感觉 \n 异味更多的是来自一种直觉，而不是一种有据可查的标准，当你看到有味的代码时你就“感觉”到了 \n 如果你不把异味清除，不久之后你就会习惯这种气味，不再对它有察觉 \n 用任何语言都能写出有异味的代码：即使最简单安全的语言，你也能做出天才才能想出的蠢事:) \n 我们经常会意识不到自己在写很臭的代码，经常需要外人为我们指出这点\n  \n   边注：如果你不想刻意去批评某人的程序，不要说“太愚蠢了”，要说“哦，这很有意思…。可有一种更好的方法你知道吗” \n  \n\n重复的代码\n\n 会引起程序里面多个地方相同的错误 \n 印度小伙：每两个月我们都会把这相同的错误修改一次 \n Venkat：你们去掉了重复的代码了吗？ \n 印度小伙：你说的这个方法不错！ \n\n不必要的复杂\n\n 程序员本质上讲高兴去处理复杂的问题 \n 复杂最恐怖 \n\n异常处理\n\n 问：有什么比一个空的异常捕捉代码更糟糕的？\n  \n   try { ... } catch (Exception e) { }\n   \n 答：一个带有注释的空异常捕捉代码！\n  \n   try { ... } catch (Exception e) { // is this required? }\n   \n Java的异常检查：好还是不好？ \n 如果你不想处理一个异常，就把它传递下去 \n 如果你想捕捉两个异常，使用两个catch代码，不要只写一个而用If条件处理 \n\nSwitch语句 &amp; 按类型的条件判断\n\n Switch语句和按类型的条件判断通常可以用多态来代替 \n\n长方法\n\n 你不能在一屏上看到整个方法 \n 这通常意味着一个方法承担这多重任务 \n 难于调试 \n 不可测试 \n 难于重用 -&gt; 导致程序员从方法的其它地方拷贝粘贴出重复的代码 \n 复杂的条件语句 -&gt; 挑战大脑的逻辑分析能力 \n 方法长度：组织归纳水平比控制代码行数更重要 \n\n方法组成模式\n\n 方法里的所有语句都必须处在同一个归纳层次上 \n\n无用的注释\n\n 让代码自我表白 \n 标注为什么这样，而不是如何这样 \n 对方法表现进行描述等于重复表现 \n 这样的注释等于重复写一遍代码\n  \n   i += 1 // 递增\n   \n 长方法里用来描述这个方法有不同的功用的注释\n  \n   把里面的功能片段提取成小方法 &amp; 删除注释 \n   \n IDE排泄物：IDE自动产生的注释空白占位符 \n 糟糕的注释通常产生于TDD*\n  \n   * (TDD：Threat driven development，恐吓驱动开发)—— 你应该为方法的表象写注释，你应该为长方法写注释，等 \n   \n 产品里的注释：\n  \n   // 上帝保佑，我实在不知道这是什么意思\n  \n\n变量名称\n\n 使用能表意的名称 \n 不要用单个字母做名称 \n 也不要使用太长的名称 \n\n继承\n\n 继承更多的是被滥用了 \n 组合通常优于继承 \n 在一对一关系中使用继承，满足Liskov替换原则 \n 不要用继承来实现方法重用 \n 重用方法时，委托是个更好的选择 \n\n粘手的语言\n\n 这种语言更容易导致犯错误 \n\n最臭的代码\n\n 冗长的类 \n 重复的代码 \n 淘汰的方法 \n 不必要的塑型(cast) \n 过度使用设计模式 \n\n代码除味\n\n 代码复查！\n  \n   写出之后尽快进行 \n   要增量进行 \n   要复查测试用例 \n   \n 可使用结对编程\n  \n   但要保持结对伙伴的经常变动，否则你会习惯你的气味，不再会有察觉 \n   结对伙伴一、两天调换一次 \n  \n\n一些设计原则\n\n 高聚合 \n 低耦合 \n Demeter定律 [不要告诉我，我会通知你] \n Liskov替换原则 \n 先让它跑起来，再让它无误，再让它快速 \n 开发/闭合原则 \n 反向依赖 \n 单一责任原则 \n\n一些参考书籍\n\n 代码整洁之道(Clean Code) \n 代码大全(Code Complete) 2 \n 程序员修炼之道(The Pragmatic Programmer) \n 敏捷开发修炼之道(Practices of an Agile Developer) \n Smalltalk Best Practice Patterns \n 实现模式(Implementation Patterns) (from @protoiyer) \n\n问和答\n\n 关于使用代码检测工具，例如PMD：这样的工具非常的有用，它能让你捕捉到很直接的问题，使你的代码复查工作专注于高层面的设计原则问题 \n 关于IDE上附加的工具：不要自己去运行它们。让这些工具在后台自动的运行(或智能化) \n 动态语言里需要重构吗：动态语言里没有太多的自动重构工具，但程序员仍然应该手动的重构 \n 关于动态语言的设计模式：每种语言都有自己的模式和特色。例如：smalltalk的execute around method模式 \n 关于掌握多种语言\n  \n   你应该知道处理一个问题的多种范式，多种风格和多种方式 \n   一种语言中学到的特色方法应用到其它语言里 \n   知道各种不同方式的各自风险 \n   \n 关于编程语言趋势：对函数性编程，移动设备编程兴趣浓厚 \n 关于著书：长时间的思考书中的各项主题，多做这方面话题的讨论，吸取精华。当开始动手去写时，已经胸有成竹，2周内把书写成 \n 关于思考文献：思考文献很有用，但你也要多看看批评性的思考性文章，它们是关于你如何去思考的(double loop learning?) \n 关于学习：在用户组里跟其它人合作，交流，讨论。你并不能学到所有的东西，但要努力缩小自己的“你不知道你不知道的东西”，让它成为“你知道你不知道的” \n\n\n        ', null);
INSERT INTO `blog` VALUES ('44', '每位开发人员都应铭记的10句编程谚语', '\n            \n \n\n所谓谚语，就是用言简意赅、通俗易懂的方式传达人生箴言和普遍真理的话，它们能很好地帮助你处理生活和工作上的事情。也正因如此，我才整理了10句编程谚语，每位开发人员都应该铭记他们，武装自己。1. 无风不起浪别紧张，这也许只是一场消防演习代码设计是否糟糕，从某些地方就可以看出来。比如：a. 超大类或超大函数b. 大片被注释的代码c. 逻辑重复d. If/else嵌套过深程序员们通常称它们作代码异味(Code Smell)，但是就我个人认为“代码警报”这个名字更为合适一些，因为它有更高的紧迫感的含义。根本问题处理不当，终将引火烧身。译注：Code Smell中文译名一般为“代码异味”，或“代码味道”，它是提示代码中某个地方存在错误的一个暗示，开发人员可以通过这种smell（异味）在代码中追捕到问题。2. 预防为主，治疗为辅 好吧，我相信了！20世纪80年代，丰田公司的流水作业线因为它在缺陷预防方法上的革新变得出了名的高效。每个发现自己的部门有问题的成员都有权暂停生产。这个方法意在宁可发现问题后马上暂定生产、解决问题，也不能由其继续生产而导致更棘手且更高代价的修复/更换/召回后的问题。程序员总会做出生产率就等同于快速编码的错误臆断。许多程序员都会不假思索地直接着手代码设计。可惜，这种Leeroy Jenkins式鲁莽的做法多会导致软件的开发过程变得很邋遢，拙劣的代码需要不断的监测和修改——也可能会被彻底地替换。最终，生产率所涉及到的因素就 不仅仅是写代码所消耗的时间了，还要有调试的时间。稍不留神就会“捡了芝麻丢了西瓜”。（因小失大。）译注：Leeroy Jenkins 行为：WOW游戏中一位玩家不顾大家独身一人迎敌，导致灭团。3. 不要孤注一掷 （过度依赖某人）一个软件开发团队的公共要素（bus factor）是指那些会影响整个项目进程的核心开发人员的总数。比如某人被车撞了或某人生孩子或某人跳槽了，项目可能就会无序，甚至会搁置。译注： bus factor 即指公共要素，比喻了开发过程中的一些共同因素。如果挤上 bus 的 factor 越多，bus 就越不稳定，所以要控制好 bus factor ，以免问题发生。换句话说，如果你的团队突然失去了一个主力成员，你会怎么办？生意依旧进行还是戛然而止？很不幸，大多数软件团队都陷入了后一种情况。这些团队把他们的开发员培养成了只会处理他们自己专业领域的“领域专家”。起初，这看起来是一个比较合理的方法。它 对汽车制造装配生产线很适用，但是为什么对软件开发团队就不行呢？毕竟，想让每个成员都掌握所编程序的细微差别也不太可能，对吧？问题是开发人员不容易轻易替换掉。虽然当每位成员都可用时，“抽屉方法”很有效，但如果当“领域专家”突然因人事变动、疾病或突发事故而无法工作时，抽屉 方法立马土崩瓦解。（所以，）软件团队有一些看似多余实则重要的后备力量是至关重要。代码复查、结对编程和共有代码可用成功营造一个环境，在这个环境中， 每位开发人员至少表面上是熟悉自己非擅长领域之外的系统部分。4. 种瓜得瓜，种豆得豆《注重实效的程序员》一书中有这样一段话解释“破窗理论”：不要留着“破窗户”（低劣的设计、错误的决策或者糟糕的代码）不修。发现一个就修一个。如果没有足够的时间进行适当的修理，就先把它保留起来。或许你可 以把出问题的代码放到注释中，或是显示“未实现”消息，或用虚拟数据加以替代。采取一些措施，防止进一步的恶化。这表明局势尚在掌控之中。我们见过整洁良好的系统在出现“破窗”之后立马崩溃。虽然促使软件崩溃的原因还有其他因素（我们将在其他地方接触到），但（对“破窗”）置之不理，肯定会更快地加速系统崩溃。简而言之，好的代码会促生好的代码，糟糕的代码也会促生糟糕的代码。别低估了惯性的力量。没人想去整理糟糕的代码，同样没人想把完美的代码弄得一团糟。写好你的代码，它才更可能经得住时间的考验。译注：《注重实效的程序员》，作者Andrew Hunt / David Thomas。该书直击编程陈地，穿过了软件开发中日益增长的规范和技术藩篱，对核心过程进行了审视――即根据需求，创建用户乐于接受的、可工作和易维护的 代码。本书包含的内容从个人责任到职业发展，直至保持代码灵活和易于改编重用的架构技术。从本书中将学到防止软件变质、消除复制知识的陷阱、编写灵活、动 态和易适应的代码、避免出现相同的设计、用契约、断言和异常对代码进行防护等内容。译注：破窗理论（Broken Window theory）：是关于环境对人们心理造成暗示性或诱导性影响的一种认识。“破窗效应”理论是指：如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些暗示性的纵容去打烂更多的窗户。发现问题就要及时矫正和补救。5. 欲速则不达经理、客户和程序员正日益变得急躁。一切都需要做的事，都需要马上就做好。正因如此，快速修复问题变得非常急迫。没时间对一个新功能进行适当的单元测试？好吧，你可以先完成一次测试运行，然后你就可以随时回来继续测试它。当访问Y属性时，会不会碰到奇怪的对象引用错误？无论怎样，把代码放到try/catch语句块中。我们要钓到大鱼啦！是不是似曾相识呢？这是因为我们在以前已经都做到了。并且在某些情况下、它是无可非议的。毕竟，我们有最后期限，还得满足客户和经理。但不要过于频繁操 作，否则你会发现你的代码不稳定，有很多热修复、逻辑重复、未测试的方案和错误处理。最后，你要么是把事情草草做完，要么是把事情好好做完。6. 三思而后行“敏捷开发”这个词最近被频繁滥用，经常被程序员用来掩饰他们在软件开发过程中的糟糕规划/设计阶段。我们是设计者，看到产品朝正当方向有实质进展，我们理应高兴。但意外的是，UML图和用例分析似乎并不能满足我们的愿望。所以，在不知自己做什么的情况下或者不知自己身处何处时，我们开发人员经常就稀里糊涂地写代码了。这就好比你要去吃饭，但你根本没有想好去哪里吃。因为你太饿了，所以你迫不及待地找个餐馆，定个桌位。然后你上车开车后沿途在想（找地方吃饭）。只是，这样会耗费更多的时间，因为你要过较多的U型弯道，还在餐馆前停车，也许最后因等待时间过长而不吃了。确切地说，你最后应该能找到地方吃饭，但你可能 吃的饭并不是你想吃的，并且这样花费的时间，可能比你直接在想去的餐馆订餐所花的时间更长。7. 如果你惟一的工具是一把锤子，你往往会把一切问题看成钉子看见了吧？我早就说过动态记录在这个项目中很有效程序员有一种倾向，当一谈到他们工具时，其视野就变狭窄了。一旦某种方法在我们的一个项目上“行得通”，我们就会在接下来所有的项目上都用到它。学习新东 西仿佛是一种煎熬，有时候甚至会心神不定。从始至终都在想“如果我用之前的方法做、这个就不会这么麻烦了”。一定要摒弃这种想法，按我们所知道的去做，即使那不是最完美的解决方法。坚持自己所知很简单，不过从长远的角度讲，选择一个适合这项工作的工具要容易得多。否则，就会与你的职业生涯格格不入。8. 沉默即赞同 我什么都没看见！没看见！“破窗理论”与”变成惯性理论”有着宏观的联系。编程社区就好像一个现实社区。每个作品都是一个开发者的缩影。糟糕的代码发布的越多，就越容易反映现状。如果你不去努力编写优秀、整洁和稳定的代码，那你每天都将和糟糕的代码相伴了。同样地，如果你看到别人写出了糟糕的代码，你就要跟这个人提出来。注意，这时候机智就应该用上场了。一般情况下，程序员都愿意承认他们在软件开发中还是有不懂的地方，并且会感谢你的好意。互相帮助对大家都有利，而对问题视而不见，只会使问题一直存在。9. 双鸟在林，不如一鸟在手 如果可以讨论系统架构和重构，那么就差找个时间把事情做完。为了使正常运作的东西更加简洁而做改动，权衡改动的利弊很重要。当然了，简洁是一个理想目标， 但总会有可以通过重构改进的代码。在编程世界中，为了代码不过时，会频繁简单改动代码。但有时候你又必须保证代码对客户有价值。那么，你面临一个简单窘 境：你不能一石二鸟。你在重构旧代码上所发时间越多，你编写新代码的时间就越少。在及时改进代码和维护程序之间，也需要找到平衡点。10. 能力越大，责任越大毫无疑问，软件已成为我们生活中一个既基本又重要的一部分。正因如此，开发优秀软件格外重要。乒乓球游戏中的Bug是一回事，航天飞机导向系统或者航空交通管制系统中的Bug是另外一回事。Slashdot曾发表一文，讲述了单单Google News的一个小失误使一家公司股票蒸发11.4亿美元。其他例子参见《软件Bug引发的十次严重后果》。这些例子便说明了我们正行使着多大的权利。你今天写的代码，无论你是否有意，说不定有朝一日在重要的应用程序中派上用场，这想想都令人害怕。编写正确合格的代码吧！译注：Slashdot是一个资讯科技网站。\n\n\n        ', null);
INSERT INTO `blog` VALUES ('45', '无名师的Unix心传', '\n            \n \n\n一、无名师与万行码\n\n无名师曾对来访的程序员说：“Unix传统上认为，一行shell脚本胜过万行C程序。”\n\n这个程序员自以为对C极其精通，说：“这不可能。UNIX内核正是用C实现的。”\n\n无名师回道：“确是如此。不过，UNIX传统上认为，一行shell脚本胜过万行C程序。“\n\n程序员颇为沮丧：”但是在C中我们可领会到尊者Ritchie的智慧。我们与操作系统和机器合而为一，可以获取无与伦比的性能。”\n\n无名师回道：“诚如你言。不过，Unix传统上认为，一行shell脚本胜过万行C程序。”\n\n程序员冷笑着想愤然离去。无名师向学生Nubi颔首示意，Nubi在黑板上写下一行shell脚本，问道：“尊敬的程序员，看看这行管道，用纯C实现，是不是要一万行C代码？”\n\n程序员沉吟念诵。最终他承认如此。\n\n“你需要多长时间来实现和调试那个C程序？”Nubi问道。\n\n“很长”，来访的程序员承认。“但傻子才会干这个而不去完成更有价值的任务。”\n\n“那么谁更了解Unix传统？”无名师问道。“是写一万行代码的，还是看到任务的无谓而不去编码的？”\n\n听到此，程序员眼中一亮。\n\n\n二、无名师与脚本狂\n\n无名师和学生吃早饭时，从黑客大陆来了个陌生访客。\n\n“Ihear y00 are very l33t,”他说。“Pl33z teach m3 all y00 know”。（我听说你很牛，请把你会的都教给我。）\n\n无名师的学生面面相觑，都没听懂这类粗鄙言语。无名师微笑道：“你想弄懂Unix？”\n\n“I want to b3 a wizard hax0r”，陌生人回答，“and 0wn ever3one\'s b0xen。”（我想当个顶尖黑客，能掌握所有人的机器。）\n\n“我不教这个”，无名师答道。\n\n陌生人很激动。“D00d， y00 r nothing but a p0ser。”，他说。“If y00 n00 anything, y00 wud t33ch m3。”（哥们儿，敢情你没真本事啊，你要知道点儿东西就教给我了。）\n\n“有条路，”无名师说，“可以将你带入真知。”他在纸上写了个IP地址。“黑掉这台机器，这对你来说应该不费什么力气，它的管理员不称职。回来后告诉我你发现了什么。“\n\n陌生人鞠了一躬就离开了。无名师把他的早饭吃完。\n\n几天过去了，几个月过去了。没人再想起陌生人。\n\n数年过去了，黑客大陆来的陌生人回来了。\n\n”你混蛋！“他说，”我黑掉了那台机器，你说的没错，太容易了。但是我被FBI抓起来扔进监狱了。“\n\n”好“，无名师说，”你可以继续下一课了。“他在另一张纸上写了个IP地址交给陌生人。\n\n”你疯了？“陌生人喊道。”经过这事，我再也不黑别人的机器了。”\n\n无名师脸现微笑。“这里就是”，他说，“真知的开始。”\n\n听到此，陌生人眼中一亮。\n\n\n\n三、无名师的双路论\n\n无名师如是教导学生：\n\n“达摩教义有条准线，这在尊者McIlroy的符咒“做一件事并做好”中得到体现。它强调软件应当具有简单一致的行为，这符合Unix惯例，人和其它程序便都很容易想象其心理模型。\n\n“但达摩教义还有另一条准线，体现在尊者Thompson的符咒“有怀疑，用穷举”中，很多经文都教导我们现在得到的90%，比等不来的100%更有价值。它强调实现的健壮性和简单性。\n\n“现在告诉我：什么程序符合Unix传统？“\n\n想了一会儿后，Nubi沉思道：\n\n“老师，这些教义有冲突。”\n\n“简单的实现往往对边缘情况有欠考虑，比如资源耗竭、无法关闭竞争窗口以及在未完成事务中超时等等。”\n\n“发生边缘情况时，软件行为往往不规律、难以猜测。这当然不是Unix传统。“\n\n无名师颔首同意。\n\n“另一方面，大家都知道精巧的程序很脆弱。更进一步说，每个对边缘情况的修正往往牵扯到程序的核心算法，还牵扯处理其它边缘情况的代码。”\n\n“于是，对边缘情况防患于未然、确保描述的简单性，反而会使得代码过分复杂、bug成堆、根本无法发售。这当然不是Unix传统。”\n\n无名师颔首同意。\n\n“那么，什么是正确的达摩道？”Nubi问道。\n\n无名师说：\n\n“当鹰飞翔时，它忘记爪子与地面相触？当虎捕食时，它忘记腾空的一刻？VAX只重三斤！”\n\n听到此，Nubi眼中一亮。\n\n\n\n四、无名师与方法论\n\n无名师和学生Nubi在圣地行走，无名师习惯在晚间为城市和乡村的Unix新门徒布道。\n\n一次，聆听者中混入了一名方法论者。\n\n“优化程序时不对热点进行反复衡量，就像渔夫把网撒入空湖中。”无名师说。\n\n“那么，”方法论者说，“管理资源时不持续地衡量你的产能，不也像渔夫将网撒入空湖中么？”\n\n“我一次碰到一个渔夫时，他正将网撒入船下的湖中，”无名师说，“他摸了好一会儿船底，像在寻找他的船。”\n\n“但是，”方法论者说，“如果他把网撒入湖中，为什么还要找船呢？”\n\n“因为他不会游泳。”无名师答道。\n\n听到此，方法论者眼中一亮。\n\n\n\n五、无名师的GUI论\n\n一晚，无名师和Nubi参加一个程序员的探讨会。有个程序员问Nubi和他的老师来自哪看看学校。当得知他们是Unix大道的追随者时，程序员颇为不屑。\n\n“Unix命令行工具太粗糙太落后”，他讥讽道。“现代的、设计得当的操作系统可以在图形用户界面中做任何事情。”\n\n无名师一言不发，只是指着月亮。旁边的一条狗对着他的手狂吠。\n\n“我不明白。”程序员说。\n\n无名师依然缄默，指着一幅佛祖像，然后又指着一扇窗。\n\n“你想说什么？”程序员问。\n\n无名师指着程序员的头，接着指着一块大石。\n\n“请把话说清楚！”程序员要求道。\n\n无名师深深蹙眉，轻拍程序员的鼻子两下，把他扔到旁边的垃圾箱中。\n\n程序员试图从垃圾堆挣扎出来之时，那条狗跑过来在他身上便溺。\n\n此时，程序员眼中一亮。\n\n\n\n六、无名师与Unix班\n\n一个Unix狂热者听说无名师掌握Unix大道真知，便跑来求教。无名师对他说：\n\n“当尊者Thompson发明Unix时，他并不理解它。随后他理解了，受益了，不再发明了。“\n\n“当尊者McIlroy发明管道时，他只知道它将传递软件，并不知道它能传递思想。”\n\n“当尊者Ritchie发明C时，他将程序员放到缓冲溢出、堆损坏和烂指针bug的地狱中惩罚。”\n\n“说实话，这些尊者又瞎又蠢！”\n\n狂热者对无名师的用词极为愤怒。\n\n“这些智者”，他抗议道，“给了我们Unix的大道。我们嘲笑他们，就是混淆是非，比转世为牲畜和MCSE还不如。”\n\n“你的代码全无污点和缺陷？”无名师问。\n\n“不，”狂热者承认，“没人不犯猎。”\n\n“这些尊者之智，”无名师说，“就是了解自身之愚。”\n\n听到此，狂热者眼中一亮。\n\n\n\n七、无名师的Unix传统论\n\n一学生对无名师说：“我们听说SCO公司把握着纯正的Unix。”\n\n无名师颔首。\n\n学生继续说，“我们还听说OpenGroup公司也把握着纯正的Unix。”\n\n无名师颔首。\n\n“这怎么可能？”学生问。\n\n无名师答道：\n\n“SCO确实把握着Unix源码，但是Unix的源码不是Unix。OpenGroup确实把握着Unix的名称，但Unix的名称不是Unix。”\n\n“那么，什么是Unix传统？”学生问。\n\n无名师答道：\n\n“非源码。非名称。非思想。非实物。恒变。不变。”\n\n“Unix传统是简单和空。正是简单，正是空，才使得它更强胜飓风。”\n\n“以自然法则前行，在程序员手中，吸纳各种优良设计。与之竞争的软件最终必与之想像；空，空，真空，虚无，万岁！”\n\n听到此，学生眼中一亮。\n\n\n八、无名师与最终用户\n\n无名师又一次布道时，一个最终用户听说了他的智慧，跑来求教。\n\n他对无名师三鞠躬。“我欲学习Unix大道，”他说，“但是弄不懂命令行。”\n\n一个旁观的新门徒开始嘲讽最终用户，说他脑子一锅粥，说只有经训练者、有智慧者才配使用Unix。\n\n无名师抚手不语，命这个嘲笑最终用户的新门徒前坐，坐到最终用户身边。\n\n“告诉我，”他对新门徒说，“你写过什么代码，有过什么突出设计。”\n\n新门徒嗫嚅了两句，然后沉默了。\n\n无名师转向最终用户。“告诉我”，他问，“为何你要寻求大道？”\n\n“我用的软件并不能令我满意”，最终用户答，“既不稳定，也不美观。听说Unix之道尽管艰难，但超越一切，我愿抛去一切诱饵和虚像。”\n\n“那么，”无名师问，“你为何想尽办法让软件帮你做事？”\n\n“我是个建筑工”，最终用户答道，“这座城里的很多房屋都出自我手。”\n\n无名师转向新门徒。“家猫也能欺负老虎”，无名师说，“但是猫叫永远比不过虎吼。”\n\n听到此，新门徒眼中一亮。\n\n        ', null);
INSERT INTO `blog` VALUES ('46', '2012-05-19', '\n            \n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 周末了，说好的特产网还是没能按所想的那样，华丽丽的修正那些bug，莫名其妙的bug，修正了一个又莫名其妙的出现新的bug，过滤了一遍又一遍的数据，还是有很多莫名其妙的东西，恨不能把全部程序删掉重新写过，本来思路很清晰的看着原有的代码，看着看着就跟着程序一起绕了进去搅不出来，改着改着就跟着写这玩意儿的人的思想里。这个礼拜对项目版本的控制和代码整洁之道有了一个更深刻的认识，我知道遇到困难更要迎刃而上，既然答应接手特产网，就不会随便放弃这个项目，要亲手让他从手上活得好好的，漂漂亮亮的，下个礼拜，我希望它能很轻松的在互联网上安稳快速的跑着，“兄弟连”的帅气程序员们，大家加油！\n\n\n        ', null);
INSERT INTO `blog` VALUES ('47', '一个完整的回合制游戏demo 。。。。嗯，好思路~~~', '\n            \n \n\n\n #include&nbsp;&quot;stdafx.h&quot; &nbsp;&nbsp;\n #include&nbsp;&lt;stdio.h&gt; &nbsp;&nbsp;\n &nbsp;&nbsp;\n //定义一个结构体 &nbsp;&nbsp;\n struct&nbsp;chr&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fHp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lv;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kind;&nbsp;&nbsp;\n };&nbsp;&nbsp;\n &nbsp;&nbsp;\n //全局变量声明 &nbsp;&nbsp;\n HINSTANCE&nbsp;hInst;&nbsp;&nbsp;\n HBITMAP&nbsp;bg,sheep,girl,skill,skillult,slash,magic,recover,game;&nbsp;&nbsp;\n HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdc,mdc,bufdc;&nbsp;&nbsp;\n HWND&nbsp;&nbsp;&nbsp;&nbsp;hWnd;&nbsp;&nbsp;\n DWORD&nbsp;&nbsp;&nbsp;tPre,tNow;&nbsp;&nbsp;\n int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pNum,f,txtNum;&nbsp;&nbsp;\n bool&nbsp;&nbsp;&nbsp;&nbsp;attack,over;&nbsp;&nbsp;\n chr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player,monster;&nbsp;&nbsp;\n char&nbsp;&nbsp;&nbsp;&nbsp;text[5][100];&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;\n //全局函数声明 &nbsp;&nbsp;\n ATOM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyRegisterClass(HINSTANCE&nbsp;hInstance);&nbsp;&nbsp;\n BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InitInstance(HINSTANCE,&nbsp;int);&nbsp;&nbsp;\n LRESULT&nbsp;CALLBACK&nbsp;&nbsp;&nbsp;&nbsp;WndProc(HWND,&nbsp;UINT,&nbsp;WPARAM,&nbsp;LPARAM);&nbsp;&nbsp;\n void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyPaint(HDC&nbsp;hdc);&nbsp;&nbsp;\n void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(char*);&nbsp;&nbsp;\n void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckDie(int&nbsp;hp,bool&nbsp;player);&nbsp;&nbsp;\n &nbsp;&nbsp;\n //****WinMain函数，程序入口点函数************************************** &nbsp;&nbsp;\n int&nbsp;APIENTRY&nbsp;WinMain(HINSTANCE&nbsp;hInstance,&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpCmdLine,&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nCmdShow)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;msg;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;MyRegisterClass(hInstance);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;//初始化&nbsp;&nbsp; &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!InitInstance&nbsp;(hInstance,&nbsp;nCmdShow))&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;//消息循环 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;GetMessage(&amp;msg,NULL,NULL,NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化msg&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;msg.message!=WM_QUIT&nbsp;)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;PeekMessage(&nbsp;&amp;msg,&nbsp;NULL,&nbsp;0,0&nbsp;,PM_REMOVE)&nbsp;)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TranslateMessage(&nbsp;&amp;msg&nbsp;);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DispatchMessage(&nbsp;&amp;msg&nbsp;);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tNow&nbsp;=&nbsp;GetTickCount();&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tNow-tPre&nbsp;&gt;=&nbsp;40)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyPaint(hdc);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;msg.wParam;&nbsp;&nbsp;\n }&nbsp;&nbsp;\n &nbsp;&nbsp;\n //***设计一个窗口类，类似填空题，使用窗口结构体************************* &nbsp;&nbsp;\n ATOM&nbsp;MyRegisterClass(HINSTANCE&nbsp;hInstance)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;WNDCLASSEX&nbsp;wcex;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.cbSize&nbsp;=&nbsp;sizeof(WNDCLASSEX);&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.style&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;CS_HREDRAW&nbsp;|&nbsp;CS_VREDRAW&nbsp;|&nbsp;CS_DBLCLKS;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.lpfnWndProc&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(WNDPROC)WndProc;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.cbClsExtra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.cbWndExtra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.hInstance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;hInstance;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.hIcon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.hCursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.hCursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;LoadCursor(NULL,&nbsp;IDC_ARROW);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.hbrBackground&nbsp;&nbsp;=&nbsp;(HBRUSH)(COLOR_WINDOW+1);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.lpszMenuName&nbsp;&nbsp;&nbsp;=&nbsp;NULL;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.lpszClassName&nbsp;&nbsp;=&nbsp;&quot;canvas&quot;;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;wcex.hIconSm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;RegisterClassEx(&amp;wcex);&nbsp;&nbsp;\n }&nbsp;&nbsp;\n &nbsp;&nbsp;\n //****初始化函数************************************ &nbsp;&nbsp;\n //加载位图并设定各种初始值&nbsp; &nbsp;&nbsp;\n BOOL&nbsp;InitInstance(HINSTANCE&nbsp;hInstance,&nbsp;int&nbsp;nCmdShow)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;HBITMAP&nbsp;bmp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;hInst&nbsp;=&nbsp;hInstance;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;hWnd&nbsp;=&nbsp;CreateWindow(&quot;canvas&quot;,&nbsp;&quot;浅墨的绘图窗口&quot;&nbsp;,&nbsp;WS_OVERLAPPEDWINDOW,&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CW_USEDEFAULT,&nbsp;0,&nbsp;CW_USEDEFAULT,&nbsp;0,&nbsp;NULL,&nbsp;NULL,&nbsp;hInstance,&nbsp;NULL);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!hWnd)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;MoveWindow(hWnd,10,10,640,510,true);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;ShowWindow(hWnd,&nbsp;nCmdShow);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;UpdateWindow(hWnd);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;hdc&nbsp;=&nbsp;GetDC(hWnd);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;mdc&nbsp;=&nbsp;CreateCompatibleDC(hdc);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;bufdc&nbsp;=&nbsp;CreateCompatibleDC(hdc);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;bmp&nbsp;=&nbsp;CreateCompatibleBitmap(hdc,640,510);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;SelectObject(mdc,bmp);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;bg&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;bg.bmp&quot;,IMAGE_BITMAP,640,510,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;sheep&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;sheep.bmp&quot;,IMAGE_BITMAP,133,220,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;girl&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;girl.bmp&quot;,IMAGE_BITMAP,480,148,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;skill&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;skill.bmp&quot;,IMAGE_BITMAP,50,50,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;skillult&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;skillult.bmp&quot;,IMAGE_BITMAP,50,50,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;slash&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;slash.bmp&quot;,IMAGE_BITMAP,196,162,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;magic&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;magic.bmp&quot;,IMAGE_BITMAP,200,100,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;recover.bmp&quot;,IMAGE_BITMAP,300,150,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;game&nbsp;=&nbsp;(HBITMAP)LoadImage(NULL,&quot;over.bmp&quot;,IMAGE_BITMAP,289,74,LR_LOADFROMFILE);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;player.nHp&nbsp;=&nbsp;player.fHp&nbsp;=&nbsp;50;&nbsp;&nbsp;&nbsp;//设定玩家角色声明值及上限 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;player.lv&nbsp;=&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设定玩家角色等级 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;player.w&nbsp;&nbsp;=&nbsp;4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设定攻击伤害加权值 &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;monster.nHp&nbsp;=&nbsp;monster.fHp&nbsp;=&nbsp;120;&nbsp;&nbsp;&nbsp;&nbsp;//设定怪物角色生命值及上限 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;monster.lv&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设定怪物角色等级 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;monster.w&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设定攻击伤害加权值 &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;txtNum&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//显示消息数目 &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;SetBkMode(mdc,&nbsp;TRANSPARENT);&nbsp;&nbsp;&nbsp;&nbsp;//设置TextOut背景透明 &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;MyPaint(hdc);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;&nbsp;&nbsp;\n }&nbsp;&nbsp;\n &nbsp;&nbsp;\n //****自定义绘图函数********************************* &nbsp;&nbsp;\n //&nbsp;1.画面贴图与对战消息显示 &nbsp;&nbsp;\n //&nbsp;2.怪物行为判断及各项数据处理与计算 &nbsp;&nbsp;\n void&nbsp;MyPaint(HDC&nbsp;hdc)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;str[100];&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,damage;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;//贴上背景图 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,bg);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,0,0,640,510,bufdc,0,0,SRCCOPY);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;//显示对战消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;txtNum;i++)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextOut(mdc,0,360+i*18,text[i],strlen(text[i]));&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;//贴上怪物图 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if(monster.nHp&gt;0)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,sheep);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,70,180,133,110,bufdc,0,110,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,70,180,133,110,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;%d&nbsp;/&nbsp;%d&quot;,monster.nHp,monster.fHp);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextOut(mdc,100,320,str,strlen(str));&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;//贴上玩家图 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if(player.nHp&gt;0)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,girl);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,500,200,60,74,bufdc,pNum*60,74,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,500,200,60,74,bufdc,pNum*60,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;%d&nbsp;/&nbsp;%d&quot;,player.nHp,player.fHp);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextOut(mdc,510,320,str,strlen(str));&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if(over)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//贴上游戏结束图画 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,game);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,200,200,289,37,bufdc,0,37,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,200,200,289,37,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(!attack)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//贴上攻击命令图画 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,skill);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,500,350,50,50,bufdc,0,0,SRCCOPY);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,skillult);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,430,350,50,50,bufdc,0,0,SRCCOPY);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//BitBlt(mdc,500,350,74,30,bufdc,0,30,SRCAND); &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//BitBlt(mdc,500,350,74,30,bufdc,0,0,SRCPAINT); &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f++;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第5~10个画面时显示玩家攻击图标 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&gt;=5&nbsp;&amp;&amp;&nbsp;f&lt;=10)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,slash);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,100,160,98,162,bufdc,98,0,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,100,160,98,162,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第10个画面时计算怪物受伤害程度并加入显示消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;10)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(4==rand()%5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;20%几率触发幻影刺客的大招，恩赐解脱，4倍暴击伤害 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;damage&nbsp;=&nbsp;4*(rand()%10&nbsp;+&nbsp;player.lv*player.w);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.nHp&nbsp;-=&nbsp;(int)damage;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;恩赐解脱触发，这下牛逼了，4倍暴击...对怪物照成了%d点伤害&quot;,damage);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;damage&nbsp;=&nbsp;rand()%10&nbsp;+&nbsp;player.lv*player.w;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.nHp&nbsp;-=&nbsp;(int)damage;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;玩家使用了无敌斩，伤害一般般...对怪物照成了%d点伤害&quot;,damage);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckDie(monster.nHp,false);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srand(tPre);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第15个画面时判断怪物进行哪项动作 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;15)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(monster.nHp&nbsp;&gt;&nbsp;20)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生命值大于20 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(rand()%5&nbsp;!=&nbsp;1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//进行利爪攻击概率4/5 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;0;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//进行闪电链攻击概率1/5 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生命值小于20 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(rand()%5)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//利爪攻击 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;0;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放闪电链 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;1;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//致命一击 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;2;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用梅肯斯姆回复 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;3;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//逃跑 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.kind&nbsp;=&nbsp;4;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第26~30个画面时显示玩家攻击图标 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&gt;=26&nbsp;&nbsp;&amp;&amp;&nbsp;f&lt;=30)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(monster.kind)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//利爪攻击 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,slash);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,480,150,98,162,bufdc,98,0,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,480,150,98,162,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第30个画面时计算玩家受伤害程度并加入显示消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;30)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;damage&nbsp;=&nbsp;rand()%10&nbsp;+&nbsp;monster.lv*monster.w;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player.nHp&nbsp;-=&nbsp;(int)damage;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;怪物利爪攻击...对玩家照成&nbsp;%d&nbsp;点伤害&quot;,damage);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckDie(player.nHp,true);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放闪电链 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,magic);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,480,190,100,100,bufdc,100,0,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,480,190,100,100,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第30个画面时计算玩家受伤害程度并加入显示消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;30)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;damage&nbsp;=&nbsp;rand()%10&nbsp;+&nbsp;3*monster.w;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player.nHp&nbsp;-=&nbsp;(int)damage;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;怪物释放闪电链...对玩家照成&nbsp;%d&nbsp;点伤害&quot;,damage);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckDie(player.nHp,true);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//致命一击 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,slash);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,480,150,98,162,bufdc,98,0,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,480,150,98,162,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第30个画面时计算玩家受伤害程度并加入显示消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;30)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;damage&nbsp;=&nbsp;rand()%10&nbsp;+&nbsp;monster.lv*monster.w*5;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player.nHp&nbsp;-=&nbsp;(int)damage;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;怪物致命一击...对玩家照成&nbsp;%d&nbsp;点伤害.&quot;,damage);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckDie(player.nHp,true);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用梅肯斯姆补血 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectObject(bufdc,recover);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,60,160,150,150,bufdc,150,0,SRCAND);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitBlt(mdc,60,160,150,150,bufdc,0,0,SRCPAINT);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第30个画面时怪物回复生命值并加入显示消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;30)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.nHp&nbsp;+=&nbsp;30;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;怪物使用梅肯斯姆...恢复了30点生命值&quot;,damage);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;4:&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在第30个画面时判断怪物是否逃跑成功 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;30)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(1==&nbsp;rand()%3&nbsp;)&nbsp;&nbsp;&nbsp;//逃跑几率1/3 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;over&nbsp;=&nbsp;true;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monster.nHp&nbsp;=&nbsp;0;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;怪物逃跑中...逃跑成功&quot;);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;怪物逃跑中...逃跑失败&quot;);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f&nbsp;==&nbsp;30)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//回合结束 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attack&nbsp;=&nbsp;false;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;0;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;BitBlt(hdc,0,0,640,510,mdc,0,0,SRCCOPY);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;tPre&nbsp;=&nbsp;GetTickCount();&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;pNum++;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if(pNum&nbsp;==&nbsp;8)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pNum&nbsp;=&nbsp;0;&nbsp;&nbsp;\n }&nbsp;&nbsp;\n &nbsp;&nbsp;\n //****新增的对战消息函数******************************** &nbsp;&nbsp;\n void&nbsp;MsgInsert(char*&nbsp;str)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if(txtNum&nbsp;&lt;&nbsp;5)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(text[txtNum],str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txtNum++;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;txtNum;i++)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(text[i],text[i+1]);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(text[4],str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n }&nbsp;&nbsp;\n &nbsp;&nbsp;\n //****生命值判断函数************************* &nbsp;&nbsp;\n void&nbsp;CheckDie(int&nbsp;hp,bool&nbsp;player)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;str[100];&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;if(hp&nbsp;&lt;=&nbsp;0)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;over&nbsp;=&nbsp;true;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(player)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;胜败乃兵家常事，大侠请重新来过......&quot;);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(str,&quot;少年，你赢了，有两下子啊~~~~~！！！！&quot;);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgInsert(str);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n }&nbsp;&nbsp;\n &nbsp;&nbsp;\n //****消息处理函数*********************************** &nbsp;&nbsp;\n //&nbsp; &nbsp;&nbsp;\n LRESULT&nbsp;CALLBACK&nbsp;WndProc(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;message,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)&nbsp;&nbsp;\n {&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x,y;&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(message)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;WM_KEYDOWN:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//键盘消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(wParam==VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//按下Esc键 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostQuitMessage(0);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;WM_LBUTTONDOWN:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//鼠标左键消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!attack)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;LOWORD(lParam);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//X坐标 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;HIWORD(lParam);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Y坐标 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(x&nbsp;&gt;=&nbsp;500&nbsp;&amp;&amp;&nbsp;x&nbsp;&lt;=&nbsp;550&nbsp;&amp;&amp;&nbsp;y&nbsp;&gt;=&nbsp;350&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;=&nbsp;400)&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attack&nbsp;=&nbsp;true;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//窗口结束消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteDC(mdc);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteDC(bufdc);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(bg);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(sheep);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(girl);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(skill);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(skillult);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(slash);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(magic);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(recover);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteObject(game);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReleaseDC(hWnd,hdc);&nbsp;&nbsp;\n &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostQuitMessage(0);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//默认消息 &nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;DefWindowProc(hWnd,&nbsp;message,&nbsp;wParam,&nbsp;lParam);&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n &nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;\n }&nbsp;&nbsp;\n#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;//定义一个结构体struct chr{ int nHp; int fHp; int lv; int w; int kind;};//全局变量声明HINSTANCE hInst;HBITMAP bg,sheep,girl,skill,skillult,slash,magic,recover,game;HDC hdc,mdc,bufdc;HWND hWnd;DWORD tPre,tNow;int pNum,f,txtNum;bool attack,over;chr player,monster;char text[5][100];//全局函数声明ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void MyPaint(HDC hdc);void MsgInsert(char*);void CheckDie(int hp,bool player);//****WinMain函数，程序入口点函数**************************************int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ MSG msg; MyRegisterClass(hInstance); //初始化 if (!InitInstance (hInstance, nCmdShow)) { return FALSE; } //消息循环 GetMessage(&amp;msg,NULL,NULL,NULL); //初始化msg while( msg.message!=WM_QUIT ) { if( PeekMessage( &amp;msg, NULL, 0,0 ,PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow-tPre &gt;= 40) MyPaint(hdc); } } return msg.wParam;}//***设计一个窗口类，类似填空题，使用窗口结构体*************************ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; wcex.lpfnWndProc = (WNDPROC)WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = NULL; wcex.hCursor = NULL; wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL; wcex.lpszClassName = &quot;canvas&quot;; wcex.hIconSm = NULL; return RegisterClassEx(&amp;wcex);}//****初始化函数************************************//加载位图并设定各种初始值 BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){ HBITMAP bmp; hInst = hInstance; hWnd = CreateWindow(&quot;canvas&quot;, &quot;浅墨的绘图窗口&quot; , WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL); if (!hWnd) { return FALSE; } MoveWindow(hWnd,10,10,640,510,true); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); hdc = GetDC(hWnd); mdc = CreateCompatibleDC(hdc); bufdc = CreateCompatibleDC(hdc); bmp = CreateCompatibleBitmap(hdc,640,510); SelectObject(mdc,bmp); bg = (HBITMAP)LoadImage(NULL,&quot;bg.bmp&quot;,IMAGE_BITMAP,640,510,LR_LOADFROMFILE); sheep = (HBITMAP)LoadImage(NULL,&quot;sheep.bmp&quot;,IMAGE_BITMAP,133,220,LR_LOADFROMFILE); girl = (HBITMAP)LoadImage(NULL,&quot;girl.bmp&quot;,IMAGE_BITMAP,480,148,LR_LOADFROMFILE); skill = (HBITMAP)LoadImage(NULL,&quot;skill.bmp&quot;,IMAGE_BITMAP,50,50,LR_LOADFROMFILE); skillult = (HBITMAP)LoadImage(NULL,&quot;skillult.bmp&quot;,IMAGE_BITMAP,50,50,LR_LOADFROMFILE); slash = (HBITMAP)LoadImage(NULL,&quot;slash.bmp&quot;,IMAGE_BITMAP,196,162,LR_LOADFROMFILE); magic = (HBITMAP)LoadImage(NULL,&quot;magic.bmp&quot;,IMAGE_BITMAP,200,100,LR_LOADFROMFILE); recover = (HBITMAP)LoadImage(NULL,&quot;recover.bmp&quot;,IMAGE_BITMAP,300,150,LR_LOADFROMFILE); game = (HBITMAP)LoadImage(NULL,&quot;over.bmp&quot;,IMAGE_BITMAP,289,74,LR_LOADFROMFILE); player.nHp = player.fHp = 50; //设定玩家角色声明值及上限 player.lv = 2; //设定玩家角色等级 player.w = 4; //设定攻击伤害加权值 monster.nHp = monster.fHp = 120; //设定怪物角色生命值及上限 monster.lv = 1; //设定怪物角色等级 monster.w = 1; //设定攻击伤害加权值 txtNum = 0; //显示消息数目 SetBkMode(mdc, TRANSPARENT); //设置TextOut背景透明 MyPaint(hdc); return TRUE;}//****自定义绘图函数*********************************// 1.画面贴图与对战消息显示// 2.怪物行为判断及各项数据处理与计算void MyPaint(HDC hdc){ char str[100]; int i,damage; //贴上背景图 SelectObject(bufdc,bg); BitBlt(mdc,0,0,640,510,bufdc,0,0,SRCCOPY); //显示对战消息 for(i=0;i&lt;txtNum;i++) TextOut(mdc,0,360+i*18,text[i],strlen(text[i])); //贴上怪物图 if(monster.nHp&gt;0) { SelectObject(bufdc,sheep); BitBlt(mdc,70,180,133,110,bufdc,0,110,SRCAND); BitBlt(mdc,70,180,133,110,bufdc,0,0,SRCPAINT); sprintf(str,&quot;%d / %d&quot;,monster.nHp,monster.fHp); TextOut(mdc,100,320,str,strlen(str)); } //贴上玩家图 if(player.nHp&gt;0) { SelectObject(bufdc,girl); BitBlt(mdc,500,200,60,74,bufdc,pNum*60,74,SRCAND); BitBlt(mdc,500,200,60,74,bufdc,pNum*60,0,SRCPAINT); sprintf(str,&quot;%d / %d&quot;,player.nHp,player.fHp); TextOut(mdc,510,320,str,strlen(str)); } if(over) //贴上游戏结束图画 { SelectObject(bufdc,game); BitBlt(mdc,200,200,289,37,bufdc,0,37,SRCAND); BitBlt(mdc,200,200,289,37,bufdc,0,0,SRCPAINT); } else if(!attack) //贴上攻击命令图画 { SelectObject(bufdc,skill); BitBlt(mdc,500,350,50,50,bufdc,0,0,SRCCOPY); SelectObject(bufdc,skillult); BitBlt(mdc,430,350,50,50,bufdc,0,0,SRCCOPY); //BitBlt(mdc,500,350,74,30,bufdc,0,30,SRCAND); //BitBlt(mdc,500,350,74,30,bufdc,0,0,SRCPAINT); } else { f++; //第5~10个画面时显示玩家攻击图标 if(f&gt;=5 &amp;&amp; f&lt;=10) { SelectObject(bufdc,slash); BitBlt(mdc,100,160,98,162,bufdc,98,0,SRCAND); BitBlt(mdc,100,160,98,162,bufdc,0,0,SRCPAINT); //第10个画面时计算怪物受伤害程度并加入显示消息 if(f == 10) { if (4==rand()%5) // 20%几率触发幻影刺客的大招，恩赐解脱，4倍暴击伤害 { damage = 4*(rand()%10 + player.lv*player.w); monster.nHp -= (int)damage; sprintf(str,&quot;恩赐解脱触发，这下牛逼了，4倍暴击...对怪物照成了%d点伤害&quot;,damage); } else { damage = rand()%10 + player.lv*player.w; monster.nHp -= (int)damage; sprintf(str,&quot;玩家使用了无敌斩，伤害一般般...对怪物照成了%d点伤害&quot;,damage); } MsgInsert(str); CheckDie(monster.nHp,false); } } srand(tPre); //第15个画面时判断怪物进行哪项动作 if(f == 15) { if(monster.nHp &gt; 20) //生命值大于20 { if(rand()%5 != 1) //进行利爪攻击概率4/5 monster.kind = 0; else //进行闪电链攻击概率1/5 monster.kind = 1; } else //生命值小于20 { switch(rand()%5) { case 0: //利爪攻击 monster.kind = 0; break; case 1: //释放闪电链 monster.kind = 1; break; case 2: //致命一击 monster.kind = 2; break; case 3: //使用梅肯斯姆回复 monster.kind = 3; break; case 4: //逃跑 monster.kind = 4; break; } } } //第26~30个画面时显示玩家攻击图标 if(f&gt;=26 &amp;&amp; f&lt;=30) { switch(monster.kind) { case 0: //利爪攻击 SelectObject(bufdc,slash); BitBlt(mdc,480,150,98,162,bufdc,98,0,SRCAND); BitBlt(mdc,480,150,98,162,bufdc,0,0,SRCPAINT); //第30个画面时计算玩家受伤害程度并加入显示消息 if(f == 30) { damage = rand()%10 + monster.lv*monster.w; player.nHp -= (int)damage; sprintf(str,&quot;怪物利爪攻击...对玩家照成 %d 点伤害&quot;,damage); MsgInsert(str); CheckDie(player.nHp,true); } break; case 1: //释放闪电链 SelectObject(bufdc,magic); BitBlt(mdc,480,190,100,100,bufdc,100,0,SRCAND); BitBlt(mdc,480,190,100,100,bufdc,0,0,SRCPAINT); //第30个画面时计算玩家受伤害程度并加入显示消息 if(f == 30) { damage = rand()%10 + 3*monster.w; player.nHp -= (int)damage; sprintf(str,&quot;怪物释放闪电链...对玩家照成 %d 点伤害&quot;,damage); MsgInsert(str); CheckDie(player.nHp,true); } break; case 2: //致命一击 SelectObject(bufdc,slash); BitBlt(mdc,480,150,98,162,bufdc,98,0,SRCAND); BitBlt(mdc,480,150,98,162,bufdc,0,0,SRCPAINT); //第30个画面时计算玩家受伤害程度并加入显示消息 if(f == 30) { damage = rand()%10 + monster.lv*monster.w*5; player.nHp -= (int)damage; sprintf(str,&quot;怪物致命一击...对玩家照成 %d 点伤害.&quot;,damage); MsgInsert(str); CheckDie(player.nHp,true); } break; case 3: //使用梅肯斯姆补血 SelectObject(bufdc,recover); BitBlt(mdc,60,160,150,150,bufdc,150,0,SRCAND); BitBlt(mdc,60,160,150,150,bufdc,0,0,SRCPAINT); //第30个画面时怪物回复生命值并加入显示消息 if(f == 30) { monster.nHp += 30; sprintf(str,&quot;怪物使用梅肯斯姆...恢复了30点生命值&quot;,damage); MsgInsert(str); } break; case 4: //在第30个画面时判断怪物是否逃跑成功 if(f == 30) { if(1== rand()%3 ) //逃跑几率1/3 { over = true; monster.nHp = 0; sprintf(str,&quot;怪物逃跑中...逃跑成功&quot;); MsgInsert(str); } else { sprintf(str,&quot;怪物逃跑中...逃跑失败&quot;); MsgInsert(str); } } break; } } if(f == 30) //回合结束 { attack = false; f = 0; } } BitBlt(hdc,0,0,640,510,mdc,0,0,SRCCOPY); tPre = GetTickCount(); pNum++; if(pNum == 8) pNum = 0;}//****新增的对战消息函数********************************void MsgInsert(char* str){ if(txtNum &lt; 5) { sprintf(text[txtNum],str); txtNum++; } else { for(int i=0;i&lt;txtNum;i++) sprintf(text[i],text[i+1]); sprintf(text[4],str); }}//****生命值判断函数*************************void CheckDie(int hp,bool player){ char str[100]; if(hp &lt;= 0) { over = true; if(player) { sprintf(str,&quot;胜败乃兵家常事，大侠请重新来过......&quot;); MsgInsert(str); } else { sprintf(str,&quot;少年，你赢了，有两下子啊~~~~~！！！！&quot;); MsgInsert(str); } }}//****消息处理函数***********************************// LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int x,y; switch (message) { case WM_KEYDOWN: //键盘消息 if(wParam==VK_ESCAPE) //按下Esc键 PostQuitMessage(0); break; case WM_LBUTTONDOWN: //鼠标左键消息 if(!attack) { x = LOWORD(lParam); //X坐标 y = HIWORD(lParam); //Y坐标 if(x &gt;= 500 &amp;&amp; x &lt;= 550 &amp;&amp; y &gt;= 350 &amp;&amp; y &lt;= 400) attack = true; } break; case WM_DESTROY: //窗口结束消息 DeleteDC(mdc); DeleteDC(bufdc); DeleteObject(bg); DeleteObject(sheep); DeleteObject(girl); DeleteObject(skill); DeleteObject(skillult); DeleteObject(slash); DeleteObject(magic); DeleteObject(recover); DeleteObject(game); ReleaseDC(hWnd,hdc); PostQuitMessage(0); break; default: //默认消息 return DefWindowProc(hWnd, message, wParam, lParam); } return 0;}\n\n\n\n\n\n\n每一回合开始的时候，我们点击画面上“无敌斩”的技能图标，就可以进行攻击，对怪物造成伤害，人品好的话，还可以触发强力被动技能“恩赐解脱”，对怪物造成4倍暴击伤害，这里我们设定的暴击概率为20%\n\n\n\n\n浅墨在截图的时候，人品挺好的，恩赐解脱的暴击概率为20%，但是浅墨的4次攻击里，有3次都打出了“恩赐解脱”的暴击效果，直接果断地把这只小绵羊带走了，呵呵。\n\n下面就是游戏运行的截图：\n游戏开始\n\n\n\n\n第一刀就出暴击了，48点伤害\n\n\n\n\n运气不错，又一刀暴击，68点伤害\n\n\n\n\n最后一刀又出了暴击，小绵羊被“秒杀”，游戏结束\n\n\n\n\n\n\n\n\n我们还可以调节怪物等级，怪物攻击加权值，怪物血量上限以及玩家角色等级，玩家角色攻击加权值，玩家角色血量上限来让游戏更具挑战性。\n\n当然，我们也可以增加更多的代码，来使怪物的思考与行动方式更具真实性和多样性，来使玩家的技能更加丰富。\n\n\n这个回合制游戏demo可以说是目前市场上回合制游戏的本体，《仙剑奇侠传》（三代以前的，三代及以后的仙剑都是进度条模式了），《梦幻西游》《问道》等经典的回合制游戏，无非就是在这种风格的demo基础上，写更多的代码，丰富内容而已，或为游戏引擎的核心代码。\n\n        ', null);
INSERT INTO `blog` VALUES ('48', '40种常用JS代码', '\n            1. oncontextmenu=&quot;window.event.returnValue=false&quot; 将彻底屏蔽鼠标右键 &lt;table border oncontextmenu=return(false)&gt;&lt;td&gt;no&lt;/table&gt; 可用于Table\n2. &lt;body onselectstart=&quot;return false&quot;&gt; 取消选取、防止复制\n3. onpaste=&quot;return false&quot; 不准粘贴\n4. oncopy=&quot;return false;&quot; oncut=&quot;return false;&quot; 防止复制\n5. &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;favicon.ico&quot;&gt; IE地址栏前换成自己的图标\n6. &lt;link rel=&quot;Bookmark&quot; href=&quot;favicon.ico&quot;&gt; 可以在收藏夹中显示出你的图标\n7. &lt;input class=&quot;ime-mode:disabled&quot;&gt; 关闭输入法\n8. 永远都会带着框架 &lt;script language=&quot;JavaScript&quot;&gt;&lt;!-- if (window == top)top.location.href = &quot;frames.htm&quot;; //frames.htm为框架网页 // --&gt;&lt;/script&gt;\n9. 防止被人frame &lt;SCRIPT LANGUAGE=JAVASCRIPT&gt;&lt;!-- if (top.location != self.location)top.location=self.location; // --&gt;&lt;/SCRIPT&gt;\n10. 网页将不能被另存为 &lt;noscript&gt;&lt;iframe src=*.html&gt;&lt;/iframe&gt;&lt;/noscript&gt;\n11. &lt;input type=button value=查看网页源代码 onclick=&quot;window.location = &quot;view-source:&quot;+ &quot;http://www.pconline.com.cn&quot;&quot;&gt;\n12.删除时确认 &lt;a href=&quot;javascript:if(confirm(&quot;确实要删除吗?&quot;))location=&quot;boos.asp?&amp;areyou=删除&amp;page=1&quot;&quot;&gt;删除&lt;/a&gt;\n13. 取得控件的绝对位置 //Javascript &lt;script language=&quot;Javascript&quot;&gt; function getIE(e){ var t=e.offsetTop; var l=e.offsetLeft; while(e=e.offsetParent){ t+=e.offsetTop; l+=e.offsetLeft; } alert(&quot;top=&quot;+t+&quot;/nleft=&quot;+l); } &lt;/script&gt;\n//VBScript &lt;script language=&quot;VBScript&quot;&gt;&lt;!-- function getIE() dim t,l,a,b set a=document.all.img1 t=document.all.img1.offsetTop l=document.all.img1.offsetLeft while a.tagName&lt;&gt;&quot;BODY&quot; set a = a.offsetParent t=t+a.offsetTop l=l+a.offsetLeft wend msgbox &quot;top=&quot;&amp;t&amp;chr(13)&amp;&quot;left=&quot;&amp;l,64,&quot;得到控件的位置&quot; end function --&gt;&lt;/script&gt;\n14. 光标是停在文本框文字的最后 &lt;script language=&quot;javascript&quot;&gt; function cc() { var e = event.srcElement; var r =e.createTextRange(); r.moveStart(&quot;character&quot;,e.value.length); r.collapse(true); r.select(); } &lt;/script&gt; &lt;input type=text name=text1 value=&quot;123&quot; onfocus=&quot;cc()&quot;&gt;\n15. 判断上一页的来源 javascript: document.referrer\n16. 最小化、最大化、关闭窗口 &lt;object id=hh1 classid=&quot;clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11&quot;&gt; &lt;param name=&quot;Command&quot; value=&quot;Minimize&quot;&gt;&lt;/object&gt; &lt;object id=hh2 classid=&quot;clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11&quot;&gt; &lt;param name=&quot;Command&quot; value=&quot;Maximize&quot;&gt;&lt;/object&gt; &lt;OBJECT id=hh3 classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot;&gt; &lt;PARAM NAME=&quot;Command&quot; VALUE=&quot;Close&quot;&gt;&lt;/OBJECT&gt; &lt;input type=button value=最小化 onclick=hh1.Click()&gt; &lt;input type=button value=最大化 onclick=hh2.Click()&gt; &lt;input type=button value=关闭 onclick=hh3.Click()&gt; 本例适用于IE\n17.屏蔽功能键Shift,Alt,Ctrl &lt;script&gt; function look(){ if(event.shiftKey) alert(&quot;禁止按Shift键!&quot;); //可以换成ALT CTRL } document.onkeydown=look; &lt;/script&gt;\n18. 网页不会被缓存 &lt;META HTTP-EQUIV=&quot;pragma&quot; CONTENT=&quot;no-cache&quot;&gt; &lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache, must-revalidate&quot;&gt; &lt;META HTTP-EQUIV=&quot;expires&quot; CONTENT=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;&gt; 或者&lt;META HTTP-EQUIV=&quot;expires&quot; CONTENT=&quot;0&quot;&gt;\n19.怎样让表单没有凹凸感？ &lt;input type=text class=&quot;border:1 solid #000000&quot;&gt; 或 &lt;input type=text class=&quot;border-left:none; border-right:none; border-top:none; border-bottom:\n1 solid #000000&quot;&gt;&lt;/textarea&gt;\n20.&lt;div&gt;&lt;span&gt;&amp;&lt;layer&gt;的区别？ &lt;div&gt;(division)用来定义大段的页面元素，会产生转行 &lt;span&gt;用来定义同一行内的元素，跟&lt;div&gt;的唯一区别是不产生转行 &lt;layer&gt;是ns的标记，ie不支持，相当于&lt;div&gt;\n21.让弹出窗口总是在最上面: &lt;body onblur=&quot;this.focus();&quot;&gt;\n22.不要滚动条? 让竖条没有: &lt;body class=&quot;overflow:scroll;overflow-y:hidden&quot;&gt; &lt;/body&gt; 让横条没有: &lt;body class=&quot;overflow:scroll;overflow-x:hidden&quot;&gt; &lt;/body&gt; 两个都去掉？更简单了 &lt;body scroll=&quot;no&quot;&gt; &lt;/body&gt;\n23.怎样去掉图片链接点击后，图片周围的虚线？ &lt;a href=&quot;#&quot; onFocus=&quot;this.blur()&quot;&gt;&lt;img src=&quot;logo.jpg&quot; border=0&gt;&lt;/a&gt;\n24.电子邮件处理提交表单 &lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;mailto:****@***.com&quot; enctype=&quot;text/plain&quot;&gt; &lt;input type=submit&gt; &lt;/form&gt;\n25.在打开的子窗口刷新父窗口的代码里如何写？ window.opener.location.reload()\n26.如何设定打开页面的大小 &lt;body onload=&quot;top.resizeTo(300,200);&quot;&gt; 打开页面的位置&lt;body onload=&quot;top.moveBy(300,200);&quot;&gt;\n27.在页面中如何加入不是满铺的背景图片,拉动页面时背景图不动 &lt;STYLE&gt; body {background-image:url(logo.gif); background-repeat:no-repeat; background-position:center;background-attachment: fixed} &lt;/STYLE&gt;\n28. 检查一段字符串是否全由数字组成 &lt;script language=&quot;Javascript&quot;&gt;&lt;!-- function checkNum(str){return str.match(//D/)==null} alert(checkNum(&quot;1232142141&quot;)) alert(checkNum(&quot;123214214a1&quot;)) // --&gt;&lt;/script&gt;\n29. 获得一个窗口的大小 document.body.clientWidth; document.body.clientHeight\n30. 怎么判断是否是字符 if (/[^/x00-/xff]/g.test(s)) alert(&quot;含有汉字&quot;); else alert(&quot;全是字符&quot;);\n31.TEXTAREA自适应文字行数的多少 &lt;textarea rows=1 name=s1 cols=27 onpropertychange=&quot;this.style.posHeight=this.scrollHeight&quot;&gt; &lt;/textarea&gt;\n32. 日期减去天数等于第二个日期 &lt;script language=Javascript&gt; function cc(dd,dadd) { //可以加上错误处理 var a = new Date(dd) a = a.valueOf() a = a - dadd * 24 * 60 * 60 * 1000 a = new Date(a) alert(a.getFullYear() + &quot;年&quot; + (a.getMonth() + 1) + &quot;月&quot; + a.getDate() + &quot;日&quot;) } cc(&quot;12/23/2002&quot;,2) &lt;/script&gt;\n33. 选择了哪一个Radio &lt;HTML&gt;&lt;script language=&quot;vbscript&quot;&gt; function checkme() for each ob in radio1 if ob.checked then window.alert ob.value next end function &lt;/script&gt;&lt;BODY&gt; &lt;INPUT name=&quot;radio1&quot; type=&quot;radio&quot; value=&quot;style&quot; checked&gt;Style &lt;INPUT name=&quot;radio1&quot; type=&quot;radio&quot; value=&quot;barcode&quot;&gt;Barcode &lt;INPUT type=&quot;button&quot; value=&quot;check&quot; onclick=&quot;checkme()&quot;&gt; &lt;/BODY&gt;&lt;/HTML&gt;\n34.脚本永不出错 &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; &lt;!-- Hide function killErrors() { return true; } window.onerror = killErrors; // --&gt; &lt;/SCRIPT&gt;\n35.ENTER键可以让光标移到下一个输入框 &lt;input onkeydown=&quot;if(event.keyCode==13)event.keyCode=9&quot;&gt;\n36. 检测某个网站的链接速度： 把如下代码加入&lt;body&gt;区域中: &lt;script language=Javascript&gt; tim=1 setInterval(&quot;tim++&quot;,100) b=1 var autourl=new Array() autourl[1]=&quot;www.njcatv.net&quot; autourl[2]=&quot;javacool.3322.net&quot; autourl[3]=&quot;www.sina.com.cn&quot; autourl[4]=&quot;www.nuaa.edu.cn&quot; autourl[5]=&quot;www.cctv.com&quot; function butt(){ document.write(&quot;&lt;form name=autof&gt;&quot;) for(var i=1;i&lt;autourl.length;i++) document.write(&quot;&lt;input type=text name=txt&quot;+i+&quot; size=10 value=测试中……&gt; =》&lt;input type=text name=url&quot;+i+&quot; size=40&gt; =》&lt;input type=button value=GO\nonclick=window.open(this.form.url&quot;+i+&quot;.value)&gt; &quot;) document.write(&quot;&lt;input type=submit value=刷新&gt;&lt;/form&gt;&quot;) } butt() function auto(url){ document.forms[0][&quot;url&quot;+b].value=url if(tim&gt;200) {document.forms[0][&quot;txt&quot;+b].value=&quot;链接超时&quot;} else {document.forms[0][&quot;txt&quot;+b].value=&quot;时间&quot;+tim/10+&quot;秒&quot;} b++ } function run(){for(var i=1;i&lt;autourl.length;i++)document.write(&quot;&lt;img src=http://&quot;+autourl+&quot;/&quot;+Math.random()+&quot;\nwidth=1 height=1\nonerror=auto(&quot;http://&quot;+autourl+&quot;&quot;)&gt;&quot;)} run()&lt;/script&gt;\n37. 各种样式的光标 auto ：标准光标 default ：标准箭头 hand ：手形光标 wait ：等待光标 text ：I形光标 vertical-text ：水平I形光标 no-drop ：不可拖动光标 not-allowed ：无效光标 help ：?帮助光标 all-scroll ：三角方向标 move ：移动标 crosshair ：十字标 e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize\n38.页面进入和退出的特效 进入页面&lt;meta http-equiv=&quot;Page-Enter&quot; content=&quot;revealTrans(duration=x, transition=y)&quot;&gt; 推出页面&lt;meta http-equiv=&quot;Page-Exit&quot; content=&quot;revealTrans(duration=x, transition=y)&quot;&gt; 这个是页面被载入和调出时的一些特效。duration表示特效的持续时间，以秒为单位。transition表示使用哪种特效，取值为\n1-23: 0 矩形缩小 1 矩形扩大 2 圆形缩小 3 圆形扩大 4 下到上刷新 5 上到下刷新 6 左到右刷新 7 右到左刷新 8 竖百叶窗 9 横百叶窗 10 错位横百叶窗 11 错位竖百叶窗 12 点扩散 13 左右到中间刷新 14 中间到左右刷新 15 中间到上下 16 上下到中间 17 右下到左上 18 右上到左下 19 左上到右下 20 左下到右上 21 横条 22 竖条 23 以上22种随机选择一种\n39.在规定时间内跳转 META http-equiv=V=&quot;REFRESH&quot; content=&quot;5;URL=http://www.51js.com&quot;&gt;\n40.网页是否被检索 &lt;meta name=&quot;ROBOTS&quot; content=&quot;属性值&quot;&gt; 其中属性值有以下一些: 属性值为&quot;all&quot;: 文件将被检索，且页上链接可被查询； 属性值为&quot;none&quot;: 文件不被检索，而且不查询页上的链接； 属性值为&quot;index&quot;: 文件将被检索； 属性值为&quot;follow&quot;: 查询页上的链接； 属性值为&quot;noindex&quot;: 文件不检索，但可被查询链接； 属性值为&quot;nofollow&quot;: 文件不被检索，但可查询页上的链接。 \n原文：http://hi.baidu.com/648636045/blog/item/387b2400e844f3044afb51e0.html \n        ', null);
INSERT INTO `blog` VALUES ('49', 'CentOS操作系统学习资料', '\n            http://www.centospub.com/make.html \n        ', null);
INSERT INTO `blog` VALUES ('50', '12/4/26', '\n            \n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 办公室外阳光明媚，看着技术部里四五十个程序员，扪心自问自己处于他们中的哪个角落，超越了多少人？多少人是仰望着的高大身影，多少个是崇拜着的大神。。。\n\n\n        ', null);
INSERT INTO `blog` VALUES ('51', 'Centos 5 安装compiz 实现3d桌面', '\n            \n 来源\nlinux数据库网\n 作者\nWhretofi\n\n 文章摘要: 1.升级内核。从2.6.18-8升级到2.6.18－53 下载如下3个内核rpm包 kernel-devel-2.6.18-53.el5 kernel-headers-2.6.18-53.el5 kernel-2.6.18-53.el5 然后rpm -ivh kernel安装。 2.安装nvidia显卡驱动。 我的dell d620的显卡型号是nvs 110m /gforce go 7300http://uk.download.nvidia.com/XF ... -100.14.23\n1.升级内核。从2.6.18-8升级到2.6.18－53\n下载如下3个内核rpm包\nkernel-devel-2.6.18-53.el5\nkernel-headers-2.6.18-53.el5\nkernel-2.6.18-53.el5\n然后rpm -ivh kernel安装。\n2.安装nvidia显卡驱动。\n我的dell d620的显卡型号是nvs 110m /gforce go 7300http://uk.download.nvidia.com/XF ... -100.14.23-pkg1.run\n使用wget\n下载nvidia linux驱动\n然后#init 3\n进入到终端模式。\nSh NVIDIA-Linux-x86-100.14.23-pkg1.run安装显卡驱动。\n3.安装compiz\n感谢Gavin,，威豆提供以下的心得分享：\n1)参考文件:\nhttp://www.tuxyturvy.com/blog/in ... on-on-CentOS-5.html\nhttp://www.opendesktop.org.tw/mo ... cle.php?storyid=131\n2)安装必要的rpm包:\nyum install libXdamage kdebase perl-XML-Parser\n3)下载相关套件:\n至下列网站下载下列套件:\nhttp://www.tuxyturvy.com/files/compiz-fusion/\nccsm-0.5.2-0.1.el5.noarch.rpm\ncompiz-0.5.2-0.1.el5.i386.rpm\ncompiz-all-0.5.2-0.1.el5.i386.rpm\ncompiz-bcop-0.5.2-0.1.el5.noarch.rpm\ncompizconfig-python-0.5.2-0.1.el5.i386.rpm\ncompiz-fusion-plugins-extra-0.5.2-0.2.el5.i386.rpm\ncompiz-fusion-plugins-main-0.5.2-0.2.el5.i386.rpm\ncompiz-fusion-plugins-unsupported-0.5.2-0.2.el5.i386.rpm\ncompiz-gnome-0.5.2-0.1.el5.i386.rpm\ncompiz-kde-0.5.2-0.1.el5.i386.rpm\ndbus-qt-0.70-1.el5.i386.rpm\nemerald-0.5.2-0.1git.el5.i386.rpm\nemerald-themes-0.5.2-0.1.el5.noarch.rpm\nfuse-libs-2.7.0-5.fc6.i386.rpm\nfusion-icon-0.1-0.13.20070814git.el5.noarch.rpm\nfusion-icon-all-0.1-0.13.20070814git.el5.noarch.rpm\nfusion-icon-gtk-0.1-0.13.20070814git.el5.noarch.rpm\nfusion-icon-qt-0.1-0.13.20070814git.el5.noarch.rpm\nintltool-0.35.5-3.el5.i386.rpm\nlibcompizconfig-0.5.2-0.1.el5.i386.rpm\nmetacity-2.18.0-2.el5.i386.rpm\n安装compiz-fusion(上逑套件) :\nrpm -Uvh *\n4.更改/etc/X11/xorg.conf配置，使其支持扩展\n在Section &quot;Module&quot;下增加\nLoad &quot;extmod&quot;\n使其支持扩展，在Section &quot;Device&quot;下增加\nOption &quot;NoLogo&quot; &quot;true&quot;\n去掉难看的显卡启动logo.\n        ', null);
INSERT INTO `blog` VALUES ('52', '华佗教你睡觉，一定要看。', '\n            \n \n熬夜是很正常的事,但经常熬夜对身体会产生很坏的影响,无意中看到这篇文章,转载过来,或许对经常熬夜的同行们会有所帮助。\n\n\n　　睡觉的诀窍\n　　根据医学和我的体验、观察，一个人真正睡着觉最多只有两个钟头，其余都是浪费时间，躺在枕头上做梦，没有哪个人不做梦。至于醒来觉得自己没有做梦，那是因为他忘记了。\n　　通常一个人睡两个钟头就够了，为什么有人要睡七、八个钟头?那是你赖床躺在枕头上休息的习惯养成的，并非我们需要那么久的睡眠时间，尤其打坐做功夫的人晓得，正午只要闭眼真正睡着三分钟，等于睡两个钟头，不过要对好正午的时间。夜晚则要在正子时睡着，五分钟等于六个钟头。\n\n就这个时间的学问又大了，同宇宙法则、地球法则、易经阴阳的道理有关系，而且你会感觉到，心脏下面硬是有一股力量降下来，与丹田(肾上)的力量融合，所谓“水火既济”，豁然一下，那你睡眠够了，精神百倍。\n　　所以失眠或真要夜里熬夜的人，正子时的时刻，哪怕二十分钟也一定要睡，睡不着也要训练自己睡着。\n　　过了正子时大约十二点半以后，你不会想睡了，这很糟糕。更严重的，到了天快亮，四、五点钟，五、六点卯时的时候，你又困得想睡，这时如果一睡，一天都会昏头。\n　　所以想从事熬夜工作的人，正子时，即使有天大的事也要摆下来，睡它半小时，到了卯时想睡觉千万不要睡，那一天精神就够了。\n不过失眠的人都挨过十二点，在床上翻来覆去睡不着，结果快天亮睡着了，到第二天下午都昏头昏脑，因此你会感觉失眠、睡眠不足，实际上是你没有经验。\n&nbsp;&nbsp; 睡眠与养生\n\n\n　　一、睡眠的规则\n　　战国时名医文挚对齐威王说：“我的养生之道把睡眠放在头等位置，人和动物只有睡眠才生长，睡眠帮助脾胃消化食物，所以，所以睡眠是养生的第一大补，人一个晚上不睡觉，其损失一百天也难以恢复。”\n　　晚21点到凌晨5点为有效睡眠时间。人是动物，和植物同属于生物，白天(凌晨5点到晚上21点)活动产生能量，晚上(21点到凌晨5点)开始进行细胞分裂，把能量转化为新生的细胞，是人体细胞休养生息、推陈出新的时间，也是人随着地球旋转到背向太阳的一面。阴主静，是人睡眠的良辰，此时休息，才会有良好的身体和精神状态。这和睡觉多的婴儿长得胖、长得快，而爱闹觉的孩子发育不良是一样的道理。\n　　睡觉是养生的一大功能，养就是用大量的健康细胞去取代腐败的细胞，如一夜睡不着就换不了新细胞。如果说白天消亡一百万个细胞，一晚上只补回来五十万个细胞，这时你的身体就会出现亏空，时间长了，人就糠了，像糠萝卜似的。为什么世上有百岁老人呢?因为他们每晚都在21点钟准时睡觉。\n\n　　植物吸收阳光的能量，夜里生长，所以夜晚在农村的庄稼地里可听到拔节的声音。人类和植物同属于生物，细胞分裂的时间段大致相同，错过夜里睡觉的良辰，细胞的新生远赶不上消亡，人就会过早的衰老或患病，人要顺其自然，就应跟着太阳走，即天醒我醒，天睡我睡。人在太阳面前小如微尘，“与太阳对着干”是愚蠢的选择，迟早会被太阳巨大的引力催垮。这是客观真理。\n　　现实生活中，不少人有入睡难，睡眠质量不高的毛病。睡眠不好是一个综合性的问题，如肝火过盛，睡觉警觉;胃火过剩，睡觉不安;肝阴不足，睡觉劳累。\n\n\n　　二、睡眠与疾病\n　　现代的生活习惯和生活方式给人们的身体带来了很多负面影响形成“四大病”：水果病、冰箱病、电视电脑病、熬夜病。肝脏有一特点：卧则回血，坐立向外供血。\n　　子时(23：00—1：00)，其实23点就是新的一天的开始，并不是0点开始的，这是我们犯的误识。肝胆相表里，互为一家，23点胆经开了，如若不睡，大伤胆气，由于十一脏腑皆取决于胆也，胆气一虚，全身脏腑功能下降，代谢力、免疫力纷纷下降，人体机能大大降低，胆气支持中枢神经，胆气受伤易患各种精神疾病，比如抑郁症、精神分裂症、强迫症、躁动症等。子时胆要更换胆汁，胆经渐旺人如不卧，胆汁更替不利，过浓而结晶成石，久之即得胆结石，如果把胆给摘了，一摘就胆怯了，全身的免疫力下降了50%以上，所以不能摘，要用它本系统的巨大潜能把它化掉。\n　　丑时肝经最旺，丑时(1：00—3：00)不眠，肝无法解除掉有毒之物，产生新鲜血液，因藏血不利，面呈青色，久之易患各类肝病，现在有些人肝不太好，特别在欧洲平均4个人就有一个大三阳或是小三阳，大都是因为违反自然规律过了子时不睡觉造成的。甲肝比较好治，乙肝就很难治。乙肝病毒携带者，是由于晚上经常不睡觉，人太虚弱了，也就是说秩序太乱了，病毒已经到了细胞里了。也就是说乙肝的病毒已经到了细胞里面，但是现在它还没有能力造成肝炎，当人身体处于最薄弱的时候就形成成肝炎，乙型肝炎就意味着将来40%——60%的肝硬化。聪明的人是应该了解天、地、人之间的关系，不聪明的人就是应该被淘汰的人。\n\n　　垃圾睡眠给肝脏带来多大伤害？\n　　肝主疏泄，过子时不睡，可引起肝疏泄不利，肝气郁结，可见易怒，头痛头晕，眼红，眼痛，耳鸣，耳聋，胸肋胀痛，女性月经不调，便秘，也可引起肝气升发不足，人会目倦神疲，腰膝酸软，晕眩，失眠，惊悸，精神恍惚，重则会晕倒在大街上，不省人事。\n　　肝有藏血、调节血液的功能，过子时不睡，会造成肝血不足，还会引起吐血、流鼻血、皮下出血、牙龈出血、眼底出血、耳出血等出血证状。\n　　肝开窍于目，过子时不睡，易引起肝虚，则出现视力模糊、老花、夜盲、畏光、迎风流泪，等症状，还会形成青光眼、白内障、眼底动脉硬化、视网膜病变等眼疾。\n　　肝主筋，其华在爪，过子时不睡觉，会引起肝血不足，就出现筋痛，麻木，屈伸困难，痉挛抽搐，易造成灰指甲，缺钙，髌骨软化，癫痫病，骨质疏松等症。\n\n　　肝与心，过子时不睡觉，可引起肝血不足，由于心主一身之血脉，肝有储藏和调节血液的功能，会造成心脏供血不足，引起心慌、心颤等症状，严重的形成心脏病、高血压等心脑血管疾病。\n　　肝与脾，过子时不睡觉，会引起肝胃不和，由于肝助脾胃消化，由于肝气太虚不能助脾胃消化，使人脾胃消化功能不好，表现为舌苔厚，长期以来会造成中气塌陷。\n　　肝与肺，过子时不睡觉，无法滋阴潜阳，肝阴亏损，引起肝火过盛灼肺，出现干咳、或咳嗽、咳痰血等木火刑金的证状，易导致牛皮癣等各种皮肤病。\n　　肝与肾，过子时不睡觉，肝虚导致肾亏，由于肝肾同源，容易造成生殖系统疾病、不育、骨病、牙病、脱发、糖尿病、肾衰竭等疾病。\n\n\n　　三、睡眠的方法\n　　交通规则——你不懂就容易出事故。比如说，23点至凌晨3点为子丑时，胆肝经最活跃的时候，肝胆要回血，“躺下去回血，站起来供血”。如果你每晚22点钟左右躺下，静静得不要说话，到23点的时候，也就睡着了。肝胆开始回血，把有毒的血过滤掉，产生新鲜的血液，到一百岁也没有胆结石，也没有肝炎、囊肿一类的病。如果你天天熬夜到1点多，肝回不了血，有毒的血排不掉，新鲜的血生不成，胆又无法换胆汁，所以这些人容易得胆结石、囊肿、大三阳、小三阳各种病症。\n　　在欧洲地区，平均四个人就有一个肝炎病毒携带者，这就叫不懂规则。睡前半小时最好不要讲话，睡觉的时候更不要说话，如一说话，肺经动，然后心经又动，(因为心肺共为上焦)人就容易进入兴奋状态，所以就很难入睡。\n　　21：00—23：00为亥时。亥时三焦经旺，三焦通百脉。亥时入眠，百脉皆得濡养，故百岁老人得共同特点即21：00(亥时)之前入睡。女性若想长久的保持容颜娇好，应做到早睡早期。\n　　睡觉要关窗，不能开风扇、不能开空调，人生病很多都与此有关，因为人在睡眠之中，气血流通缓慢，体温下降，人体会在表面形成一种阳气层，这种阳气层它使人叫“鬼魅不侵”，什么意思呢，阳气足的人，不做恶梦，就是这种阳气，占了上风。开空调，开风扇，情况就不一样了，开窗户，窗户走的是风，风入的是筋，如果开空调，也有风，风入筋，寒入骨，早上起来，身上发黄，脸发黄，脖子后面那条筋发硬，骨节酸痛，甚至有人就开始发烧，这就是风和寒侵入到了筋和骨头里的缘故，这也就是气受伤了。如果说晚上睡觉不开窗，不开空调，不开风扇，连房门也关上，效果最好，如果热，把房门打开，把窗户关上，效果就差了一点，但是他不至于第二天早上起来浑身乏力，后背僵硬.\n　　有人把客厅的空调开开了，把卧室的门打开，和直接开空调睡觉是差不多的，开了空调以后，空调那个寒进了骨了，所以心里发冷，心在哪，心在脑髓，脑为髓之海，骨髓里有寒，那肯定心里就寒了，怎么办，补肾阳、补中气，什么时候补到心里不冷，烧就退了，寒走出去了。\n\n\n　　睡觉要尽量早睡，睡得晚，伤了少阳之气，必然第二天是疲倦无力，要关上窗户，不开空调、电扇，保护阳气。\n　　肝胆在下焦，如果胃出现问题的时候，他就会出现寝睡不安，一个是胃寒，如果这个人胃阳本来就不足，过多的喝绿茶，就会出现胃寒，胃寒的时候人是睡不好觉的，或者吃带泥沙之物过多，胃隐隐作寒，肯定是睡不好;\n　　再一个是胃热，就是热气往上走，嘴里喘的都是热气，像这种情况也睡不好觉;再一个是胃燥，口干舌燥，胃里感觉到燥;\n　　还有一个就是胃厚，气味的味，胃厚，这种情况就是吃了这种厚腻的味道，有人吃海鲜、吃鱼、吃炖鸡，味道好鲜美，吃多了，美味不可多用，这些东西在里面要稀释它，不稀释它，它在里面味太厚了，所以这个也睡不好觉;\n　　再一个腹涨，腹是涨鼓鼓的，也睡不着，翻来覆去也睡不着;再一个是胃气太虚，冒冷汗，这也睡不好觉，这些原因都可能形成胃不宁，胃不宁就睡不好。\n　　睡觉时要肢暖，四肢要暖，因为四肢是阳之本，这个大家都知道了，四肢不暖，肯定是肾阳不足，应该在睡觉之前把手脚捂暖，手脚和肚脐、背后的命门都要盖好。\n\n\n　　睡眠法因人而异，下面介绍3种做法：\n\n　　1、睡觉前简单的压腿，然后在床上自然盘坐，两手重叠放于腿上，自然呼吸，感觉全身毛孔随呼吸一张一合，若能流泪打哈欠效果最佳，到了想睡觉时倒下便睡。\n　　2、仰卧，自然呼吸，感觉呼吸像春风，先融化大脚趾，然后是其他脚趾，接着脚、小腿、大腿逐渐融化。如还未醒着，再从头做。\n　　3、入睡快的人可右侧卧，右手掌托右耳。右掌心为火，耳为水，二者形成水火即济，在人体中形成心肾相交。久之，养心滋肾。\n　　睡眠一定要早起，即使在冬天，也不可超过6点起床，春夏秋季尽量在5点之前起床，因为人在寅时(3点—5点)肺经旺的时候起床，能够使肺气得以舒展，以顺应阳气的舒长，来完成新陈代谢，肃降浊气，使肺气清，这样有助于养肺和顺应太阳的天势升起人体阳气，使人一天阳气充足，否则，就好像发动机，过了这段好时机就很难发动人体阳气，人体阳气淤积在人体下部不能由命门向上发动升起，会形成淫气，严重损害人的身心健康。\n\n　　早晨5点至7点是人体大肠经最旺的时候，人体需要把代谢的浊物排出体外，此时如果不起床，大肠得不到充分活动，无法很好的完成排浊功能，使浊物停留而形成毒素，危害人体血液和脏腑百骸。早晨7点到9点人体胃经最旺，9点到11点人体脾经最旺，这时人的消化吸收运化的能力最好，如果这时还不起床，人体胃酸会严重腐蚀胃粘膜，人体在最佳吸收营养时间得不到营养，长期以来会患脾胃疾病，造成营养不良、中气塌陷。所以千万不要赖床，赖床会造成头昏、疲惫不堪、睡眠不足的感觉，而应按时起床，历史上许多伟人都是有三四点钟起床的习惯，比如华盛顿、拿破仑、康熙皇帝、曾国藩等。另外早起能增加工作效益，俗话说：“三天早起，一天工”。\n　　现代医学证明，早睡早起的人精神压力较小，不易患精神类疾病。早晨不要太早出去锻炼，因为早晨在太阳没有出来之前，地下道的漳气、浊气正往上走(尤其是城市)，这些气对人体损伤是很严重的。\n　　养身三大事，一睡眠，二便利，三饮食，其余起居、服装等皆是辅助。\n　　三事中睡眠第一。然胃纳不和者，夜眠不安，故以通便利为第二。而饮食无节，饥饱过度者，肠胃必受伤，而营养日减。睡以安神为主，神以心安为主，应配合年龄，壮年至多七小时至八小时，多睡则智昏头晕眼红胀，四肢疲软，童年必睡足八小时，或过九小时勿碍，老或病人至多六小时已足。\n\n\n　　睡眠中不可忽视的疾病警告\n　　应注意：\n　　(一)睡眠宜早，勿过十时，老年人以八点为正，勿过九点。凡交十一时，为阳生时，属肾，此时失眠，肾水必亏，心肾相连，水亏则火旺，最易伤神。千万勿以安眠药片助睡。\n　　(二)枕上切忌思索计算未来事，睡时宜一切不思，鼻息调匀，自己静听其气，由粗而细，由细而微细而息。视此身如无物，或如糖入于水，化为乌有，自然睡着。\n　　(三)如有思想，不能安着，切勿在枕上转侧思虑，此最耗神，可坐起一时再睡。\n　　(四)如在午时，即上午十一点至一点，为阴生之时，属心，此时如不能睡，可静坐一刻钟，闭目养神，则心气强。凡有心脏病者切宜注意，每日于此二时注意，则元气日强，无心跳腹泄或小便频速之病。\n　　(五)夏日起宜早，冬日起宜迟。居北方宜防寒气，如在粤桂等省，早起防山岚瘴气中病。食后勿仰天睡，早起如在寅时三点至五点，此时切忌郁怒，必损肺伤肝，万望注意。\n\n\n\n        ', null);
INSERT INTO `blog` VALUES ('53', '画的好，写得也好，关于上班族。。。', '\n            \n \n\n作为一名上班族，每天我们都会碰到很多很多的事儿以及很多很多的突发状况，下面这组漫画就分享给所有上班族朋友们。来自蛋包仔的《上班那些事儿》，这些事儿你是不是也经常遇到呢？\n&nbsp;\n&gt; /&gt; /&gt; /&gt; /&gt; /&gt; /&gt;&nbsp;&gt;\n&nbsp;\n\n&nbsp;\n每天早晨，都是无尽的挣扎\n&nbsp;\n\n&nbsp;\n每个月总有那么几天，是这种状况……\n&nbsp;\n\n&nbsp;\n挤公车，挤地铁，挤电梯…….\n&nbsp;\n\n&nbsp;\n每次看到这种坐电梯只上下一层的人，都有一种想把他干掉的冲动\n&nbsp;\n\n&nbsp;\n有时候简单干脆直入主题往往比很多海阔天空\n&nbsp;\n\n&nbsp;\n如果不合群的话……\n&nbsp;\n\n&nbsp;\n办公室内外，冰火两重天\n&nbsp;\n\n&nbsp;\n还记得每次工作要完成时断电的那一刻么？\n&nbsp;\n\n&nbsp;\n等啊～盼啊～～\n&nbsp;\n\n&nbsp;\n每天开会，千姿百态\n&nbsp;\n\n&nbsp;\n公司7类人，请同学们对号入座～\n&nbsp;\n\n&nbsp;\n周六去上班的人请无视\n&nbsp;\n\n&nbsp;\n以上欲望仅代表个人观点\n&nbsp;\n\n&nbsp;\n在饿不死的前提下，我更注重精神食粮\n&nbsp;\n\n&nbsp;\n最后，请记住，永远不要让理想，只成为一个理想！\n\n        ', null);
INSERT INTO `blog` VALUES ('54', 'Linux下安装Java JDK及Eclipse步骤总结', '\n            Linux下安装JDK及系统环境变量设置\n\n1.去官网下载jdk1.6.0_31.bin 包\n2.放入/usr/local/目录下，用chmod a+x ./jdk1.6.0_31.bin 将其转为可执行文件 ，然后执行./jdk1.6.0_31.bin命令安装\n3.修改 &nbsp;/etc/profile文件来添加系统环境变量 &nbsp;vim /etc/profile，在文件尾部添加下列环境变量值\n &nbsp;&nbsp;&nbsp;export JAVA_HOME=/usr/local/jdk1.6.0_31/\n &nbsp;&nbsp;&nbsp;export PATH=$JAVA_HOME/bin:$PATH\n &nbsp;&nbsp;&nbsp;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n &nbsp;&nbsp;&nbsp;export JAVA_HOME\n &nbsp;&nbsp;&nbsp;export PATH\n &nbsp;&nbsp;&nbsp;export CLASSPATH\n5.保存后执行 source /etc/profile 完成环境变量的添加，输入java 及javac测试系统环境变量的安装\n&nbsp;\nLinux下安装Eclipse\n\n1.在官网http://www.eclipse.org下载Eclispe-indigo版本的Linux版本 &nbsp;eclipse-jee-indigo-SR2-linux-gtk.tar.gz \n2.使用tar -zxvf eclipse-jee-indigo-SR2-linux-gtk.tar.gz -C /usr/local/ &nbsp;&nbsp;&nbsp;解压到/usr/local/目录下 \n3.双击运行eclipse即可启动eclipse\n（注意：如报Failed to load the JNI shared library&quot;/usr/local/jdk1.6.0_31/bin/../jre/lib/i386/client/libjvm.so&quot;.这个错误，可编辑/etc/sysconfig/selinux文件，修改SELINUX=disable保存，重启系统即可）\n        ', null);
INSERT INTO `blog` VALUES ('55', '使用yum来安装或卸载CentOS图形界面包', '\n            之前安装公司服务器的时候，默认安装了图形界面，第二天公司工程师跟我说不能安装图形界面，需要把服务器全部重装，之后一直有疑问，安装了图形界面就不能卸载掉吗？因为在linux里面，图形界面只是一个软件包的形式，并不是核心，今天看书的时候想起这个问题，在网上找资料，发现网上一个简单的办法，直接用yum的方式安装或卸载！ 命令行模式安装图形界面yum grouplist 检查已安装的组yum groupinstall &quot;X Window System&quot;yum groupinstall &quot;GNOME Desktop Environment&quot;startx或者init 5就OK。重新安装了带图形界面模式的centos系统，来实验yum方式卸载图形界面图形界面想要卸载：yum groupremove &quot;GNOME Desktop Environment&quot;yum groupremove &quot;X Window System&quot; 以图形界面安装的linux 卸载图形界面之后会提示错误init: Id &quot;x&quot; respawning too fast: disabled for 5 minutes解决的办法是vi /etc/inittab找到这段文字 把这段文字中id后面的数字改为3 id:3:initdefault 让系统以文本界面启动找到这段文字x:5:respawn:/etc/X11/prefdm -nodaemon注释掉！\n注（此方法未证实能否保证服务器保持稳定！未在服务器上线实验过）\n\n        ', null);
INSERT INTO `blog` VALUES ('56', '面向对象的思维方法', '\n            面向对象的思维方法 作者：范凯E-mail: robbin_fan@yahoo.com.cn我是从学习Java编程开始接触OOP(面向对象编程)，刚开始使用Java编写程序的时候感觉很别扭，因为我早以习惯用C来编写程序，很欣赏C的简洁性和高效性，喜欢C简练而表达能力丰富的风格，特别忍受不了Java运行起来慢吞吞的速度，相对冗长的代码，而且一个很简单的事情，要写好多类，一个类调用一个类，心里的抵触情绪很强。我对Java的面向对象的特性琢磨良久，自认为有所领悟，也开始有意识的运用OOP风格来写程序，然而还是经常会觉得不知道应该怎样提炼类，面对一个具体的问题的时候，会觉得脑子里千头万绪的，不知道怎么下手，一不小心，又会回到原来的思路上去。举个例子，要发广告邮件，广告邮件列表存在数据库里面。倘若用C来写的话，一般会这样思考，先把邮件内容读入，然后连接数据库，循环取邮件地址，调用本机的qmail的sendmail命令发送。然后考虑用Java来实现，既然是OOP，就不能什么代码都塞到main过程里面，于是就设计了三个类：一个类是负责读取数据库，取邮件地址，调用qmail的sendmail命令发送；一个类是读邮件内容，MIME编码成HTML格式的，再加上邮件头；一个主类负责从命令读参数，处理命令行参数，调用发email的类。把一件工作按照功能划分为3个模块分别处理，每个类完成一件模块任务。仔细的分析一下，就会发现这样的设计完全是从程序员实现程序功能的角度来设计的，或者说，设计类的时候，是自低向上的，从机器的角度到现实世界的角度来分析问题的。因此在设计的时候，就已经把程序编程实现的细节都考虑进去了，企图从底层实现程序这样的出发点来达到满足现实世界的软件需求的目标。这样的分析方法其实是不适用于Java这样面向对象的编程语言，因为，如果改用C语言，封装两个C函数，都会比Java实现起来轻松的多，逻辑上也清楚的多。我觉得面向对象的精髓在于考虑问题的思路是从现实世界的人类思维习惯出发的，只要领会了这一点，就领会了面向对象的思维方法。举一个非常简单的例子：假使现在需要写一个网页计数器，客户访问一次页面，网页计数器加1，计数器是这样来访问的http://hostname/count.cgi?id=xxx后台有一个数据库表，保存每个id（一个id对应一个被统计访问次数的页面）的计数器当前值，请求页面一次，对应id的计数器的字段加1(这里我们忽略并发更新数据库表，出现的表锁定的问题)。如果按照一般从程序实现的角度来分析，我们会这样考虑：首先是从HTTP GET请求取到id，然后按照id查数据库表，获得某id对应的访问计数值，然后加1，更新数据库，最后向页面显示访问计数。现在假设一个没有程序设计经验的人，他会怎样来思考这个问题的呢？他会提出什么样的需求呢？他很可能会这样想：我需要有一个计数器，这个计数器应该有这样的功能，刷新一次页面，访问量就会加1，另外最好还有一个计数器清0的功能，当然计数器如果有一个可以设为任意值的功能的话，我就可以作弊了。做为一个没有程序设计经验的人来说，他完全不会想到对数据库应该如何操作，对于HTTP变量该如何传递，他考虑问题的角度就是我有什么需求，我的业务逻辑是什么，软件应该有什么功能。按照这样的思路(请注意，他的思路其实就是我们平时在生活中习惯的思维方式)，我们知道需要有一个计数器类 Counter，有一个必须的和两个可选的方法：getCount() &nbsp;// 取计数器值方法resetCounter() &nbsp;// 计数器清0方法setCount() &nbsp;// 设计数器为相应的值方法把Counter类完整的定义如下：public class Counter { &nbsp;public int getCount(int id) {} &nbsp;public void resetCounter(int id) {} &nbsp;public void setCount(int id, int currentCount) {}}解决问题的框架已经有了，来看一下如何使用Counter。 在count.cgi里面调用Counter来计数，程序片断如下： &nbsp;// &nbsp;这里从HTTP环境里面取id值 &nbsp;... &nbsp;Counter myCounter = new Counter(); &nbsp;// 获得计数器 &nbsp;int currentCount = myCounter.getCount(id); &nbsp;// 从计数器中取计数 &nbsp;// &nbsp;这里向客户浏览器输出 &nbsp;...程序的框架全都写好了，剩下的就是实现Counter类方法里面具体的代码了，此时才去考虑具体的程序语言实现的细节，比如，在getCount()方法里面访问数据库，更新计数值。从上面的例子中看到，面向对象的思维方法其实就是我们在现实生活中习惯的思维方式，是从人类考虑问题的角度出发，把人类解决问题的思维方式逐步翻译成程序能够理解的思维方式的过程，在这个翻译的过程中，软件也就逐步被设计好了。在运用面向对象的思维方法进行软件设计的过程中，最容易犯的错误就是开始分析的时候，就想到了程序代码实现的细节，因此封装的类完全是基于程序实现逻辑，而不是基于解决问题的业务逻辑。学习JDBC编程的经典错误问法是：“我怎样封装对数据库的select操作？”面向对象的设计是基于解决业务问题的设计，而不是基于具体编程技术的设计。我不会去封装select语句的，我只封装解决问题的业务逻辑，对数据库的读取是在业务逻辑的编码实现阶段才去考虑的问题。回过头看上面那个发广告邮件的例子，应该如何应用面向对象的思维方法呢？对于一个邮件来说，有邮件头，邮件体，和邮件地址这三个属性，发送邮件，需要一个发送的方法，另外还需要一个能把所有邮件地址列出来的方法。所以应该如下设计：类JunkMail属性： &nbsp;head &nbsp;body &nbsp;address方法： &nbsp;sendMail() &nbsp;&nbsp;&nbsp;// 发送邮件 &nbsp;listAllMail() // 列邮件地址用Java来表示：public class JunkMail { &nbsp;private String head; &nbsp;private String body; &nbsp;private String address; &nbsp;public JunkMain() { &nbsp;// 默认的类构造器 &nbsp;&nbsp;&nbsp;// 从外部配置文件读邮件头和邮件体 &nbsp;&nbsp;&nbsp;this.head=...; &nbsp;&nbsp;&nbsp;this.body=...; &nbsp;} &nbsp;public static boolean sendMail(String address) { &nbsp;&nbsp;&nbsp;// &nbsp;调用qmail，发送email &nbsp;} &nbsp;public static Collection listAllMail() { &nbsp;&nbsp;&nbsp;// &nbsp;访问数据库，返回一个邮件地址集合 &nbsp;}}当把JunkMail设计好了以后，再调用JunkMail类完成邮件的发送，将是非常轻松的事情。如果说传统的面向过程的编程是符合机器运行指令的流程的话，那么面向对象的思维方法就是符合现实生活中人类解决问题的思维过程。在面向对象的软件分析和设计的时候，要提醒自己，不要一上来就去想程序代码的实现，应该抛开具体编程语言的束缚，集中精力分析我们要实现的软件的业务逻辑，分析软件的业务流程，思考应该如何去描述和实现软件的业务。毕竟软件只是一个载体，业务才是我们真正要实现的目标。但是在设计过程中，心里却往往在担心，如果我完全不去考虑程序代码的实现的话，那么我怎么知道我的设计一定合理呢？我怎么知道我设计的类、接口一定可以实现呢？（是个问题：（）所以经常可以看到的现象就是：在设计过程中，虽然知道不能过早考虑代码实现，但是每设计一个类，一个接口，心里都要不知不觉的用自己熟悉的编程语言大概的评估一下，看看能否编出来，因此，一不小心，就会又回到按照程序功能实现的思路进行设计的老路上去了。举个例子来说明，在做Web程序设计的时候，经常要遇到分页显示数据的情况。比如说需要把系统中所有的用户都列出来这样的功能。假设使用User类来表示用户，增加用户addUser()，删除用户deleteUser()，查询所有用户listUsers()方法。而数据库中有一个user表，一条记录是一个用户的信息。下面考虑一下User类的方法的实现：addUser()和deleteUser()方法都好实现，就是对数据库增加记录和删除记录。对于listUsers()方法，其实就是对user表的select，取出一个记录集。但是该怎么从listUsers()方法中得到所有用户的列表呢？一个方法调用的返回值只有一个，没有多个，所以很多情况下采用的办法就是返回值定义为集合类型，比如Vector。这样就可以在listUsers()方法的具体代码实现的时候，从数据库依次取出一个个记录，插入到Vector里面来。在主程序里面，调用listUsers()方法可以返回一个Vector，然后再对Vector遍历操作，就可以得到用户列表了。public class User { &nbsp;public static void addUser(...) { &nbsp;&nbsp;&nbsp;// &nbsp;数据库insert一条记录 &nbsp;} &nbsp;public static void deleteUser(...) { &nbsp;&nbsp;&nbsp;// &nbsp;数据库delete一条记录 &nbsp;} &nbsp;public Vector listUsers(...) { &nbsp;&nbsp;&nbsp;// &nbsp;数据库select结果放到一个集合里面 &nbsp;}}这样的设计基本合理，但是仍然有点小问题。因为在设计的时候，就考虑到了用Java的集合类Vector来实现对不定长数据集的存放，因而违反了面向对象设计的一个原则：在设计的时候不应过早的考虑具体程序语言的实现。所以必须用抽象的方法，和具体实现无关的方法来表达业务逻辑。我们知道，通常对具有集合特征的数据结构进行遍历通常可以使用next和hasNext方法，next实现取下一个用户，hasNext判断是否还有元素。 因此我们定义一个接口Iterator，这个接口中定义两个方法next和hasNext：public interface Iterator { &nbsp;public boolean hasNext() {} &nbsp;public Object next() &nbsp;{}}而User类的listUses方法返回值改为Iterator接口的实现类:public class User { &nbsp;... &nbsp;public Iterator listUsers() { &nbsp;} &nbsp;...}这样就把User类的设计和具体的实现方法分离开了，因为此时任何实现了next()和hasNext()方法的类都可以做为listUsers的返回值，都可以被用来表达“用户列表”，而不仅仅可以使用Vector而已。比如，我可以用ArrayList来表达用户列表，因为ArrayList也实现了Iterator，当然我也可以自己专门写一个类来存放用户列表，只要实现next()和hasNext()方法就行了。这样在具体的编写代码的时候，程序员具有了最大的灵活性，可以根据具体的情况，采用不同的编程方法来存放用户列表。特别是降低了程序的耦合度，提高了程序的可移植性。对于上面那个JunkMail的listAllMail()方法也同样应该改为接口类型。然后，在主程序里面就这样来使用User类的listUsers方法：User myUser = new User();Iterator iterator = myUser.listUsers();while (iterator.hasNext()) { &nbsp;iterator.next();}这样就可以完全不用考虑程序代码实现了，从高层次上把功能抽象出来，定义成为接口，同时又可以把系统设计的很合理，完全根据业务的需求来进行设计。结语通过上面的几个例子的设计说明，使用面向对象的思维方法，其实是一个把业务逻辑从具体的编程技术当中抽象出来的过程，而这个抽象的过程是自上而下的，非常符合人类的思维习惯，也就是先不考虑问题解决的细节，把问题的最主要的方面抽象成为一个简单的框架，集中精力思考如何解决主要矛盾，然后在解决问题的过程中，再把问题的细节分割成一个一个小问题，再专门去解决细节问题。因而一旦牢牢的抓住了这一点，你就会发现在软件设计和开发过程中，你自己总是会不知不觉的运用面向对象的思维方法来设计和编写程序，并且程序的设计和开发也变得不再那么枯燥，而一个合理运用面向对象技术进行设计和架构的软件，更是具备了思维的艺术美感。最后，愿面向对象的思维方法也能给您的程序设计之路带来创作的乐趣。\n        ', null);
INSERT INTO `blog` VALUES ('57', 'Java程序员成长之路（你必须知道的10个面向对象设计原则）', '\n            福缘彬:\n\n Android Developer:\n \n  面向对象设计原则是OOPS（Object-Oriented Programming System，面向对象的程序设计系统）编程的核心，但大多数Java程序员追逐像Singleton、Decorator、Observer这样的设计模式，而不重视面向对象的分析和设计。甚至还有经验丰富的Java程序员没有听说过OOPS和SOLID设计原则，他们根本不知道设计原则的好处，也不知道如何依照这些原则来进行编程。\n  众所周知，Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计。查看Apache和Sun的开放源代码能帮助你发现其他Java设计原则在这些代码中的实际运用。Java Development Kit则遵循以下模式：BorderFactory类中的工厂模式、Runtime类中的单件模式。你可以通过Joshua Bloch的《Effective Java》一书来了解更多信息。我个人偏向的另一种面向对象的设计模式是Kathy Sierra的Head First Design Pattern以及Head First Object Oriented Analysis and Design。\n  虽然实际案例是学习设计原则或模式的最佳途径，但通过本文的介绍，没有接触过这些原则或还在学习阶段的Java程序员也能够了解这10个面向对象的设计原则。其实每条原则都需要大量的篇幅才能讲清楚，但我会尽力做到言简意赅。\n  原则1：DRY（Don\'t repeat yourself）\n  即不要写重复的代码，而是用“abstraction”类来抽象公有的东西。如果你需要多次用到一个硬编码值，那么可以设为公共常量；如果你要在两个以上的地方使用一个代码块，那么可以将它设为一个独立的方法。SOLID设计原则的优点是易于维护，但要注意，不要滥用，duplicate 不是针对代码，而是针对功能。这意味着，即使用公共代码来验证OrderID和SSN，二者也不会是相同的。使用公共代码来实现两个不同的功能，其实就是近似地把这两个功能永远捆绑到了一起，如果OrderID改变了其格式，SSN验证代码也会中断。因此要慎用这种组合，不要随意捆绑类似但不相关的功能。\n  原则2：封装变化\n  在软件领域中唯一不变的就是“Change”，因此封装你认为或猜测未来将发生变化的代码。OOPS设计模式的优点在于易于测试和维护封装的代码。如果你使用Java编码，可以默认私有化变量和方法，并逐步增加访问权限，比如从private到protected和not public。有几种Java设计模式也使用封装，比如Factory设计模式是封装“对象创建”，其灵活性使得之后引进新代码不会对现有的代码造成影响。\n  原则3：开闭原则\n  即对扩展开放，对修改关闭。这是另一种非常棒的设计原则，可以防止其他人更改已经测试好的代码。理论上，可以在不修改原有的模块的基础上，扩展功能。这也是开闭原则的宗旨。\n  原则4：单一职责原则\n  类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。\n  原则5：依赖注入或倒置原则\n  这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。\n  原则6：优先利用组合而非继承\n  如果可能的话，优先利用组合而不是继承。一些人可能会质疑，但我发现，组合比继承灵活得多。组合允许在运行期间通过设置类的属性来改变类的行为，也可以通过使用接口来组合一个类，它提供了更高的灵活性，并可以随时实现。《Effective Java》也推荐此原则。\n  原则7：里氏代换原则（LSP）\n  根据该原则，子类必须能够替换掉它们的基类，也就是说使用基类的方法或函数能够顺利地引用子类对象。LSP原则与单一职责原则和接口分离原则密切相关，如果一个类比子类具备更多功能，很有可能某些功能会失效，这就违反了LSP原则。为了遵循该设计原则，派生类或子类必须增强功能。\n  原则8：接口分离原则\n  采用多个与特定客户类有关的接口比采用一个通用的涵盖多个业务方法的接口要好。设计接口很棘手，因为一旦释放接口，你就无法在不中断执行的情况下改变它。在Java中，该原则的另一个优势在于，在任何类使用接口之前，接口不利于实现所有的方法，所以单一的功能意味着更少的实现方法。\n  原则9：针对接口编程，而不是针对实现编程\n  该原则可以使代码更加灵活，以便可以在任何接口实现中使用。因此，在Java中最好使用变量接口类型、方法返回类型、方法参数类型等。《Effective Java》 和《head first design pattern》书中也有提到。\n  原则10：委托原则\n  该原则最典型的例子是Java中的equals() 和 hashCode() 方法。为了平等地比较两个对象，我们用类本身而不是客户端类来做比较。这个设计原则的好处是没有重复的代码，而且很容易对其进行修改。\n  总之，希望这些面向对象的设计原则能帮助你写出更灵活更好的代码。理论是第一步，更重要的是需要开发者在实践中去运用和体会。\n  译文出自：ITeye\n  英文出自：javarevisited（无法直接访问）\n \n\n        ', null);
INSERT INTO `blog` VALUES ('58', 'Java异常处理', '\n            六种异常处理的陋习\n你觉得自己是一个Java专家吗？是否肯定自己已经全面掌握了Java的异常处理机制？在下面这段代码中，你能够迅速找出异常处理的六个问题吗？ \n1 OutputStreamWriter out = ... 2 java.sql.Connection conn = ... 3 try { // ⑸ 4 Statement stat = conn.createStatement(); 5 ResultSet rs = stat.executeQuery( 6 &quot;select uid, name from user&quot;); 7 while (rs.next()) 8 { 9 out.println(&quot;ID：&quot; + rs.getString(&quot;uid&quot;) // ⑹ 10 &quot;，姓名：&quot; + rs.getString(&quot;name&quot;)); 11 } 12 conn.close(); // ⑶ 13 out.close(); 14 } 15 catch(Exception ex) // ⑵ 16 { 17 ex.printStackTrace(); //⑴，⑷ 18 }\n\n 作为一个Java程序员，你至少应该能够找出两个问题。但是，如果你不能找出全部六个问题，请继续阅读本文。  本文讨论的不是Java异常处理的一般性原则，因为这些原则已经被大多数人熟知。我们要做的是分析各种可称为“反例”（anti-pattern）的违背优秀编码规范的常见坏习惯，帮助读者熟悉这些典型的反面例子，从而能够在实际工作中敏锐地察觉和避免这些问题。  反例之一：丢弃异常  代码：15行-18行。  这段代码捕获了异常却不作任何处理，可以算得上Java编程中的杀手。从问题出现的频繁程度和祸害程度来看，它也许可以和C/C++程序的一个恶名远播的问题相提并论??不检查缓冲区是否已满。如果你看到了这种丢弃（而不是抛出）异常的情况，可以百分之九十九地肯定代码存在问题（在极少数情况下，这段代码有存在的理由，但最好加上完整的注释，以免引起别人误解）。  这段代码的错误在于，异常（几乎）总是意味着某些事情不对劲了，或者说至少发生了某些不寻常的事情，我们不应该对程序发出的求救信号保持沉默和无动于衷。调用一下printStackTrace算不上“处理异常”。不错，调用printStackTrace对调试程序有帮助，但程序调试阶段结束之后，printStackTrace就不应再在异常处理模块中担负主要责任了。  丢弃异常的情形非常普遍。打开JDK的ThreadDeath类的文档，可以看到下面这段说明：“特别地，虽然出现ThreadDeath是一种‘正常的情形’，但ThreadDeath类是Error而不是Exception的子类，因为许多应用会捕获所有的Exception然后丢弃它不再理睬。”这段话的意思是，虽然ThreadDeath代表的是一种普通的问题，但鉴于许多应用会试图捕获所有异常然后不予以适当的处理，所以JDK把ThreadDeath定义成了Error的子类，因为Error类代表的是一般的应用不应该去捕获的严重问题。可见，丢弃异常这一坏习惯是如此常见，它甚至已经影响到了Java本身的设计。  那么，应该怎样改正呢？主要有四个选择：  1、处理异常。针对该异常采取一些行动，例如修正问题、提醒某个人或进行其他一些处理，要根据具体的情形确定应该采取的动作。再次说明，调用printStackTrace算不上已经“处理好了异常”。  2、重新抛出异常。处理异常的代码在分析异常之后，认为自己不能处理它，重新抛出异常也不失为一种选择。  3、把该异常转换成另一种异常。大多数情况下，这是指把一个低级的异常转换成应用级的异常（其含义更容易被用户了解的异常）。  4、不要捕获异常。  结论一：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。  反例之二：不指定具体的异常  代码：15行。  许多时候人们会被这样一种“美妙的”想法吸引：用一个catch语句捕获所有的异常。最常见的情形就是使用catch(Exception ex)语句。但实际上，在绝大多数情况下，这种做法不值得提倡。为什么呢？  要理解其原因，我们必须回顾一下catch语句的用途。catch语句表示我们预期会出现某种异常，而且希望能够处理该异常。异常类的作用就是告诉Java编译器我们想要处理的是哪一种异常。由于绝大多数异常都直接或间接从java.lang.Exception派生，catch(Exception ex)就相当于说我们想要处理几乎所有的异常。  再来看看前面的代码例子。我们真正想要捕获的异常是什么呢？最明显的一个是SQLException，这是JDBC操作中常见的异常。另一个可能的异常是IOException，因为它要操作OutputStreamWriter。显然，在同一个catch块中处理这两种截然不同的异常是不合适的。如果用两个catch块分别捕获SQLException和IOException就要好多了。这就是说，catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。  另一方面，除了这两个特定的异常，还有其他许多异常也可能出现。例如，如果由于某种原因，executeQuery返回了null，该怎么办？答案是让它们继续抛出，即不必捕获也不必处理。实际上，我们不能也不应该去捕获可能出现的所有异常，程序的其他地方还有捕获异常的机会??直至最后由JVM处理。 结论二：在catch语句中尽可能指定具体的异常类型，必要时使用多个catch。不要试图处理所有可能出现的异常。  反例之三：占用资源不释放  代码：3行-14行。  异常改变了程序正常的执行流程。这个道理虽然简单，却常常被人们忽视。如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，也要正确释放占用的资源。为此，Java提供了一个简化这类操作的关键词finally。  finally是样好东西：不管是否出现了异常，Finally保证在try/catch/finally块结束之前，执行清理任务的代码总是有机会执行。遗憾的是有些人却不习惯使用finally。  当然，编写finally块应当多加小心，特别是要注意在finally块之内抛出的异常??这是执行清理任务的最后机会，尽量不要再有难以处理的错误。  结论三：保证所有资源都被正确释放。充分运用finally关键词。\n反例之四：不说明异常的详细信息  代码：3行-18行。  仔细观察这段代码：如果循环内部出现了异常，会发生什么事情？我们可以得到足够的信息判断循环内部出错的原因吗？不能。我们只能知道当前正在处理的类发生了某种错误，但却不能获得任何信息判断导致当前错误的原因。  printStackTrace的堆栈跟踪功能显示出程序运行到当前类的执行流程，但只提供了一些最基本的信息，未能说明实际导致错误的原因，同时也不易解读。  因此，在出现异常时，最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。  结论四：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。  反例之五：过于庞大的try块  代码：3行-14行。  经常可以看到有人把大量的代码放入单个try块，实际上这不是好习惯。这种现象之所以常见，原因就在于有些人图省事，不愿花时间分析一大块代码中哪几行代码会抛出异常、异常的具体类型是什么。把大量的语句装入单个巨大的try块就象是出门旅游时把所有日常用品塞入一个大箱子，虽然东西是带上了，但要找出来可不容易。  一些新手常常把大量的代码放入单个try块，然后再在catch语句中声明Exception，而不是分离各个可能出现异常的段落并分别捕获其异常。这种做法为分析程序抛出异常的原因带来了困难，因为一大段代码中有太多的地方可能抛出Exception。  结论五：尽量减小try块的体积。  反例之六：输出数据不完整  代码：7行-11行。  不完整的数据是Java程序的隐形杀手。仔细观察这段代码，考虑一下如果循环的中间抛出了异常，会发生什么事情。循环的执行当然是要被打断的，其次，catch块会执行??就这些，再也没有其他动作了。已经输出的数据怎么办？使用这些数据的人或设备将收到一份不完整的（因而也是错误的）数据，却得不到任何有关这份数据是否完整的提示。对于有些系统来说，数据不完整可能比系统停止运行带来更大的损失。  较为理想的处置办法是向输出设备写一些信息，声明数据的不完整性；另一种可能有效的办法是，先缓冲要输出的数据，准备好全部数据之后再一次性输出。  结论六：全面考虑可能出现的异常以及这些异常对执行流程的影响。  改写后的代码  根据上面的讨论，下面给出改写后的代码。也许有人会说它稍微有点?嗦，但是它有了比较完备的异常处理机制。 \nOutputStreamWriter out = ... java.sql.Connection conn = ... try {  Statement stat = conn.createStatement();  ResultSet rs = stat.executeQuery(  &quot;select uid, name from user&quot;);  while (rs.next())  {  out.println(&quot;ID：&quot; + rs.getString(&quot;uid&quot;) + &quot;，姓名: &quot; + rs.getString(&quot;name&quot;));  } } catch(SQLException sqlex) {  out.println(&quot;警告：数据不完整&quot;);  throw new ApplicationException(&quot;读取数据时出现SQL错误&quot;, sqlex); } catch(IOException ioex) {  throw new ApplicationException(&quot;写入数据时出现IO错误&quot;, ioex); } finally {  if (conn != null) {  try {  conn.close();  }  catch(SQLException sqlex2)  {  System.err(this.getClass().getName() + &quot;.mymethod - 不能关闭数据库连接: &quot; + sqlex2.toString());  }  }  if (out != null) {  try {  out.close();  }  catch(IOException ioex2)  {  System.err(this.getClass().getName() + &quot;.mymethod - 不能关闭输出文件&quot; + ioex2.toString());  }  } }\n\n\n 本文的结论不是放之四海皆准的教条，有时常识和经验才是最好的老师。如果你对自己的做法没有百分之百的信心，务必加上详细、全面的注释。  另一方面，不要笑话这些错误，不妨问问你自己是否真地彻底摆脱了这些坏习惯。即使最有经验的程序员偶尔也会误入歧途，原因很简单，因为它们确确实实带来了“方便”。所有这些反例都可以看作Java编程世界的恶魔，它们美丽动人，无孔不入，时刻诱惑着你。也许有人会认为这些都属于鸡皮蒜毛的小事，不足挂齿，但请记住：勿以恶小而为之，勿以善小而不为。------------------------------------------------------------------下面是一些java异常集-------------------------------------------------------------------------------------------\n\n\n算术异常类：ArithmeticExecption\n空指针异常类：NullPointerException\n类型强制转换异常：ClassCastException\n数组负下标异常：NegativeArrayException\n数组下标越界异常：ArrayIndexOutOfBoundsException\n违背安全原则异常：SecturityException\n文件已结束异常：EOFException\n文件未找到异常：FileNotFoundException\n字符串转换为数字异常：NumberFormatException\n操作数据库异常：SQLException\n输入输出异常：IOException\n方法未找到异常：NoSuchMethodException\njava.lang.AbstractMethodError\n抽象方法错误。当应用试图调用抽象方法时抛出。\njava.lang.AssertionError\n断言错。用来指示一个断言失败的情况。\njava.lang.ClassCircularityError\n类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。\njava.lang.ClassFormatError\n类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。\njava.lang.Error\n错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。\njava.lang.ExceptionInInitializerError\n初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。\njava.lang.IllegalAccessError\n违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。\njava.lang.IncompatibleClassChangeError\n不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。\njava.lang.InstantiationError\n实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.\njava.lang.InternalError\n内部错误。用于指示Java虚拟机发生了内部错误。\njava.lang.LinkageError\n链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。\njava.lang.NoClassDefFoundError\n未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。\njava.lang.NoSuchFieldError\n域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。\njava.lang.NoSuchMethodError\n方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。\njava.lang.OutOfMemoryError\n内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。\njava.lang.StackOverflowError\n堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。\njava.lang.ThreadDeath\n线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。\njava.lang.UnknownError\n未知错误。用于指示Java虚拟机发生了未知严重错误的情况。\njava.lang.UnsatisfiedLinkError\n未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。\njava.lang.UnsupportedClassVersionError\n不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。\njava.lang.VerifyError\n验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。\njava.lang.VirtualMachineError\n虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。\njava.lang.ArithmeticException\n算术条件异常。譬如：整数除零等。\njava.lang.ArrayIndexOutOfBoundsException\n数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。\njava.lang.ArrayStoreException\n数组存储异常。当向数组中存放非数组声明类型对象时抛出。\njava.lang.ClassCastException\n类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。\njava.lang.ClassNotFoundException\n找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。\njava.lang.CloneNotSupportedException\n不支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。\njava.lang.EnumConstantNotPresentException\n枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。\njava.lang.Exception\n根异常。用以描述应用程序希望捕获的情况。\njava.lang.IllegalAccessException\n违法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。\njava.lang.IllegalMonitorStateException\n违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。\njava.lang.IllegalStateException\n违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。\njava.lang.IllegalThreadStateException\n违法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。\njava.lang.IndexOutOfBoundsException\n索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。\njava.lang.InstantiationException\n实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。\njava.lang.InterruptedException\n被中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。\njava.lang.NegativeArraySizeException\n数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。\njava.lang.NoSuchFieldException\n属性不存在异常。当访问某个类的不存在的属性时抛出该异常。\njava.lang.NoSuchMethodException\n方法不存在异常。当访问某个类的不存在的方法时抛出该异常。\njava.lang.NullPointerException\n空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。\njava.lang.NumberFormatException\n数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。\njava.lang.RuntimeException\n运行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。\njava.lang.SecurityException\n安全异常。由安全管理器抛出，用于指示违反安全情况的异常。\njava.lang.StringIndexOutOfBoundsException\n字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。\njava.lang.TypeNotPresentException\n类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。\njava.lang.UnsupportedOperationException\n不支持的方法异常。指明请求的方法不被支持情况的异常。\n异常javax.servlet.jsp.JspException: Cannot retrieve mapping for action /Login （/Login是你的action名字） &nbsp;\n可能原因action没有再struts-config.xml 中定义，或没有找到匹配的action，例如在JSP文件中使用 &lt;html:form action=&quot;Login.do&quot;.将表单提交给Login.do处理，如果出现上述异常，请查看struts-config.xml中的定义部分，有时可能是打错了字符或者是某些不符合规则，可以使用strutsconsole工具来检查。-----------------------------------------------------------------------------------------------------------------异常org.apache.jasper.JasperException: Cannot retrieve definition for form bean null\n可能原因 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个异常是因为Struts根据struts-config.xml中的mapping没有找到action期望的form bean。大部分的情况可能是因为在form-bean中设置的name属性和action中设置的name属性不匹配所致。换句话说，action和form都应该各自有一个name属性，并且要精确匹配，包括大小写。这个错误当没有name属性和action关联时也会发生，如果没有在action中指定name属性，那么就没有name属性和action相关联。当然当action制作某些控制时，譬如根据参数值跳转到相应的jsp页面，而不是处理表单数据，这是就不用name属性，这也是action的使用方法之一。-----------------------------------------------------------------------------------------------------------------异常No action instance for path /xxxx could be created\n可能原因特别提示：因为有很多中情况会导致这个错误的发生，所以推荐大家调高你的web服务器的日志/调试级别，这样可以从更多的信息中看到潜在的、在试图创建action类时发生的错误，这个action类你已经在struts-config.xml中设置了关联（即添加了&lt;action&gt;标签）。\n在struts-config.xml中通过action标签的class属性指定的action类不能被找到有很多种原因，例如：定位编译后的.class文件失败。Failure to place compiled .class file for the action in the classpath (在web开发中，class的的位置在r WEB-INF/classes，所以你的action class必须要在这个目录下。例如你的action类位于WEB-INF/classes/action/Login.class,那么在struts-config.xml中设置action的属性type时就是action.Login).拼写错误，这个也时有发生，并且不易找到，特别注意第一个字母的大小写和包的名称。 -----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: No getter method for property username of bean org.apache.struts.taglib.html.BEAN\n可能原因没有位form bean中的某个变量定义getter 方法\n这个错误主要发生在表单提交的FormBean中，用struts标记&lt;html:text property=”username”&gt;时，在FormBean中必须有一个getUsername()方法。注意字母“U”。-----------------------------------------------------------------------------------------------------------------异常java.lang.NoClassDefFoundError: org/apache/struts/action/ActionForm\n可能原因这个错误主要发生在在classpath中找不到相应的Java .class文件。如果这个错误发生在web应用程序的运行时，主要是因为指定的class文件不在web server的classpath中（/WEB-INF/classes 和 /WEB-INF/lib）。在上面的错误中，原因是找不到ActionForm类。-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Exception creating bean of class org.apache.struts.action.ActionForm: {1}\n可能原因Instantiating Struts-provided ActionForm class directly instead of instantiating a class derived off ActionForm. This mightoccur implicitly if you specify that a form-bean is this Struts ActionForm class rather than specifying a child of this classfor the form-bean.\nNot associating an ActionForm-descended class with an action can also lead to this error.-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Cannot find ActionMappings or ActionFormBeans collection\n可能原因不是标识Struts actionServlet的&lt;servlet&gt;标记就是映射.do扩展名的&lt;sevlet-mapping&gt;标记或者两者都没有在web.xml中声明。\n在struts-config.xml中的打字或者拼写错误也可导致这个异常的发生。例如缺少一个标记的关闭符号/&gt;。最好使用struts console工具检查一下。\n另外，load-on-startup必须在web.xml中声明，这要么是一个空标记，要么指定一个数值，这个数值用来表servlet运行的优先级，数值越大优先级越低。\n还有一个和使用load-on-startup有关的是使用Struts预编译JSP文件时也可能导致这个异常。-----------------------------------------------------------------------------------------------------------------异常java.lang.NullPointerException at org.apache.struts.util.RequestUtils.forwardURL(RequestUtils.java:1223)\n可能原因在struts-config.xml中的forward元素缺少path属性。例如应该是如下形式：&lt;forward name=&quot;userhome&quot; path=&quot;/user/userhome.jsp&quot;/&gt;-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Cannot find bean org.apache.struts.taglib.html.BEAN in any scope\n \nProbable Causes试图在Struts的form标记外使用form的子元素。这常常发生在你在&lt;/html:form&gt;后面使用Struts的html标记。另外要注意可能你不经意使用的无主体的标记，如&lt;html:form … /&gt;，这样web 服务器解析时就当作一个无主体的标记，随后使用的所有&lt;html&gt;标记都被认为是在这个标记之外的，如又使用了&lt;html:text property=”id”&gt;还有就是在使用taglib引入HTML标记库时，你使用的prefix的值不是html。-----------------------------------------------------------------------------------------------------------------异常javax.servlet.jsp.JspException: Missing message for key xx.xx.xx\nProbable Causes这个key的值对没有在资源文件ApplicationResources.properties中定义。如果你使用eclipse时经常碰到这样的情况，当项目重新编译时，eclipse会自动将classes目录下的资源文件删除。\n资源文件ApplicationResources.properties 不在classpath中应将资源文件放到 WEB-INF/classes 目录下，当然要在struts-config.xml中定义)-----------------------------------------------------------------------------------------------------------------异常Cannot find message resources under key org.apache.struts.action.MESSAGE\n可能原因很显然，这个错误是发生在使用资源文件时，而Struts没有找到资源文件。\nImplicitly trying to use message resources that are not available (such as using empty html:options tag instead of specifyingthe options in its body -- this assumes options are specified in ApplicationResources.properties file)\nXML parser issues -- too many, too few, incorrect/incompatible versions-----------------------------------------------------------------------------------------------------------------异常Strange and seemingly random characters in HTML and on screen, but not in original JSP or servlet.\n可能原因混和使用Struts的html:form标记和标准的HTML标记不正确。\n使用的编码样式在本页中不支持。-----------------------------------------------------------------------------------------------------------------异常&quot;Document contained no data&quot; in Netscape\nNo data rendered (completely empty) page in Microsoft Internet Explorer\n可能原因使用一个Action的派生类而没有实现perform()方法或execute()方法。在Struts1.0中实现的是perform()方法，在Struts1.1中实现的是execute()方法，但Struts1.1向后兼容perform()方法。但你使用Struts1.1创建一个Action的派生类，并且实现了execute()方法，而你在Struts1.0中运行的话，就会得到&quot;Document contained nodata&quot; error message in Netscape or a completely empty (no HTML whatsoever) page rendered in Microsoft Internet Explorer.”的错误信息。\n---------------------------------------------------------------------------------------------------------------------------异常ServletException: BeanUtils.populate解决方案在用Struts上传文件时,遇到了javax.servlet.ServletException: BeanUtils.populate异常。我的ActionServlet并没有用到BeanUtils这些工具类。后来仔细检查代码发现是在jsp文件里的form忘了加enctype=&amp;quot;multipart/form-data&amp;quot; 了。所以写程序遇到错误或异常应该从多方面考虑问题存在的可能性，想到系统提示信息以外的东西。----------------------------------------------------------------------------------------------------------------------------1. 定义Action后, 如果指定了name, 那么必须要定义一个与它同名的FormBean才能进行form映射.2. 如果定义Action后, 提交页面时出现 &quot;No input attribute for mapping path...&quot; 错误, 则需要在其input属性中定义转向的页面.3. 如果插入新的数据时出现 &quot;Batch update row count wrong:...&quot; 错误, 则说明XXX.hbm.xml中指定的key的类型为原始类型(int, long),因为这种类型会自动分配值, 而这个值往往会让系统认为已经存在该记录, 正确的方法是使用java.lang.Integer或java.lang.Long对象.4. 如果插入数据时出现 &quot;argument type mismatch&quot; 错误, 可能是你使用了Date等特殊对象, 因为struts不能自动从String型转换成Date型,所以, 你需要在Action中手动把String型转换成Date型.5. Hibernate中, Query的iterator()比list()方法快很多.6. 如果出现 &quot;equal symbol expected&quot; 错误, 说明你的strtus标签中包含另一个标签或者变量, 例如:&lt;html:select property=&quot;test&quot; onchange=&quot;&lt;%=test%&gt;&quot;/&gt;或者&lt;html:hidden property=&quot;test&quot; value=&quot;&lt;bean:write name=&quot;t&quot; property=&quot;p&quot;/&gt;&quot;/&gt;这样的情况... ---------------------------------------------------------------------------------------------------------------------------错误：Exception in thread &quot;main&quot; org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update原因与解决： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为Hibernate Tools（或者Eclipse本身的Database Explorer）生成*.hbn.xml工具中包含有catalog=&quot;***&quot;（*表示数据库名称）这样的属性,将该属性删除就可以了---------------------------------------------------------------------------------------------------------------------------错误：org.hibernate.ObjectDeletedException: deleted object would be re-saved by cascade (remove deleted object from associations)原因与解决：方法1 删除Set方的cascade方法2 解决关联关系后，再删除方法3 在many-to-one方增加cascade 但值不能是none最后一招：检查一下hashCode equals是否使用了id作为唯一标示的选项了；我用uuid.hex时是没有问题的；但是用了native，就不行了，怎么办？删除啊！----------------------------------------------------------------------------------------------------------------------------问题：今天用Tomcat 5.5.12，发现原来很好用的系统不能用了，反复测试发现页面中不能包含 taglib，否则会出现以下提示：HTTP Status 500 -type Exception reportMessage description The server encountered an internal error () that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: /index.jsp(1,1) Unable to read TLD &quot;META-INF/tlds/struts-bean.tld&quot; from JAR file&quot;file:*****/WEB-INF/lib/struts.jar&quot;:原因：更新了工程用的lib文件夹下的jar，发布时也发布了servlet.jar和jsp-api.jar。解决：把jsp-api.jar删除就解决这个问题了。-----------------------------------------------------------------------------------------------------------------------------错误： java.lang.NullPointerException原因： 发现 dao 实例、 manage 实例等需要注入的东西没有被注入（俗称空指针异常）解决：这个时候，你应该查看日志文件；默认是应用服务器的 log 文件，比如 Tomcat 就是 [Tomcat 安装目录 ]/logs ；你会发现提示你：可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'sf\' defined in ServletContextresource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xmlorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xml……………………….Caused by: java.io.FileNotFoundException: src\\hibernate.cfg.xml可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'sessionFactory\' defined inServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not foundorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not found然后你就知道原因是因为配置文件的解析出了错误，这个通过 Web 页面是看不出来的。更多的是持久化影射文件出的错误；导致了没有被解析；当然你需要的功能就无法使用了。----------------------------------------------------------------------------------------------------------------------------错误：StandardWrapperValve[action]: Servlet.service() for servlet action threw exceptionjavax.servlet.jsp.JspException: Cannot retrieve mapping for action /settlementTypeManage或者： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type Status report &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message Servlet action is not available &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description The requested resource (Servlet action is not available) is not available.原因： 同 上----------------------------------------------------------------------------------------------------------------------------错误StandardWrapperValve[jsp]: Servlet.service() for servlet jsp threw exceptionjava.lang.ClassNotFoundException: org.apache.struts.taglib.bean.CookieTei界面错误具体描述：org.apache.jasper.JasperException: Failed to load or instantiate TagExtraInfo class: org.apache.struts.taglib.bean.CookieTei &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因与解决： &nbsp;&nbsp;&nbsp;&lt;方案一&gt;你的“html:”开头的标签没有放在一个&lt;html:form&gt;中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;方案二&gt;重新启动你的应用服务器，自动就没有这个问题\n        ', null);
INSERT INTO `blog` VALUES ('59', '正则表达式大全', '\n            匹配中文字符的正则表达式： [u4e00-u9fa5] &nbsp;&nbsp; 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了  匹配双字节字符(包括汉字在内)：[^x00-xff]  评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）  匹配空白行的正则表达式：ns*r  评注：可以用来删除空白行  匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;  评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力  匹配首尾空白字符的正则表达式：^s*|s*$  评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式  匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*  评注：表单验证时很实用  匹配网址URL的正则表达式：[a-zA-z]+://[^s]*  评注：网上流传的版本功能很有限，上面这个基本可以满足需求  匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$  评注：表单验证时很实用  匹配国内电话号码：d{3}-d{8}|d{4}-d{7}  评注：匹配形式如 0511-4405222 或 021-87888822  匹配腾讯QQ号：[1-9][0-9]{4,}  评注：腾讯QQ号从10000开始  匹配中国邮政编码：[1-9]d{5}(?!d)  评注：中国邮政编码为6位数字  匹配身份证：d{15}|d{18}  评注：中国的身份证为15位或18位  匹配ip地址：d+.d+.d+.d+  评注：提取ip地址时有用  匹配特定数字：  ^[1-9]d*$ //匹配正整数  ^-[1-9]d*$ //匹配负整数  ^-?[1-9]d*$ //匹配整数  ^[1-9]d*|0$ //匹配非负整数（正整数 + 0）  ^-[1-9]d*|0$ //匹配非正整数（负整数 + 0）  ^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数  ^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数  ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数  ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0）  ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0）  评注：处理大量数据时有用，具体应用时注意修正  匹配特定字符串：  ^[A-Za-z]+$ //匹配由26个英文字母组成的字符串  ^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串  ^[a-z]+$ //匹配由26个英文字母的小写组成的字符串  ^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串  ^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串  在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下:  只能输入数字：“^[0-9]*$”  只能输入n位的数字：“^d{n}$”  只能输入至少n位数字：“^d{n,}$”  只能输入m-n位的数字：“^d{m,n}$”  只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$”  只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$”  只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$”  只能输入非零的正整数：“^+?[1-9][0-9]*$”  只能输入非零的负整数：“^-[1-9][0-9]*$”  只能输入长度为3的字符：“^.{3}$”  只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”  只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”  只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”  只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$”  只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”  验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间，  只能包含字符、数字和下划线。  验证是否含有^%&amp;\'\',;=?$&quot;等字符：“[^%&amp;\'\',;=?$x22]+”  只能输入汉字：“^[u4e00-u9fa5],{0,}$”  验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$”  验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$”  验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$”  正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，  “XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。  验证身份证号（15位或18位数字）：“^d{15}|d{}18$”  验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”  验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”  正确格式为：“01”“09”和“1”“31”。  匹配中文字符的正则表达式： [u4e00-u9fa5]  匹配双字节字符(包括汉字在内)：[^x00-xff]  匹配空行的正则表达式：n[s| ]*r  匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*|&lt;(.*) /&gt;/  匹配首尾空格的正则表达式：(^s*)|(s*$)  匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*  匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?  (1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）  String.prototype.len=function(){return this.replace([^x00-xff]/g,&quot;aa&quot;).length;}  (2)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现  String.prototype.trim = function()  {  return this.replace(/(^s*)|(s*$)/g, &quot;&quot;);  }  (3)应用：利用正则表达式分解和转换IP地址  function IP2V(ip) //IP地址转换成对应数值  {  re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式  if(re.test(ip))  {  return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1  }  else  {  throw new Error(&quot;Not a valid IP address!&quot;)  }  }  (4)应用：从URL地址中提取文件名的javascript程序  s=&quot;http://www.9499.net/page1.htm&quot;;  s=s.replace(/(.*/){0,}([^.]+).*/ig,&quot;$2&quot;) ;//Page1.htm  (5)应用：利用正则表达式限制网页表单里的文本框输入内容  用正则表达式限制只能输入中文：onkeyup=&quot;value=value.replace(/[^u4E00-u9FA5]/g,\'\') &quot;onbeforepaste=&quot;clipboardData.setData(\'\'text\'\',clipboardData.getData(\'\'text\'\').replace(/[^u4E00-u9FA5]/g,\'\'))&quot;  用正则表达式限制只能输入全角字符： onkeyup=&quot;value=value.replace(/[^uFF00-uFFFF]/g,\'\') &quot;onbeforepaste=&quot;clipboardData.setData(\'\'text\'\',clipboardData.getData(\'\'text\'\').replace(/[^uFF00-uFFFF]/g,\'\'))&quot;  用正则表达式限制只能输入数字：onkeyup=&quot;value=value.replace(/[^d]/g,\'\') &quot;onbeforepaste= &quot;clipboardData.setData(\'\'text\'\',clipboardData.getData(\'\'text\'\').replace(/[^d]/g,\'\'))&quot;  用正则表达式限制只能输入数字和英文：onkeyup=&quot;value=value.replace(/[W]/g,\'\') &quot;onbeforepaste=&quot;clipboardData.setData(\'\'text\'\',clipboardData.getData(\'\'text\'\').replace(/[^d]/g,\'\'\n        ', null);
INSERT INTO `blog` VALUES ('60', '修改secureCRT默认背景色', '\n            SecureCRT改颜色方案为Traditional大家都会了，但是好多人只会修改单一标签的，这样每次新建会话都要重新修改，太麻烦了。今天告诉大家如何一劳永逸修改颜色方案为Traditional(黑色背景，绿色字符)。\n 这里我用的是中文版，英文版一样。\n 1、点击&quot;选项&quot;(Options)-&quot;全局选项&quot;(Global options)\n 2、左边选择&quot;默认会话&quot;(Default Session)\n 3、右边选择&quot;编辑默认设置&quot;(Edit default setting)\n\n 4、左边选择&quot;外观&quot;(Appearance)\n 5、右边的&quot;当前颜色方案&quot;(Current color scheme)，选择&quot;Traditional&quot;，确定\n\n 6、弹出的对话框选择&quot;是&quot;(yes)保存为默认配置。\n\n 7、以后再创建新的会话就会使用Traditional颜色方案了。\n        ', null);
INSERT INTO `blog` VALUES ('61', 'HTTP协议的头信息', '\n            通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可 选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域 值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。  通用头域 通用头 域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩 展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。  Cache-Control头域 Cache -Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如 下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。  Date头域 Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。  Pragma头域 Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。  请求消息 请求消息的第一行为下面的格式： MethodSPRequest-URISPHTTP-VersionCRLFMethod 表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、 TRACE。方法GET和HEAD应该被所有的通用WEB服务器支持，其他所有方法的实现是可选的。GET方法取回由Request-URI标识的信息。 HEAD方法也是取回由Request-URI标识的信息，只是可以在响应时，不返回消息体。POST方法可以请求服务器接收包含在请求中的实体信息，可 以用于提交表单，向新闻组、BBS、邮件群组和数据库发送消息。 SP表示空格。Request-URI遵循URI格式，在此字段为星 号（*）时，说明请求并不用于某个特定的资源地址，而是用于服务器本身。HTTP- Version表示支持的HTTP版本，例如为HTTP/1.1。CRLF表示换行回车符。请求头域允许客户端向服务器传递关于请求或者关于客户机的附加 信息。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请 求头域，一般将会作为实体头域处理。  典型的请求消息： GET http://download.microtool.de:80/somedata.exe Host: download.microtool.de Accept:*/* Pragma: no-cache Cache-Control: no-cache Referer: http://download.microtool.de/ User-Agent:Mozilla/4.04[en](Win95;I;Nav) Range:bytes=554554- 上例第一行表示HTTP客户端（可能是浏览器、下载程序）通过GET方法获得指定URL下的文件。棕色的部分表示请求头域的信息，绿色的部分表示通用头部分。  Host头域 Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。  Referer头域 Referer 头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被 追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。  Range头域 Range头域可以请求实体的一个或者多个子范围。例如， 表示头500个字节：bytes=0-499 表示第二个500字节：bytes=500-999 表示最后500个字节：bytes=-500 表示500字节以后的范围：bytes=500- 第一个和最后一个字节：bytes=0-0,-1 同时指定几个范围：bytes=500-600,601-999 但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200 （OK）。  User-Agent头域 User-Agent头域的内容包含发出请求的用户信息。  响应消息 响应消息的第一行为下面的格式： HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF HTTP -Version表示支持的HTTP版本，例如为HTTP/1.1。Status- Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自 动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可 能取5个不同的值： 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和 Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头 域，一般将会作为实体头域处理。 典型的响应消息： HTTP/1.0200OK Date:Mon,31Dec200104:25:57GMT Server:Apache/1.3.14(Unix) Content-type:text/html Last-modified:Tue,17Apr200106:46:28GMT Etag:&quot;a030f020ac7c01:1e9f&quot; Content-length:39725426 Content-range:bytes554554-40279979/40279980 上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。  Location响应头 Location响应头用于重定向接收者到一个新URI地址。  Server响应头 Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。  实体 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体 头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定 义，它的长度由Content-Length或Content-Range定义。  Content-Type实体头 Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型 Content-Range实体头 Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth 例如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围， Content-Length表示实际传送的字节数。  Last-modified实体头 \n应答头\n说明\nAllow\n服务器支持哪些请求方法（如GET、POST等）。\nContent-Encoding\n文 档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的 下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(&quot;Accept- Encoding&quot;)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length\n表 示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type\n表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 \nDate\n当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires\n应该在什么时候认为文档已经过期，从而不再缓存它？\nLast-Modified\n文 档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档 才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation\n表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh\n表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)让浏览器读取指定的页面。 注 意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的 HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是“N秒之后 刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则 可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=&quot;Refresh&quot; ...＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer\n服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie\n设置和页面关联的Cookie。Servlet不应使用response.setHeader(&quot;Set-Cookie&quot;, ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate\n客 户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如， response.setHeader(&quot;WWW-Authenticate&quot;, &quot;BASIC realm=＼&quot;executives＼&quot;&quot;)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n \n        ', null);
INSERT INTO `blog` VALUES ('62', 'HTTP协议详解', '\n            引言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\nHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n \n \n一、HTTP协议详解之URL篇\n &nbsp;&nbsp;&nbsp;http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。\nHTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：http://host[&quot;:&quot;port][abs_path]http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。eg:1、输入：www.guet.edu.cn浏览器自动转换成：http://www.guet.edu.cn/2、http:192.168.0.116:8080/index.jsp \n \n \n \n二、HTTP协议详解之请求篇\n &nbsp;&nbsp;&nbsp;http请求由三部分组成，分别是：请求行、消息报头、请求正文\n1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF &nbsp;其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。\n请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET &nbsp;&nbsp;&nbsp;&nbsp;请求获取Request-URI所标识的资源POST &nbsp;&nbsp;&nbsp;在Request-URI所标识的资源后附加新的数据HEAD &nbsp;&nbsp;&nbsp;请求获取由Request-URI所标识的资源的响应消息报头PUT &nbsp;&nbsp;&nbsp;&nbsp;请求服务器存储一个资源，并用Request-URI作为其标识DELETE &nbsp;请求服务器删除Request-URI所标识的资源TRACE &nbsp;&nbsp;请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求应用举例：GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)\nPOST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。eg：POST /reg.jsp HTTP/ (CRLF)Accept:image/gif,image/x-xbit,... (CRLF)...HOST:www.guet.edu.cn (CRLF)Content-Length:22 (CRLF)Connection:Keep-Alive (CRLF)Cache-Control:no-cache (CRLF)(CRLF) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//该CRLF表示消息报头已经结束，在此之前为消息报头user=jeffrey&amp;pwd=1234 &nbsp;//此行以下为提交的数据\nHEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。2、请求报头后述3、请求正文(略) \n \n三、HTTP协议详解之响应篇\n &nbsp;&nbsp;&nbsp;在接收和解释请求消息后，服务器返回一个HTTP响应消息。\nHTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文1、状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求常见状态代码、状态描述、说明：200 OK &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//客户端请求成功400 Bad Request &nbsp;//客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//头域一起使用 403 Forbidden &nbsp;//服务器收到请求，但是拒绝提供服务404 Not Found &nbsp;//请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable &nbsp;//服务器当前不能处理客户端的请求，一段时间后， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//可能恢复正常eg：HTTP/1.1 200 OK （CRLF）\n2、响应报头后述\n3、响应正文就是服务器返回的资源的内容 \n \n四、HTTP协议详解之消息报头篇\n &nbsp;&nbsp;&nbsp;HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。\nHTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。\n1、普通报头在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。eg：Cache-Control &nbsp;&nbsp;用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);//response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);作用相当于上述代码，通常两者//合用这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache\nDate普通报头域表示消息产生的日期和时间\nConnection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接\n2、请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号User-Agent我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。请求报头举例：GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF)\n3、响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。常用的响应报头LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot; &nbsp;//可以看出服务器对请求资源采用的是基本验证机制。\n4、实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipContent-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:daContent-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;);\n \n \n五、利用telnet观察http协议的通讯过程\n &nbsp;&nbsp;&nbsp;实验目的及原理： &nbsp;&nbsp;&nbsp;利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。\n &nbsp;&nbsp;&nbsp;实验步骤：\n1、打开telnet1.1 打开telnet运行--&gt;cmd--&gt;telnet\n1.2 打开telnet回显功能set localecho\n2、连接服务器并发送请求2.1 open www.guet.edu.cn 80 &nbsp;//注意端口号不能省略\n &nbsp;&nbsp;&nbsp;HEAD /index.asp HTTP/1.0 &nbsp;&nbsp;&nbsp;Host:www.guet.edu.cn &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;/*我们可以变换请求方法,请求桂林电子主页内容,输入消息如下*/ &nbsp;&nbsp;&nbsp;open www.guet.edu.cn 80  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GET /index.asp HTTP/1.0 &nbsp;//请求资源的内容 &nbsp;&nbsp;&nbsp;Host:www.guet.edu.cn &nbsp;\n2.2 open www.sina.com.cn 80 &nbsp;//在命令提示符号下直接输入telnet www.sina.com.cn 80 &nbsp;&nbsp;&nbsp;HEAD /index.asp HTTP/1.0 &nbsp;&nbsp;&nbsp;Host:www.sina.com.cn \n3 实验结果：\n3.1 请求信息2.1得到的响应是:\nHTTP/1.1 200 OK &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//请求成功Server: Microsoft-IIS/5.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//web服务器Date: Thu,08 Mar 200707:17:51 GMTConnection: Keep-Alive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Content-Length: 23330Content-Type: text/htmlExpries: Thu,08 Mar 2007 07:16:51 GMTSet-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/Cache-control: private\n//资源内容省略\n3.2 请求信息2.2得到的响应是:\nHTTP/1.0 404 Not Found &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//请求失败Date: Thu, 08 Mar 2007 07:50:50 GMTServer: Apache/2.0.54 &lt;Unix&gt;Last-Modified: Thu, 30 Nov 2006 11:35:41 GMTETag: &quot;6277a-415-e7c76980&quot;Accept-Ranges: bytesX-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remixVary: Accept-EncodingContent-Type: text/htmlX-Cache: MISS from zjm152-78.sina.com.cnVia: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt;X-Cache: MISS from th-143.sina.com.cnConnection: close\n失去了跟主机的连接\n按任意键继续...\n4 .注意事项：1、出现输入错误，则请求不会成功。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、报头域不分大小写。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、更深一步了解HTTP协议，可以查看RFC2616，在http://www.letf.org/rfc上找到该文件。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、开发后台程序必须掌握http协议\n \n六、HTTP协议相关技术补充\n &nbsp;&nbsp;&nbsp;1、基础： &nbsp;&nbsp;&nbsp;高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。 &nbsp;&nbsp;&nbsp;&nbsp;代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 &nbsp;&nbsp;&nbsp;通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。2、协议分析的优势—HTTP分析器检测网络攻击以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。http://www.cnpaf.net/Class/HTTP/0532918532667330.html4、利用HTTP协议的特性进行拒绝服务攻击的一些构思服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。5、Http指纹识别技术 &nbsp;&nbsp;Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。常用测试请求：1：HEAD/Http/1.0发送基本的Http请求2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求3：GET/Http/3.0发送一个非法版本的Http协议请求4：GET/JUNK/1.0发送一个不正确规格的Http协议请求Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供更高效率的连接。\n原文：http://blog.csdn.net/gueter/article/details/1524447 \n        ', null);
INSERT INTO `blog` VALUES ('63', 'Eclipse 快捷键', '\n            Eclipse本身很快的，但是加上了myeclipse后，就狂占内存，而且速度狂慢，那如何让Eclipse拖着myeclipse狂飚呢?这里提供一个：\n\n技巧：取消自动validation \nvalidation有一堆，什么xml、jsp、jsf、js等等，我们没有必要全部都去自动校验一下，只是需要的时候才会手工校验一下，速度立马提升好几个档次！ \n取消方法： windows--&gt;perferences--&gt;myeclipse--&gt;validation 除开Manual下面的复选框全部选中之外，其他全部不选手工验证方法： \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在要验证的文件上，单击鼠标右键--&gt;myeclipse--&gt;run validation\n程序代码自动排版：Ctrl+Shift+F，会自动把代码进行格式化的排版，非常方便\n快速执行程序：Ctrl + F11第一次执行时，它会询问您执行模式，设置好后，以后只要按这个热键，它就会快速执行.\nCtrl+Shift+/ 加上段注释/**/\nCtrl+Shift+\\ 取消段注释/**/\nCtrl+/ 加上行注释或取消行注释\n自动汇入所需要的类别：Ctrl+Shift+M Ctrl+Shift+O 好象使用Ctrl+Shift+O 也可以\n重要技巧（机器配置低就别用了，呵呵）\nEclipse中默认是输入&quot;.&quot;后出现自动提示，用于类成员的自动提示，可是有时候我们希望它能在我们输入类的首字母后就出现自动提示，可以节省大量的输入时间(虽然按alt + /会出现提示，但还是要多按一次按键，太麻烦了). \n从Window -&gt; preferences -&gt; Java -&gt; Editor -&gt; Content assist -&gt; Auto-Activation下，我们可以在&quot;.&quot;号后面加入我们需要自动提示的首字幕，比如&quot;ahiz&quot;. \n然后我们回到Eclipse的开发环境，输入&quot;a&quot;，提示就出现了. \n但是我们可以发现，这个Auto-Activation下的输入框里最多只能输入5个字母，也许是Eclipse的开发人员担心我们输入的太多会影响性能，但计算机的性能不用白不用，所以我们要打破这个限制. \n其实上面都是铺垫，制造一下气氛，以显得我们下面要做的事情很牛似的，其实不然，一切都很简单.嘿嘿 :) \n在&quot;.&quot;后面随便输入几个字符，比如&quot;abij&quot;，然后回到开发环境，File -&gt; export -&gt; general -&gt; preferences -&gt; 选一个地方保存你的首选项，比如C:\\a.epf \n用任何文本编辑器打开a.epf，查找字符串“abij”，找到以后，替换成“abcdefghijklmnopqrstuvwxyz”，总之就是你想怎样就怎样！！然后回到Eclipse，File -&gt; import -&gt; general -&gt; preferences -&gt; 导入刚才的a.epf文件.此时你会发现输入任何字幕都可以得到自动提示了.爽！！！ \n最后：自动提示弹出的时间最好改成100毫秒以下，这样会比较爽一点，不然你都完事了，自动提示才弹出来:)，不过也要看机器性能.\n\nmyeclipse自动提示背景颜色设置（再也不那么淡）\nwindow--preference--java--editor- completion proposals Background 颜色推荐85，90，205\n\nEclipse 常用快捷键 \nEclipse的编辑功能非常强大，掌握了Eclipse快捷键功能，能够大大提高开发效率。Eclipse中有如下一些和编辑相关的快捷键。 \n1. 【ALT+/】 \n此快捷键为用户编辑的好帮手，能为用户提供内容的辅助，不要为记不全方法和属性名称犯愁，当记不全类、方法和属性的名字时，多体验一下【ALT+/】快捷键带来的好处吧。 \n2. 【Ctrl+O】 \n显示类中方法和属性的大纲，能快速定位类的方法和属性，在查找Bug时非常有用。 \n3. 【Ctrl+/】 \n快速添加注释，能为光标所在行或所选定行快速添加注释或取消注释，在调试的时候可能总会需要注释一些东西或取消注释，现在好了，不需要每行进行重复的注释。 \n4. 【Ctrl+D】 \n删除当前行，这也是笔者的最爱之一，不用为删除一行而按那么多次的删除键。 \n5. 【Ctrl+M】 \n窗口最大化和还原，用户在窗口中进行操作时，总会觉得当前窗口小（尤其在编写代码时），现在好了，试试【Ctrl+M】快捷键。 \n查看和定位快捷键 \n在程序中，迅速定位代码的位置，快速找到Bug的所在，是非常不容易的事，Eclipse提供了强大的查找功能，可以利用如下的快捷键帮助完成查找定位的工作。 \n1. 【Ctrl+K】、【Ctrl++Shift+K】 \n快速向下和向上查找选定的内容，从此不再需要用鼠标单击查找对话框了。 \n2. 【Ctrl+Shift+T】 \n查找工作空间（Workspace）构建路径中的可找到Java类文件，不要为找不到类而痛苦，而且可以使用“*”、“？”等通配符。 \n3. 【Ctrl+Shift+R】 \n和【Ctrl+Shift+T】对应，查找工作空间（Workspace）中的所有文件（包括Java文件），也可以使用通配符。 \n\n\n4. 【Ctrl+Shift+G】 \n查找类、方法和属性的引用。这是一个非常实用的快捷键，例如要修改引用某个方法的代码，可以通过【Ctrl+Shift+G】快捷键迅速定位所有引用此方法的位置。 \n\n\n5. 【Ctrl+Shift+O】 \n快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类，试试【Ctrl+Shift+O】快捷键，一定会有惊喜。 \n6. 【Ctrl+Shift+F】 \n格式化代码，书写格式规范的代码是每一个程序员的必修之课，当看见某段代码极不顺眼时，选定后按【Ctrl+Shift+F】快捷键可以格式化这段代码，如果不选定代码则默认格式化当前文件（Java文件）。 \n7. 【ALT+Shift+W】 \n查找当前文件所在项目中的路径，可以快速定位浏览器视图的位置，如果想查找某个文件所在的包时，此快捷键非常有用（特别在比较大的项目中）。 \n8. 【Ctrl+L】 \n定位到当前编辑器的某一行，对非Java文件也有效。 \n9. 【Alt+←】、【Alt+→】 \n后退历史记录和前进历史记录，在跟踪代码时非常有用，用户可能查找了几个有关联的地方，但可能记不清楚了，可以通过这两个快捷键定位查找的顺序。 \n10. 【F3】 \n快速定位光标位置的某个类、方法和属性。 \n11. 【F4】 \n显示类的继承关系，并打开类继承视图。 \n调试快捷键 \nEclipse中有如下一些和运行调试相关的快捷键。 \n1. 【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。 \n2. 【F11】：调试最后一次执行的程序。 \n3. 【Ctrl+F11】：运行最后一次执行的程序。 \n4. 【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。 \n5. 【F6】：单步执行程序。 \n6. 【F7】：执行完方法，返回到调用此方法的后一条语句。 \n7. 【F8】：继续执行，到下一个断点或程序结束。 \n常用编辑器快捷键 \n通常文本编辑器都提供了一些和编辑相关的快捷键，在Eclipse中也可以通过这些快捷键进行文本编辑。 \n1. 【Ctrl+C】：复制。 \n2. 【Ctrl+X】：剪切。 \n3. 【Ctrl+V】：粘贴。 \n4. 【Ctrl+S】：保存文件。 \n5. 【Ctrl+Z】：撤销。 \n6. 【Ctrl+Y】：重复。 \n7. 【Ctrl+F】：查找。 \n其他快捷键 \nEclipse中还有很多快捷键，无法一一列举，用户可以通过帮助文档找到它们的使用方式，另外还有几个常用的快捷键如下。 \n1. 【Ctrl+F6】：切换到下一个编辑器。 \n2. 【Ctrl+Shift+F6】：切换到上一个编辑器。 \n3. 【Ctrl+F7】：切换到下一个视图。 \n4. 【Ctrl+Shift+F7】：切换到上一个视图。 \n5. 【Ctrl+F8】：切换到下一个透视图。 \n6. 【Ctrl+Shift+F8】：切换到上一个透视图。 \nEclipse中快捷键比较多，可以通过帮助文档找到所有快捷键的使用，但要掌握所有快捷键的使用是不可能的，也没有必要，如果花点时间熟悉本节列举的快捷键，必将会事半功倍\n\n1. edit-&gt;content Assist - &gt; add &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+/ 代码关联 \n2. Window -&gt; Next Editor -&gt; add &nbsp;&nbsp;&nbsp;Ctrl+Tab 切换窗口 \n3. Run/Debug Toggle Line Breakpoint -&gt; add Ctrl+` 在调试的时候 增删断点 \n\n\n4. Source-&gt; Surround with try/catch Block -&gt; Ctrl+Shift+v 增加try catch 框框 \n5. Source -&gt; Generate Getters and Setters -&gt; Ctrl+Shift+. 增加get set 方法\n\n-----------有用的快捷键----------- \nAlt+/ 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) \nCtrl+1:光标停在某变量上，按Ctrl+1键，可以提供快速重构方案。选中若干行，按Ctrl+1键可将此段代码放入for、while、if、do或try等代码块中。 \n双击左括号（小括号、中括号、大括号），将选择括号内的所有内容。 \nAlt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 \n-----------Ctrl系列----------- \nCtrl+K:将光标停留在变量上，按Ctrl+K键可以查找到下一个同样的变量 \nCtrl+Shift+K:和Ctrl+K查找的方向相反 \nCtrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) \nCtrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) \nCtrl+Q 定位到最后编辑的地方 \nCtrl+L 定位在某行 (对于程序超过100的人就有福音了) \nCtrl+M 最大化当前的Edit或View (再按则反之) \nCtrl+/ 注释当前行,再按则取消注释 \nCtrl+T 快速显示当前类的继承结构 \nCtrl+Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（source tree）打开的方式吧。 \nCtrl+O:在代码中打开类似大纲视图的小窗口 \nCtrl+鼠标停留:可以显示类和方法的源码 \nCtrl+H:打开搜索窗口 \nCtrl+/(小键盘) 折叠当前类中的所有代码 \nCtrl+&times;(小键盘) 展开当前类中的所有代码 \n-----------Ctrl+Shift 系列----------- \nCtrl+Shift+F 格式化当前代码 \nCtrl+Shift+X 把当前选中的文本全部变味小写 \nCtrl+Shift+Y 把当前选中的文本全部变为小写 \nCtrl+Shift+O:快速地导入import \nCtrl+Shift+R:打开资源 open Resource \n-----------F快捷键 系列----------- \nF3:打开声明该引用的文件 \nF4:打开类型层次结构 \nF5:单步跳入 \nF6:单步跳过 \nF7:单步跳出 \nF8:继续，如果后面没有断点，程序将运行完 \n-----------行编辑用----------- \nCtrl+D: 删除当前行 \nCtrl+Alt+↓ 复制当前行到下一行(复制增加) \nCtrl+Alt+↑ 复制当前行到上一行(复制增加) \nAlt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) \nAlt+↑ 当前行和上面一行交互位置(同上) \nShift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) \nCtrl+Shift+Enter 在当前行插入空行(原理同上条)\n        ', null);
INSERT INTO `blog` VALUES ('64', 'mysql性能', '\n             &nbsp;\n今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。\n1. 为查询缓存优化你的查询\n大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。\n这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：\n// 查询缓存不开启\n$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= CURDATE()&quot;);\n \n// 开启查询缓存\n$today = date(&quot;Y-m-d&quot;);\n$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= \'$today\'&quot;);\n上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。\n&nbsp;\n2. EXPLAIN 你的 SELECT 查询\n使用EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。\nEXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。\n挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：\n\n当我们为 group_id 字段加上索引后：\n\n我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。\n3. 当只要一行数据时使用 LIMIT 1\n当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。\n在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。\n下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）\n// 没有效率的：\n$r = mysql_query(&quot;SELECT * FROM user WHERE country = \'China\'&quot;);\nif (mysql_num_rows($r) &gt; 0) {\n    // ...\n}\n \n// 有效率的：\n$r = mysql_query(&quot;SELECT 1 FROM user WHERE country = \'China\' LIMIT 1&quot;);\nif (mysql_num_rows($r) &gt; 0) {\n    // ...\n}\n4. 为搜索字段建索引\n索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。\n\n从上图你可以看到那个搜索字串 “last_name LIKE ‘a%’”，一个是建了索引，一个是没有索引，性能差了4倍左右。\n另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用MySQL全文索引 或是自己做一个索引（比如说：搜索关键词或是Tag什么的）\n5. 在Join表的时候使用相当类型的例，并将其索引\n如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）\n// 在state中查找company\n$r = mysql_query(&quot;SELECT company_name FROM users\n    LEFT JOIN companies ON (users.state = companies.state)\n    WHERE users.id = $user_id&quot;);\n \n// 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。\n6. 千万不要 ORDER BY RAND()\n想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。\n如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）\n下面的示例是随机挑一条记录\n// 千万不要这样做：\n$r = mysql_query(&quot;SELECT username FROM user ORDER BY RAND() LIMIT 1&quot;);\n \n// 这要会更好：\n$r = mysql_query(&quot;SELECT count(*) FROM user&quot;);\n$d = mysql_fetch_row($r);\n$rand = mt_rand(0,$d[0] - 1);\n \n$r = mysql_query(&quot;SELECT username FROM user LIMIT $rand, 1&quot;);\n7. 避免 SELECT *\n从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。\n所以，你应该养成一个需要什么就取什么的好的习惯。\n// 不推荐\n$r = mysql_query(&quot;SELECT * FROM user WHERE user_id = 1&quot;);\n$d = mysql_fetch_assoc($r);\necho &quot;Welcome {$d[\'username\']}&quot;;\n \n// 推荐\n$r = mysql_query(&quot;SELECT username FROM user WHERE user_id = 1&quot;);\n$d = mysql_fetch_assoc($r);\necho &quot;Welcome {$d[\'username\']}&quot;;\n8. 永远为每张表设置一个ID\n我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。\n就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。\n而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……\n在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。\n9. 使用 ENUM 而不是 VARCHAR\nENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。\n如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。\nMySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。\n10. 从 PROCEDURE ANALYSE() 取得建议\nPROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。\n例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。\n在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议\n\n一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。\n11. 尽可能的使用 NOT NULL\n除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。\n首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)\n不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。\n下面摘自MySQL自己的文档：\n\n “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”\n\n12. Prepared Statements\nPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。\nPrepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。\n在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。\n虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。\n当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。\n在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展 或是使用数据库抽象层，如：PDO.\n// 创建 prepared statement\nif ($stmt = $mysqli-&gt;prepare(&quot;SELECT username FROM user WHERE state=?&quot;)) {\n \n    // 绑定参数\n    $stmt-&gt;bind_param(&quot;s&quot;, $state);\n \n    // 执行\n    $stmt-&gt;execute();\n \n    // 绑定结果\n    $stmt-&gt;bind_result($username);\n \n    // 移动游标\n    $stmt-&gt;fetch();\n \n    printf(&quot;%s is from %s\\n&quot;, $username, $state);\n \n    $stmt-&gt;close();\n}\n13. 无缓冲的查询\n正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。\n关于这个事情，在PHP的文档中有一个非常不错的说明：mysql_unbuffered_query() 函数：\n\n “mysql_unbuffered_query() sends the SQL query query to MySQL without automatically fetching and buffering the result rows as mysql_query() does. This saves a considerable amount of memory with SQL queries that produce large result sets, and you can start working on the result set immediately after the first row has been retrieved as you don’t have to wait until the complete SQL query has been performed.”\n\n上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。\n然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用mysql_free_result() 清除结果。而且，mysql_num_rows() 或mysql_data_seek() 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。\n14. 把IP地址存成 UNSIGNED INT\n很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。\n我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。\n而你的查询，你可以使用INET_ATON() 来把一个字符串IP转成一个整形，并使用INET_NTOA() 把一个整形转成一个字符串IP。在PHP中，也有这样的函数ip2long() 和long2ip()。\n$r = &quot;UPDATE users SET ip = INET_ATON(\'{$_SERVER[\'REMOTE_ADDR\']}\') WHERE user_id = $user_id&quot;;\n15. 固定长度的表会更快\n如果表中的所有字段都是“固定长度”的，整个表会被认为是“static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。\n固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。\n并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。\n使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。\n16. 垂直分割\n“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）\n示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。\n示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。\n另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。\n17. 拆分大的 DELETE 或 INSERT 语句\n如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。\nApache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。\n如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。\n所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：\nwhile (1) {\n    //每次只做1000条\n    mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= \'2009-11-01\' LIMIT 1000&quot;);\n    if (mysql_affected_rows() == 0) {\n        // 没得可删了，退出！\n        break;\n    }\n    // 每次都要休息一会儿\n    usleep(50000);\n}\n18. 越小的列会越快\n对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。\n参看 MySQL 的文档Storage Requirements 查看所有的数据类型。\n如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。\n当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。\n19. 选择正确的存储引擎\n在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。\nMyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。\nInnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。\n下面是MySQL的手册\n\n target=”_blank”MyISAM Storage Engine\n InnoDB Storage Engine\n\n20. 使用一个对象关系映射器（Object Relational Mapper）\n使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。\nORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。\nORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。\n目前，个人最喜欢的PHP的ORM是：Doctrine。\n21. 小心“永久链接”\n“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。\n\n PHP手册：mysql_pconnect()\n\n在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。\n而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。\n文章：来源\n（全文完）原文：http://coolshell.cn/articles/1846.html\n        ', null);
INSERT INTO `blog` VALUES ('65', 'Java自定义注解实践', '\n            ⊃2; &nbsp;背景\n最近在为公司的技术改造做准备，我设计了一个提高Web开发效率的技术框架，为了增加框架的友好性和易用性，决定采用注解来代替配置文件，于是我查询了很多的资料，进行整理和学习。\n \n \n⊃2; &nbsp;概念\n注解是JDK5引入的新特性，最初衍生自代码注释，但现在早已经超出了注释的范畴，以至于我很惶恐，不敢使用注释这个词汇来描述他，尽管现有的很多资料里仍然称其为注释。如果说反射使得很多技术实现（动态代理、依赖注入等）有了基础，那么注解就是使这些技术实现变得平民化的基础。\n \n从class文件规范中可以看出，JDK5开始，class文件已经引入了注解描述片段。站在java虚拟机的角度来看，class保留和运行时保留的注解已经和java二进制码放在了同等的地位。虚拟机在加载class文件时，会为注解内容分配空间并进行解析，最终还会为注解和对应的二进制码建立关联。尽管这些注解不会被运行，但其对代码的说明能力，结合反射技术已经足够我们做太多的事情。\n \n我们知道，java除了内置的注解（@Override、@Deprecated等）以外，还支持自定义注解（Struts、Hibernate等很多框架甚至java自身都实现了很多自定义注解）。当然，更为厉害的是元注解，元注解是用来描述注解的注解（光听着就觉得厉害了吧）。\n \n要实现一个自定义注解，必须通过@interface关键字来定义。且在@interface之前，需要通过元注解来描述该注解的使用范围（@Target）、生命周期（@Retention）及其他（其他的不重要，所以领盒饭了）。\n \n@Target用于描述注解的使用范围（即：被描述的注解可以用在什么地方），其取值有：\n取值\n描述\nCONSTRUCTOR\n用于描述构造器（领盒饭）。\nFIELD\n用于描述域（领盒饭）。\nLOCAL_VARIABLE\n用于描述局部变量（领盒饭）。\nMETHOD\n用于描述方法。\nPACKAGE\n用于描述包（领盒饭）。\nPARAMETER\n用于描述参数。\nTYPE\n用于描述类或接口（甚至enum）。\n \n@Retention用于描述注解的生命周期（即：被描述的注解在什么范围内有效），其取值有：\n取值\n描述\nSOURCE\n在源文件中有效（即源文件保留，领盒饭）。\nCLASS\n在class文件中有效（即class保留，领盒饭）。\nRUNTIME\n在运行时有效（即运行时保留）。\n \n根据上述介绍，如果我需要定义一个用于对方法进行描述，且能在运行时可以读取到的自定义注解（假定我希望这个注解的名字是Sample）。那么，我就应该这样：\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface Sample {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String value() default &quot;&quot;;\n}\n \nOK，自定义注解已经写好了，那我们就可以在代码中使用这个注解了，如：\n@Sample(value=&quot;I\'m here.&quot;)\npublic void anyName() {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... ...\n}\n \n值得一提的是，在网上能搜索到的资料（中文的）几乎都是到此为止了。给人的感觉就像看美国大片，每到结束的时候总会给你一种未完待续的意味。事实上，我能容忍电影给我这样的感觉，因为这样会让我充满期待。而从技术的角度来说，我很厌恶这种感觉。\n \n事实上，事情远没有结束。如果自定义注解以这样的形式存在，那么这种存在是没有任何实际意义的。\n \n那么，我们接下来该做什么呢？\n接下来我们应该编写自己的注解处理器。\n \n嗯，再啰嗦一下，提到注解处理器，我又被N多资料误导了。很多资料都提到APT，或者AbstractProcessor。但事实上，我的理解是APT或者AbstractProcessor更多的用于：在非运行时进行增强处理（如：分析逻辑BUG，分析代码结构等等）。\n \n回到注解处理器，注释处理器其实就是一段用于解释或处理自定义注解的代码而已，没有太多复杂的概念或者技术（嗯，先卖个关子，后面的实例会细说注解处理器的）。\n \n⊃2; &nbsp;实践\n通过前文对自定义注解的了解，我猜想我应该这样做：\n1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合实际需求规划注解的功能，以及定义如何解析注解\n先说说我的需求吧：框架会把页面划分成N个分块，而每个分块都需要不同的类来处理输出内容，处理到不同的分块是，框架会自动创建对应的类实例（目前为止，没有任何问题）。接下来的问题就来了，每个分块处理类处理分块内容时，所需要的参数是不一样的（参数类型以及参数个数都不一样）；因此，也不好定义一个固定的接口。当然，肯定有人会说可以把参数改成map，或Object数组。是的，这是一种解决办法，但是如果我用自定义注解，会不会能更好的完成这项工作呢？是的，答案在你我心中。\n \n我们不妨设想一下：\n如果处理类需要获取参数，那么这个处理类就给我注解某个方法（方法名任意，前文提到过：虚拟机会做好二者之间的关联），以说明该方法需要被框架预先调用一次（类似初始化方法）。同样的道理，在注解这个方法时，加入所需要的参数注解。\n然后，在框架的处理程序中，我们先根据注解查找方法，如果该方法存在，则再次根据注解把对应的参数准备好，然后反射调用invoke方法。\nOK，这样的设想应该是行得通的。\n \n2. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义并构造自定义注解\n前文提到了我们需要对方法进行注解，而且注解中还需要包含参数信息。好吧，我的设想是定义两个注解：\n@RenderParameter用于描述方法的参数，包括参数类型、参数来源等。\n@RenderMethod用于描述方法（主要描述方法的参数列表）。\n \n这里要提到一个小技巧：即注解可以使用数组（嗯嗯，待会会看到的）。\n \n先来定义一下@RenderParameter吧：\n… …\n \n@Retention(RetentionPolicy.RUNTIME) // 运行时保留\n@Target({ElementType.METHOD}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 注解对象为方法\npublic @interface RenderParameter {\n \n// 参数类型\npublic enum ParameterType { STRING, SHORT, INT, BOOL, LONG, OBJECT };\n// 参数值的来源\npublic enum ScopeType { NORMAL, SESSION, COOKIE, ATTRIBUTE, CUSTOM };\n \npublic String name(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数名\npublic boolean ignoreCase() default false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 匹配时是否忽略大小写\npublic ParameterType type() default ParameterType.STRING; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数类型\npublic ScopeType scope() default ScopeType.NORMAL; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数值来源\n \n}\n \n再看看@RenderMethod的定义：\n… …\n \n@Retention(RetentionPolicy.RUNTIME) // 运行时保留\n@Target({ElementType.METHOD}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 注解对象为方法\npublic @interface RenderMethod {\n \npublic enum MethodType { INQUIRE };\n \npublic MethodType method() default MethodType.INQUIRE;\npublic RenderParameter[] parameters(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数列表\n \n}\n \n至此，两个自定义注解已经完成，看看我应该如何使用他们：\n@RenderMethod(parameters={@RenderParameter(name=&quot;logined&quot;, scope=ScopeType.SESSION),@RenderParameter(name=&quot;loginedUser&quot;, scope=ScopeType.SESSION)})\npublic void inquire(String logined, String loginedUser) {\nif(&quot;true&quot;.equals(logined)) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(loginedUser + &quot; is logined.&quot;);\n} else {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;No user logined.&quot;);\n}\n}\n \n3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造自定义注解的处理方法（即注解处理器）\n终于又说到注解处理器了，其实很简单：\n… …\n// 此处的renderer就是采用了自定义注解的类实例\nfor(Method method : renderer.getClass().getDeclaredMethods()) {\nRenderMethod rm = (RenderMethod)method.getAnnotation(RenderMethod.class);\n \nif(rm != null) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length = rm.parameters().length;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object[] parameters = length &gt; 0 ? buildParameters(rm.parameters()) : null;\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method.invoke(renderer, parameters);\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (IllegalArgumentException e) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage());\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (IllegalAccessException e) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage());\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (InvocationTargetException e) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage());\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n}\n}\n… …\n \n// 根据注解数组创建参数对象列表，供invoke使用\nprivate Object[] buildParameters(RenderParameter[] parameters) {\nObject[] objs = new Object[parameters.length];\nint i = 0;\n \nfor(RenderParameter parameter : parameters) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ScopeType scope = parameter.scope();\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数值来自request.getParameter\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(scope == ScopeType.NORMAL) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String temp = request.getParameter(parameter.name());\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String value = null;\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(temp != null &amp;&amp; !&quot;&quot;.equals(temp)) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] bytes = temp.getBytes(&quot;iso-8859-1&quot;);\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = new String(bytes, &quot;UTF-8&quot;);\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (UnsupportedEncodingException e) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage());\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objs[i ++] = value;\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数值来自Session\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if(scope == ScopeType.SESSION) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objs[i ++] = request.getSession().getAttribute(parameter.name());\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数值来自Cookie\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if(scope == ScopeType.COOKIE) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(Cookie cookie : request.getCookies()) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cookie.getName().equals(parameter.name())) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objs[i ++] = cookie.getValue();\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n \n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数值来自request. getAttribute\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if(scope == ScopeType.ATTRIBUTE) {\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objs[i ++] = request.getAttribute(parameter.name());\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n \nreturn objs;\n}\n \n \n⊃2; &nbsp;参考\n1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《java编程思想》\n2. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《深入理解java虚拟机》\n原文：http://blog.csdn.net/lonely001/article/details/6722433 \n        ', null);
INSERT INTO `blog` VALUES ('66', 'mysql性能优化的最佳20+条经验', '\n             &nbsp;&nbsp;\n今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。1. 为查询缓存优化你的查询\n大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。\n这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：\n// 查询缓存不开启\n$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= CURDATE()&quot;);\n \n// 开启查询缓存\n$today = date(&quot;Y-m-d&quot;);\n$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= \'$today\'&quot;);\n上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。\n2. EXPLAIN 你的 SELECT 查询\n使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。\nEXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。\n挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：\n\n当我们为 group_id 字段加上索引后：\n\n我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。3. 当只要一行数据时使用 LIMIT 1\n当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。\n在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。\n下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）\n// 没有效率的：\n$r = mysql_query(&quot;SELECT * FROM user WHERE country = \'China\'&quot;);\nif (mysql_num_rows($r) &gt; 0) {\n    // ...\n}\n \n// 有效率的：\n$r = mysql_query(&quot;SELECT 1 FROM user WHERE country = \'China\' LIMIT 1&quot;);\nif (mysql_num_rows($r) &gt; 0) {\n    // ...\n}4. 为搜索字段建索引\n索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。\n\n从上图你可以看到那个搜索字串 “last_name LIKE ‘a%’”，一个是建了索引，一个是没有索引，性能差了4倍左右。\n另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用MySQL全文索引 或是自己做一个索引（比如说：搜索关键词或是Tag什么的）5. 在Join表的时候使用相当类型的例，并将其索引\n如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）\n// 在state中查找company\n$r = mysql_query(&quot;SELECT company_name FROM users\n    LEFT JOIN companies ON (users.state = companies.state)\n    WHERE users.id = $user_id&quot;);\n \n// 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。6. 千万不要 ORDER BY RAND()\n想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。\n如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）\n下面的示例是随机挑一条记录\n// 千万不要这样做：\n$r = mysql_query(&quot;SELECT username FROM user ORDER BY RAND() LIMIT 1&quot;);\n \n// 这要会更好：\n$r = mysql_query(&quot;SELECT count(*) FROM user&quot;);\n$d = mysql_fetch_row($r);\n$rand = mt_rand(0,$d[0] - 1);\n \n$r = mysql_query(&quot;SELECT username FROM user LIMIT $rand, 1&quot;);7. 避免 SELECT *\n从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。\n所以，你应该养成一个需要什么就取什么的好的习惯。\n// 不推荐\n$r = mysql_query(&quot;SELECT * FROM user WHERE user_id = 1&quot;);\n$d = mysql_fetch_assoc($r);\necho &quot;Welcome {$d[\'username\']}&quot;;\n \n// 推荐\n$r = mysql_query(&quot;SELECT username FROM user WHERE user_id = 1&quot;);\n$d = mysql_fetch_assoc($r);\necho &quot;Welcome {$d[\'username\']}&quot;;8. 永远为每张表设置一个ID\n我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。\n就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。\n而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……\n在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。9. 使用 ENUM 而不是 VARCHAR\nENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。\n如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。\nMySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。10. 从 PROCEDURE ANALYSE() 取得建议\nPROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。\n例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。\n在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议\n\n一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。11. 尽可能的使用 NOT NULL\n除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。\n首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)\n不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。\n下面摘自MySQL自己的文档：\n\n “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”\n12. Prepared Statements\nPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。\nPrepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。\n在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。\n虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。\n当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。\n在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展 或是使用数据库抽象层，如： PDO.\n// 创建 prepared statement\nif ($stmt = $mysqli-&gt;prepare(&quot;SELECT username FROM user WHERE state=?&quot;)) {\n \n    // 绑定参数\n    $stmt-&gt;bind_param(&quot;s&quot;, $state);\n \n    // 执行\n    $stmt-&gt;execute();\n \n    // 绑定结果\n    $stmt-&gt;bind_result($username);\n \n    // 移动游标\n    $stmt-&gt;fetch();\n \n    printf(&quot;%s is from %s\\n&quot;, $username, $state);\n \n    $stmt-&gt;close();\n}13. 无缓冲的查询\n正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。\n关于这个事情，在PHP的文档中有一个非常不错的说明： mysql_unbuffered_query() 函数：\n\n “mysql_unbuffered_query() sends the SQL query query to MySQL without automatically fetching and buffering the result rows as mysql_query() does. This saves a considerable amount of memory with SQL queries that produce large result sets, and you can start working on the result set immediately after the first row has been retrieved as you don’t have to wait until the complete SQL query has been performed.”\n\n上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。\n然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用mysql_free_result() 清除结果。而且， mysql_num_rows() 或 mysql_data_seek() 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。14. 把IP地址存成 UNSIGNED INT\n很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。\n我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。\n而你的查询，你可以使用 INET_ATON() 来把一个字符串IP转成一个整形，并使用 INET_NTOA() 把一个整形转成一个字符串IP。在PHP中，也有这样的函数 ip2long() 和 long2ip()。\n$r = &quot;UPDATE users SET ip = INET_ATON(\'{$_SERVER[\'REMOTE_ADDR\']}\') WHERE user_id = $user_id&quot;;15. 固定长度的表会更快\n如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。\n固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。\n并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。\n使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。16. 垂直分割\n“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）\n示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。\n示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。\n另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。17. 拆分大的 DELETE 或 INSERT 语句\n如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。\nApache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。\n如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。\n所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：\nwhile (1) {\n    //每次只做1000条\n    mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= \'2009-11-01\' LIMIT 1000&quot;);\n    if (mysql_affected_rows() == 0) {\n        // 没得可删了，退出！\n        break;\n    }\n    // 每次都要休息一会儿\n    usleep(50000);\n}18. 越小的列会越快\n对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。\n参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。\n如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。\n当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。19. 选择正确的存储引擎\n在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。\nMyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。\nInnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。\n下面是MySQL的手册\n\n target=”_blank”MyISAM Storage Engine\n InnoDB Storage Engine\n20. 使用一个对象关系映射器（Object Relational Mapper）\n使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。\nORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。\nORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。\n目前，个人最喜欢的PHP的ORM是：Doctrine。21. 小心“永久链接”\n“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。\n\n PHP手册：mysql_pconnect()\n\n在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。\n而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。\n文章：来源\n（全文完）原文：http://coolshell.cn/articles/1846.html\n        ', null);
INSERT INTO `blog` VALUES ('67', 'javascript 中 prototype 的用法', '\n            \n \n\nprototype 是在 IE 4 及其以后版本引入的一个针对于某一类的对象的方法，而且特殊的地方便在于：它是一个给类的对象添加方法的方法！这一点可能听起来会有点乱，别急，下面我便通过实例对这一特殊的方法作已下讲解：\n\n\n　　首先，我们要先了解一下类的概念，JavaScript 本身是一种面向对象的语言，它所涉及的元素根据其属性的不同都依附于某一个特定的类。我们所常见的类包括：数组变量(Array)、逻辑变量(Boolean)、日期变量(Date)、结构变量(Function)、数值变量(Number)、对象变量(Object)、字符串变量(String) 等，而相关的类的方法，也是程序员经常用到的（在这里要区分一下类的注意和属性发方法），例如数组的push方法、日期的get系列方法、字符串的split方法等等，\n\n\n　　但是在实际的编程过程中不知道有没有感觉到现有方法的不足？prototype 方法应运而生！下面，将通过实例由浅入深讲解 prototype 的具体使用方法：\n\n\n\n1、最简单的例子，了解 prototype：\n\n(1) Number.add(num)：作用，数字相加\n\n实现方法：Number.prototype.add = function(num){return(this+num);}\n\n试验：alert((3).add(15)) -&gt; 显示 18\n\n\n\n(2) Boolean.rev(): 作用，布尔变量取反\n\n实现方法：Boolean.prototype.rev = function(){return(!this);}\n\n试验：alert((true).rev()) -&gt; 显示 false\n\n\n是不是很简单？这一节仅仅是告诉读者又这么一种方法，这种方法是这样运用的。\n\n\n\n2、已有方法的实现和增强，初识 prototype：\n\n(1) Array.push(new_element)\n\n　　作用：在数组末尾加入一个新的元素\n\n　　实现方法：\n\n　　Array.prototype.push = function(new_element){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this[this.length]=new_element;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.length;\n\n&nbsp;&nbsp;&nbsp;&nbsp; }\n\n　　让我们进一步来增强他，让他可以一次增加多个元素！\n\n　　实现方法：\n\n　　Array.prototype.pushPro = function() {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var currentLength = this.length;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (var i = 0; i &lt; arguments.length; i++) {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this[currentLength + i] = arguments[i];\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.length;\n\n&nbsp;&nbsp;&nbsp;&nbsp; }\n\n　　应该不难看懂吧？以此类推，你可以考虑一下如何通过增强 Array.pop 来实现删除任意位置，任意多个元素（具体代码就不再细说了）\n\n\n(2) String.length\n\n　　作用：这实际上是 String 类的一个属性，但是由于 JavaScript 将全角、半角均视为是一个字符，在一些实际运用中可能会造成一定的问题，现在我们通过 prototype 来弥补这部不足。\n\n　　实现方法：\n\n　　String.prototype.cnLength = function(){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var arr=this.match(/[^\\x00-\\xff]/ig);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.length+(arr==null?0:arr.length);\n\n&nbsp;&nbsp;&nbsp;&nbsp; }\n\n　　试验：alert(&quot;EaseWe空间Spaces&quot;.cnLength()) -&gt; 显示 16\n\n　　这里用到了一些正则表达式的方法和全角字符的编码原理，由于属于另两个比较大的类别，本文不加说明，请参考相关材料。\n\n\n\n3、新功能的实现，深入 prototype：在实际编程中所用到的肯定不只是已有方法的增强，更多的实行的功能的要求，下面我就举两个用 prototype 解决实际问题的例子：\n\n(1) String.left()\n\n　　问题：用过 vb 的应该都知道left函数，从字符串左边取 n 个字符，但是不足是将全角、半角均视为是一个字符，造成在中英文混排的版面中不能截取等长的字符串\n\n　　作用：从字符串左边截取 n 个字符，并支持全角半角字符的区分\n\n　　实现方法：\n\n　　String.prototype.left = function(num,mode){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!/\\d+/.test(num))return(this);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var str = this.substr(0,num);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!mode) return str;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var n = str.Tlength() - str.length;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num = num - parseInt(n/2);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.substr(0,num);\n\n&nbsp;&nbsp;&nbsp;&nbsp; }\n\n　　试验：\n\n&nbsp;&nbsp;&nbsp;&nbsp; alert(&quot;EaseWe空间Spaces&quot;.left(8)) -&gt; 显示 EaseWe空间\n\n&nbsp;&nbsp;&nbsp;&nbsp; alert(&quot;EaseWe空间Spaces&quot;.left(8,true)) -&gt; 显示 EaseWe空\n\n　　本方法用到了上面所提到的String.Tlength()方法，自定义方法之间也能组合出一些不错的新方法呀！\n\n\n(2) Date.DayDiff()\n\n　　作用：计算出两个日期型变量的间隔时间（年、月、日、周）\n\n　　实现方法：\n\n　　Date.prototype.DayDiff = function(cDate,mode){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDate.getYear();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(e){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var base =60*60*24*1000;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var result = Math.abs(this - cDate);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(mode){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &quot;y&quot;:\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result/=base*365;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &quot;m&quot;:\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result/=base*365/12;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &quot;w&quot;:\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result/=base*7;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result/=base;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(Math.floor(result));\n\n&nbsp;&nbsp;&nbsp;&nbsp; }\n\n　　试验：alert((new Date()).DayDiff((new Date(2002,0,1)))) -&gt; 显示 329\n\n&nbsp;&nbsp;&nbsp;&nbsp; alert((new Date()).DayDiff((new Date(2002,0,1)),&quot;m&quot;)) -&gt; 显示 10\n\n　　当然，也可以进一步扩充，得出响应的小时、分钟，甚至是秒。\n\n\n(3) Number.fact()\n\n　　作用：某一数字的阶乘\n\n　　实现方法：\n\n　　Number.prototype.fact=function(){\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var num = Math.floor(this);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(num&lt;0)return NaN;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(num==0 || num==1)\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (num*(num-1).fact());\n\n&nbsp;&nbsp;&nbsp;&nbsp; }\n\n　　试验：alert((4).fact()) -&gt; 显示 24\n\n　　这个方法主要是说明了递归的方法在 prototype 方法中也是可行的！&nbsp;\n\n原文：\nhttp://hi.baidu.com/3seefans/blog/item/1761b3f56ed3d02fbc3109e4.html\n\n        ', null);
INSERT INTO `blog` VALUES ('68', '周末', '\n            \n \n看看空间里以前的照片，挺怀念以前的日子的，无论是高中，抑或是大学，更多的，是那些人儿。\n\n        ', null);
INSERT INTO `blog` VALUES ('69', 'jqPlot的Option配置对象详解', '\n            原文：http://blog.csdn.net/gaoyusi4964238/article/details/4378459 \n 如果看过本文姊妹篇《 jqPlot——基于jquery的图表绘制工具》的朋友，应该知道jqPlot大致的操作方法；如果还是不太清楚的话，可以参考jqPlot官方网站的 使用方法介绍。这里主要介绍jqPlot中核心部分——Option配置对象。同时，也会对jqplot的各个渲染器做个简单介绍。\n \n &nbsp;&nbsp;&nbsp;&nbsp;这里主要是参考jqPlot官方网站关于Option的介绍并结自己简单实践和理解来对Option的相关属性进行解释，如有不合适或错误的地方请指正。\n\n\n\n\n\n options = &nbsp;&nbsp;\n { &nbsp;\n  &nbsp;&nbsp;&nbsp;seriesColors: [ &quot;#4bb2c5&quot;, &quot;#c5b47f&quot;, &quot;#EAA228&quot;, &quot;#579575&quot;, &quot;#839557&quot;, &quot;#958c12&quot;, &nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;#953579&quot;, &quot;#4b5de4&quot;, &quot;#d8b83f&quot;, &quot;#ff5800&quot;, &quot;#0085cc&quot;], &nbsp;// 默认显示的分类颜色， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果分类的数量超过这里的颜色数量，则从该队列中第一个位置开始重新取值赋给相应的分类 &nbsp;\n  &nbsp;&nbsp;&nbsp;stackSeries: false, // 如果置为true并且有多个分类（如果是折线图，就必须多于一条折线）， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 那么每个分类（折线）在纵轴上的值为其前所有分类纵轴值总和与其纵 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//轴值相加值（eg,当前分类纵轴值为Y3 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//，其前有Y2,Y1，那么他显示在Y轴上值为Y2+Y3+Y1,目前该属性支持线图和柱状图 &nbsp;\n  &nbsp;&nbsp;&nbsp;title: \'\', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置当前图的标题 &nbsp;\n  &nbsp;&nbsp;&nbsp;title: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: \'\', &nbsp;&nbsp;// 设置当前图的标题 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: true,//设置当前标题是否显示 &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;axisDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: false, &nbsp;&nbsp;&nbsp;// wether or not to renderer the axis. &nbsp;Determined automatically. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min: null, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 横（纵）坐标显示的最小值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max: null, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 横（纵）坐标显示的最大值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pad: 1.2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 一个相乘因子， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//（数据在横（纵）轴上最大值-数据在横（纵）轴上最小值）*pad值=该轴显示的横（纵）坐标区间长度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 该轴显示的横（纵）坐标区间长度=横（纵）坐标显示的最大值-横（纵）坐标显示的最小值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果设置了max和min的值的话，那么会优先考虑min和max设置的值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ticks: [], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置横（纵）坐标的刻度上的值，可为该ticks数组中的值， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a 1D [val1, val2, ...], or 2D [[val, label], [val, label], ...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberTicks: undefined, &nbsp;//一个相除因子，用于设置横（纵）坐标刻度间隔 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//横（纵）坐标刻度间隔值=横（纵）坐标区间长度/(numberTicks-1) &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tickInterval:\'\', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//横（纵）坐标刻度间隔值，可为日期字符串 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderer: $.jqplot.LinearAxisRenderer, &nbsp;// 设置横（纵）轴上数据加载的渲染器,有dateAxisRenderer（参见本文最后相关介绍） 。 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rendererOptions: {}, &nbsp;&nbsp;&nbsp;// 设置renderer的Option配置对象，线状图不需要设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不同图表的Option配置对象请参见下面《jqPlot各个不同插件的Option对象设置》 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//中各个图表的配置Option对象 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tickOptions: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark: \'outside\', &nbsp;&nbsp;&nbsp;// 设置横（纵）坐标刻度在坐标轴上显示方式，分为坐标轴内，外，穿过坐标轴显示 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 值也分为：\'outside\', \'inside\' 和 \'cross\', &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMark: true, &nbsp;&nbsp;&nbsp;&nbsp;//设置是否显示刻度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showGridLine: true, // 是否在图表区域显示刻度值方向的网格线 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markSize: 4, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 每个刻度线顶点距刻度线在坐标轴上点距离（像素为单位） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果mark值为 \'cross\', 那么每个刻度线都有上顶点和下顶点，刻度线与坐标轴 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在刻度线中间交叉，那么这时这个距离&times;2, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否显示刻度线，与刻度线同方向的网格线，以及坐标轴上的刻度值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showLabel: true, &nbsp;&nbsp;&nbsp;// 是否显示刻度线以及坐标轴上的刻度值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatString: \'\', &nbsp;&nbsp;// 梃置坐标轴上刻度值显示格式，eg:\'%b %#d, %Y\'表示格式&quot;月 日，年&quot;，&quot;AUG 30,2008&quot; &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontSize:\'10px\', &nbsp;&nbsp;&nbsp;//刻度值的字体大小 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontFamily:\'Tahoma\', //刻度值上字体 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle:40, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//刻度值与坐标轴夹角，角度为坐标轴正向顺时针方向 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontWeight:\'normal\', //字体的粗细 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontStretch:1//刻度值在所在方向（坐标轴外）上的伸展(拉伸)度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTicks: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/// 是否显示刻度线以及坐标轴上的刻度值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTickMarks: true, &nbsp;&nbsp;&nbsp;//设置是否显示刻度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useSeriesColor: true &nbsp;&nbsp;&nbsp;&nbsp;//如果有多个纵（横）坐标轴，通过该属性设置这些坐标轴是否以不同颜色显示 &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;axes: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaxis: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置同 axisDefaults &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yaxis: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置同 axisDefaults &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x2axis: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置同 axisDefaults &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y2axis: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置同 axisDefaults &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;seriesDefaults: {//如果有多个分类，这可通过该配置属性设置各个分类的共性属性 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: true, &nbsp;&nbsp;&nbsp;&nbsp;// 设置是否渲染整个图表区域（即显示图表中内容） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaxis: \'xaxis\', // either \'xaxis\' or \'x2axis\'. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yaxis: \'yaxis\', // either \'yaxis\' or \'y2axis\'. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label: \'\', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 用于显示在分类名称框中的分类名称 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: \'\', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 分类在图标中表示（折现，柱状图等）的颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineWidth: 2.5, // 分类图（特别是折线图）哪宽度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow: true, &nbsp;&nbsp;// 各图在图表中是否显示阴影区域 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAngle: 45, &nbsp;&nbsp;&nbsp;// 参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowOffset: 1.25, // 参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowDepth: 3, &nbsp;&nbsp;&nbsp;&nbsp;// 参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAlpha: 0.1, &nbsp;&nbsp;// 参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showLine: true, &nbsp;&nbsp;&nbsp;&nbsp;//是否显示图表中的折线（折线图中的折线） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMarker: true, &nbsp;&nbsp;// 是否强调显示图中的数据节点 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill: false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否填充图表中折线下面的区域（填充颜色同折线颜色）以及legend &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置的分类名称框中分类的颜色，此处注意的是如果fill为true， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//那么showLine必须为true，否则不会显示效果 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fillAndStroke: false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在fill为true的状态下，在填充区域最上面显示一条线（如果是折线图则显示该折线） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fillColor: undefined, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置填充区域的颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fillAlpha: undefined, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 梃置填充区域的透明度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderer: $.jqplot.PieRenderer, &nbsp;// 利用渲染器（这里是利用饼图PieRenderer）渲染现有图表 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//，从而转换成所需图表 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rendererOptions: {}, // 传给上个属性所设置渲染器的option对象，线状图的渲染器没有option对象， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不同图表的Option配置对象请参见下面《jqPlot各个不同插件的Option对象设置》 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//中各个图表的配置Option对象 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markerRenderer: $.jqplot.MarkerRenderer, &nbsp;&nbsp;&nbsp;// renderer to use to draw the data  &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// point markers. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markerOptions: { &nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否在图中显示数据点 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style: \'filledCircle\', &nbsp;// 各个数据点在图中显示的方式，默认是&quot;filledCircle&quot;(实心圆点), &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//其他几种方式circle，diamond, square, filledCircle， &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// filledDiamond or filledSquare. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineWidth: 2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 数据点各个的边的宽度（如果设置过大，各个边会重复，会显示的类似于实心点） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size: 9, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 数据点的大小 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: \'#666666\' &nbsp;&nbsp;&nbsp;// 数据点的颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否为数据点显示阴影区（增加立体效果） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAngle: 45, &nbsp;&nbsp;&nbsp;// 阴影区角度，x轴顺时针方向 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowOffset: 1, &nbsp;&nbsp;&nbsp;// 参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowDepth: 3, &nbsp;&nbsp;&nbsp;&nbsp;//参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAlpha: 0.07 &nbsp;&nbsp;// 参考grid中相同参数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDragable: true,//是否允许拖动（如果dragable包已引入）,默认可拖动 &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;series:[//如果有多个分类需要显示，这在此处设置各个分类的相关配置属性 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//eg.设置各个分类在分类名称框中的分类名称 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//[label: \'Traps Division\'},{label: \'Decoy Division\'},{label: \'Harmony Division\'}] &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//配置参数设置同seriesDefaults &nbsp;\n  &nbsp;&nbsp;&nbsp;], &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;legend: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: false,//设置是否出现分类名称框（即所有分类的名称出现在图的某个位置） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location: \'ne\', &nbsp;&nbsp;&nbsp;&nbsp;// 分类名称框出现位置, nw, n, ne, e, se, s, sw, w. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xoffset: 12, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 分类名称框距图表区域上边框的距离（单位px） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yoffset: 12, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 分类名称框距图表区域左边框的距离(单位px) &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:\'\' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分类名称框距图表区域背景色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textColor:\'\' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分类名称框距图表区域内字体颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..其他关于样式设计参考官方文档 &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;grid: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawGridLines: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// wether to draw lines across the grid or not. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridLineColor: \'#cccccc\' &nbsp;&nbsp;&nbsp;// 设置整个图标区域网格背景线的颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background: \'#fffdf6\', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置整个图表区域的背景色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;borderColor: \'#999999\', &nbsp;&nbsp;&nbsp;&nbsp;// 设置图表的(最外侧)边框的颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;borderWidth: 2.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置图表的（最外侧）边框宽度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 为整个图标（最外侧）边框设置阴影，以突出其立体效果 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAngle: 45, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置阴影区域的角度，从x轴顺时针方向旋转 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowOffset: 1.5, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置阴影区域偏移出图片边框的距离 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowWidth: 3, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置阴影区域的宽度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowDepth: 3, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置影音区域重叠阴影的数量 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAlpha: 0.07 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置阴影区域的透明度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderer: $.jqplot.CanvasGridRenderer, &nbsp;// renderer to use to draw the grid. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rendererOptions: {} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// options to pass to the renderer. &nbsp;Note, the default &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// CanvasGridRenderer takes no additional options. &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;/************************jqPlot各个不同插件的Option对象设置******************************/ &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;// BarRenderer（设置柱状图的Option对象） &nbsp;\n  &nbsp;&nbsp;&nbsp;//该Option对象适用与柱状图的series和seriesDefault属性的相关配置对象设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;seriesDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rendererOptions: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barPadding: 8, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置同一分类两个柱状条之间的距离（px） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barMargin: 10, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置不同分类的两个柱状条之间的距离（px）（同一个横坐标表点上） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barDirection: \'vertical\', //设置柱状图显示的方向：垂直显示和水平显示 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//，默认垂直显示 vertical or horizontal. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barWidth: null, &nbsp;&nbsp;&nbsp;&nbsp;// 设置柱状图中每个柱状条的宽度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowOffset: 2, &nbsp;&nbsp;&nbsp;// 同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowDepth: 5, &nbsp;&nbsp;&nbsp;&nbsp;// 同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAlpha: 0.8, &nbsp;&nbsp;// 同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;// Cursor(光标) &nbsp;\n  &nbsp;&nbsp;&nbsp;// 鼠标移动到图中时，鼠标在图中显示形式，常与和高亮功能同时使用 &nbsp;\n  &nbsp;&nbsp;&nbsp;//此外，通过设置该属性的zoom相关属性来对图中某个区域钻取（就选定区域放大） &nbsp;\n  &nbsp;&nbsp;&nbsp;//该配置对象直接在option下配置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;cursor: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style: \'crosshair\', &nbsp;&nbsp;&nbsp;&nbsp;//当鼠标移动到图片上时，鼠标的显示样式，该属性值为css类 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//是否显示光标 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTooltip: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否显示提示信息栏 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;followMouse: false, &nbsp;&nbsp;&nbsp;&nbsp;//光标的提示信息栏是否随光标（鼠标）一起移动 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipLocation: \'se\', &nbsp;// 光标提示信息栏的位置设置。如果followMouse=true,那么该位置为 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//提示信息栏相对于光标的位置。否则，为光标提示信息栏在图标中的位置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 该属性可选值： n, ne, e, se, etc. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipOffset: 6, &nbsp;&nbsp;&nbsp;&nbsp;//提示信息栏距鼠标(followMouse=true)或坐标轴（followMouse=false）的位置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTooltipGridPosition: false,//是否在信息提示栏中显示光标位置（取其据图标左和上边缘线像素距离） &nbsp;&nbsp; &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTooltipUnitPosition: true,// 是否显示提示光标所在位置（取其在横纵轴上数据值）的信息栏 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//注：注意此处与showTooltipGridPosition值区别，前者显示坐标值，该处显示的是数据值 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipFormatString: \'%.4P\', &nbsp;&nbsp;&nbsp;// 同Highlighter的tooltipFormatString &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useAxesFormatters: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 同Highlighter的tooltipFormatString &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipAxesGroups: [], &nbsp;// show only specified axes groups in tooltip. &nbsp;Would specify like: &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [[\'xaxis\', \'yaxis\'], [\'xaxis\', \'y2axis\']]. &nbsp;By default, all axes &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// combinations with for the series in the plot are shown. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;// Dragable（拖动） &nbsp;\n  &nbsp;&nbsp;&nbsp;//该配置对象通过seriesDefaults和series配置对象进行配置 &nbsp;\n  &nbsp;&nbsp;&nbsp;seriesDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;dragable: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: undefined, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当拖动数据点是，拖动线与拖动数据点颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constrainTo: \'none\', &nbsp;&nbsp;&nbsp;//设置拖动的的范围: \'x\'（只能在横向上拖动）, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// \'y\'（只能在纵向上拖动）, or \'none\'（无限制）. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;// Highlighter（高亮） &nbsp;\n  &nbsp;&nbsp;&nbsp;//设置高亮动作option属性对象 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;//鼠标移动到某个数据点上时，该数据点增大并显示提示信息框 &nbsp;\n  &nbsp;&nbsp;&nbsp;//该配置对象直接在option下配置 &nbsp;&nbsp;&nbsp; &nbsp;\n  &nbsp;&nbsp;&nbsp;highlighter: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineWidthAdjust: 2.5, &nbsp;&nbsp;//当鼠标移动到放大的数据点上时，设置增大的数据点的宽度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 目前仅适用于非实心数据点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeAdjust: 5, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当鼠标移动到数据点上时，数据点扩大的增量增量 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTooltip: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否显示提示信息栏 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipLocation: \'nw\', &nbsp;// 提示信息显示位置（英文方向的首写字母）: n, ne, e, se, s, sw, w, nw. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fadeTooltip: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置提示信息栏出现和消失的方式（是否淡入淡出） &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipFadeSpeed: &quot;fast&quot;//设置提示信息栏淡入淡出的速度： slow, def, fast, 或者是一个毫秒数的值. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipOffset: 2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 提示信息栏据被高亮显示的数据点的偏移位置，以像素计。 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipAxes: \'both\', &nbsp;&nbsp;&nbsp;// 提示信息框显示数据点那个坐标轴上的值，目前有横/纵/横纵三种方式。 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//值分别为 x, y or xy. &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipSeparator: \', \' &nbsp;// 提示信息栏不同值之间的间隔符号 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useAxesFormatters: true // 提示信息框中数据显示的格式是否和该数据在坐标轴上显示格式一致 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltipFormatString: \'%.5P\' // 用于设置提示信息框中数据显示的格式，前提条件是useAxesFormatters &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 为false. 此时信息提示框中数据格式不再与坐标轴一致，而是以此为准 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//同时，该属性还支持html格式字符串 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//eg:\'&lt;b&gt;&lt;i&gt;&lt;span style=&quot;color:red;&quot; mce_style=&quot;color:red;&quot;&gt;hello&lt;/span&gt;&lt;/i&gt;&lt;/b&gt; %.2f\' &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;// LogAxisRenderer(指数渲染器) &nbsp;\n  &nbsp;&nbsp;&nbsp;// 该渲染器只有两个属性， 指数渲染器通过axesDefaults和axes配置对象进行配置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;axesDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base: 10, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 指数的底数 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tickDistribution: \'even\', &nbsp;&nbsp;// 坐标轴显示方式：\'even\' or \'power\'. &nbsp;\'even\' 产生的是均匀分布于坐标 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//轴上的坐标刻度值 。而\'power\' 则是根据不断增大的增数来确定坐标轴上的刻度 &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;// PieRenderer(设置饼状图的OPtion对象) &nbsp;\n  &nbsp;&nbsp;&nbsp;// 饼状图通过seriesDefaults和series配置对象进行配置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;seriesDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rendererOptions: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diameter: undefined, // 设置饼的直径 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding: 20, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 饼距离其分类名称框或者图表边框的距离，变相该表饼的直径 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sliceMargin: 20, &nbsp;&nbsp;&nbsp;&nbsp;// 饼的每个部分之间的距离 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill:true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 设置饼的每部分被填充的状态 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow:true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//为饼的每个部分的边框设置阴影，以突出其立体效果 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowOffset: 2, &nbsp;&nbsp;&nbsp;//设置阴影区域偏移出饼的每部分边框的距离 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowDepth: 5, &nbsp;&nbsp;&nbsp;&nbsp;// 设置阴影区域的深度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAlpha: 0.07 &nbsp;&nbsp;// 设置阴影区域的透明度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;}, &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;//pointLabels(数据点标签) &nbsp;\n  &nbsp;&nbsp;&nbsp;//用于在数据点所在位置显示相关信息（非提示框性质） &nbsp;\n  &nbsp;&nbsp;&nbsp;seriesDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointLabels: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location:\'s\',//数据标签显示在数据点附近的方位 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ypadding:2 &nbsp;&nbsp;//数据标签距数据点在纵轴方向上的距离 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;// Trendline（趋势线） &nbsp;\n  &nbsp;&nbsp;&nbsp;// 饼状图通过seriesDefaults和series配置对象进行配置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  &nbsp;&nbsp;&nbsp;seriesDefaults: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trendline: { &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 是否显示趋势线 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: \'#666666\', &nbsp;&nbsp;// 趋势线颜色 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label: \'\', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 趋势线名称 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: \'linear\', &nbsp;&nbsp;&nbsp;&nbsp;//趋势线类型\'linear\'（直线）, \'exponential\'（幂值数线） or \'exp\' &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineWidth: 1.5, &nbsp;&nbsp;&nbsp;&nbsp;// 趋势线宽度 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAngle: 45, &nbsp;&nbsp;&nbsp;// &nbsp;同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowOffset: 1.5, &nbsp;// &nbsp;同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowDepth: 3, &nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;同grid相同属性设置 &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadowAlpha: 0.07 &nbsp;&nbsp;// 同grid相同属性设置 &nbsp; &nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;\n  &nbsp;&nbsp;&nbsp;} &nbsp;\n } &nbsp;\n\n\n\n\n相关渲染器介绍 &nbsp;&nbsp;\n\n1.dateAxisRenderer &nbsp;&nbsp;&nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.dateAxisRenderer.min.js&quot; /&gt; &nbsp;&nbsp;&nbsp;该渲染器主要用于显示刻度为日期格式的坐标轴，它增强了javascript的本地数据处理能力，它几乎支持所有的日期格式。 &nbsp;&nbsp;&nbsp;另外，该渲染器还提供了强大的格式化功能，它能将数据中日期字符串格式化为你需要的格式并显示在坐标轴的刻度线上。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.categoryAxisRenderer &nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.categoryAxisRenderer.min.js&quot; /&gt; &nbsp;该渲染器主要用于将显示于刻度处的值显示与两个刻度之间，当然其表达意思也发生变化，因为刻度值处值表示某个点处的值，而它则代表某个范围内的值。 &nbsp;该渲染器比较适合与柱状图联合使用。 &nbsp; &nbsp;3.barRenderer &nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.barRenderer.min.js&quot; /&gt; &nbsp;该渲染器主要用于显示柱状图，该渲染器能够很好的控制每个组（位于一个刻度值处的各个分类）内及组间距离，并且该柱状图能够水平显示。 &nbsp; &nbsp;4.cursor &nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.cursor.min.js&quot; / &nbsp;该渲染器主要用于鼠标移动到图中时，鼠标在图中显示形式，常用与和高亮功能同时使用。 &nbsp;该渲染器相关引用包一旦引用到当前页面会，该渲染器立即生效。 &nbsp; &nbsp;5.highlighter &nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.highlighter.min.js&quot; /&gt; &nbsp;该渲染器主要用于当鼠标移动到图中数据点上时，在鼠标附近显示提示栏，并将相关信息显示在提示栏。默认显示值是横纵坐标轴刻度值。当然，提示框中信息是可以根据自身需要定制的。 &nbsp;&nbsp;该渲染器相关引用包一旦引用到当前页面会，该渲染器立即生效。  &nbsp;&nbsp; &nbsp;&nbsp;6.logAxisRenderer &nbsp;&nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.logAxisRenderer.min.js&quot; /&gt; &nbsp;&nbsp;该渲染器主要用于以指数计算的方式生成坐标轴上刻度值。默认情况下，刻度值是均匀显示的，但是刻度值也可以按指数增长的方式显示。 &nbsp;&nbsp; &nbsp;&nbsp;7.ohlcRenderer &nbsp;&nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.ohlcRenderer.min.js&quot; /&gt; &nbsp;&nbsp;该渲染器主要用于显示甘特图。通常情况下，该渲染器与dateAxisRenderer一起使用较多 &nbsp;&nbsp; &nbsp;&nbsp;8.dragable &nbsp;&nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.dragable.min.js&quot; /&gt; &nbsp;&nbsp;通过该渲染器，用户能够拖动某个数据点，jqplot会自动重画拖动后的新图表。同时，被拖动的数据点的数据值也随着拖动发生变化。 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;9.trendline &nbsp;&nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.trendline.min.js&quot; /&gt; &nbsp;&nbsp;该渲染器主要用于对现有数据进行线性回归计算，并自动将计算结果以趋势线的形式展示出来，当用户拖动某个数据点时，趋势线亦随用户拖动而变化。 &nbsp;&nbsp; &nbsp;&nbsp;10.pointLabels &nbsp;&nbsp;相关引用包：&lt;script type=&quot;text/javascript&quot; src=&quot;../plugins/jqplot.pointLabels.min.js&quot; /&gt; &nbsp;&nbsp;该渲染器主要用于将数据节点相关的的信息以标签的方式放于该数据节点附近；对于相应数据为空的，其标签不显示。\n\n\n        ', null);
INSERT INTO `blog` VALUES ('70', 'IT人不要一直做技术', '\n            \n \n我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己，觉得特别想对那些初学JAVA/DOT。NET技术的朋友说点心里话，希望你们能从我们的体会中，多少受点启发(也许我说的不好，你不赞同但看在我真心的份上别扔砖头啊).\n\n一。 在中国你千万不要因为学习技术就可以换来稳定的生活和高的薪水待遇，你千万更不要认为哪些从事市场开发，跑腿的人，没有前途。不知道你是不是知道，咱们中国有相当大的一部分软件公司，他们的软件开发团队都小的可怜，甚至只有1-3个人，连一个项目小组都算不上，而这样的团队却要承担一个软件公司所有的软件开发任务，在软件上线和开发的关键阶段需要团队的成员没日没夜的加班，还需要为测试出的BUG 和不能按时提交的软件模块功能而心怀忐忑，有的时候如果你不幸加入现场开发的团队你则需要背井离乡告别你的女友，进行封闭开发，你平时除了编码之外就是吃饭和睡觉（有钱的公司甚至请个保姆为你做饭，以让你节省出更多的时间来投入到工作中，让你一直在那种累了就休息，不累就立即工作的状态）更可怕的是，会让你接触的人际关系非常单一，除了有限的技术人员之外你几乎见不到做其他行业工作和职位的人，你的朋友圈子小且单一，甚至破坏你原有的爱情（想象一下，你在外地做现场开发2个月以上，却从没跟女友见过一面的话，你的女友是不是会对你呲牙裂嘴）。也许你拿到了所谓的白领的工资，但你却从此失去享受生活的自由，如果你想做技术人员尤其是开发人员，我想你很快就会理解，你多么想在一个地方长期待一段时间，认识一些朋友，多一些生活时间的愿望。比之于我们的生活和人际关系及工作，那些从事售前和市场开发的朋友，却有比我们多的多的工作之外的时间，甚至他们工作的时间有的时候是和生活的时间是可以兼顾的，他们可以通过市场开发，认识各个行业的人士，可以认识各种各样的朋友，他们比我们坦率说更有发财和发展的机会，只要他们跟我们一样勤奋。（有一种勤奋的普通人，如果给他换个地方，他马上会成为一个勤奋且出众的人。）\n\n二。在学习技术的时候千万不要认为如果做到技术最强，就可以成为100%受尊重的人。有一次一个人在面试项目经理的时候说了这么一段话：我只用最听话的人，按照我的要求做只要是听话就要，如果不听话不管他技术再好也不要。随后这个人得到了试用机会，如果没意外的话，他一定会是下一个项目经理的继任者。朋友们你知道吗？不管你技术有多强，你也不可能自由的腾出时间象别人那样研究一下LINUX源码，甚至写一个LINUX样的杰作来表现你的才能。你需要做的就是按照要求写代码，写代码的含义就是都规定好，你按照规定写，你很快就会发现你昨天写的代码，跟今天写的代码有很多类似，等你写过一段时间的代码，你将领略：复制，拷贝，粘贴那样的技术对你来说是何等重要。（如果你没有做过1年以上的真正意义上的开发不要反驳我）。如果你幸运的能够听到市场人员的谈话，或是领导们的谈话，你会隐约觉得他们都在把技术人员当作编码的机器来看，你的价值并没有你想象的那么重要。而在你所在的团队内部，你可能正在为一个技术问题的讨论再跟同事搞内耗，因为他不服你，你也不服他，你们都认为自己的对，其实你们两个都对，而争论的目的就是为了在关键场合证明一下自己比对方技术好，比对方强。（在一个项目开发中，没有人愿意长期听别人的，总想换个位置领导别人。）\n\n三。你更不要认为，如果我技术够好，我就自己创业，自己有创业的资本，因为自己是搞技术的。如果你那样认为，真的是大错特错了，你可以做个调查在非技术人群中，没有几个人知道C#与JAVA的，更谈不上来欣赏你的技术是好还是不好。一句话，技术仅仅是一个工具，善于运用这个工具为别人干活的人，却往往不太擅长用这个工具来为自己创业，因为这是两个概念，训练的技能也是完全不同的。创业最开始的时候，你的人际关系，你处理人际关系的能力，你对社会潜规则的认识，还有你明白不明白别人的心，你会不会说让人喜欢的话，还有你对自己所提供的服务的策划和推销等等，也许有一万，一百万个值得我们重视的问题，但你会发现技术却很少有可能包含在这一万或一百万之内，如果你创业到了一个快成功的阶段，你会这样告诉自己：我干吗要亲自做技术，我聘一个人不就行了，这时候你才真正会理解技术的作用，和你以前做技术人员的作用。\n\n【小结】\n\n基于上面的讨论，我奉劝那些学习技术的朋友，千万不要拿科举考试样的心态去学习技术,对技术的学习几近的痴迷，想掌握所有所有的技术，以让自己成为技术领域的权威和专家，以在必要的时候或是心里不畅快的时候到网上对着菜鸟说自己是前辈。技术仅仅是一个工具，是你在人生一个阶段生存的工具，你可以一辈子喜欢他，但最好不要一辈子靠它生存。掌握技术的唯一目的就是拿它找工作（如果你不想把技术当作你第二生命的话），就是干活。所以你在学习的时候千万不要去做那些所谓的技术习题或是研究那些帽泡算法，最大数算法了，什么叫干活？就是做一个东西让别人用，别人用了，可以提高他们的工作效率，想象吧，你做1万道技术习题有什么用？只会让人觉得酸腐，还是在学习的时候，多培养些自己务实的态度吧，比如研究一下当地市场目前有哪些软件公司用人，自己离他们的要求到底有多远，自己具体应该怎么做才可以达到他们的要求。等你分析完这些，你就会发现，找工作成功，技术的贡献率其实并没有你原来想象的那么高。不管你是学习技术为了找工作还是创业，你都要对技术本身有个清醒的认识，在中国不会出现BILL GATES，因为，中国目前还不是十分的尊重技术人才，还仅仅的停留在把软件技术人才当作人才机器来用的尴尬境地。（如果你不理解，一种可能是你目前仅仅从事过技术工作，你的朋友圈子里技术类的朋友占了大多数，一种可能是你还没有工作，但喜欢读比尔。盖茨的传记）。\n\n每个项目中都有很多人，当然了，有项目的地方就有人，有人的地方就有利益，有利益的地方就有江湖，有江湖的地方就有女人，有女人就要“带刀”，带刀就要漂泊，漂泊就要一丈见方。\n\n        ', null);
INSERT INTO `blog` VALUES ('71', '数据库联合查询备忘', '\n            我们经常用到2个表的联合查询，有时候用到内连接，全连接，以及左右连接，是不是很复杂呢？下面给演示一下他们的区别\n首先有以下2个表：\nCREATE TABLE weather(&nbsp; city character varying(80) NOT NULL,&nbsp; temp_lo integer NOT NULL,&nbsp; temp_hi integer NOT NULL,&nbsp; prcp real,&nbsp; date date)WITH (&nbsp; OIDS=FALSE);ALTER TABLE weather OWNER TO postgres;\n&nbsp;\n-----------------------------------------------------------\nREATE TABLE cities(&nbsp; &quot;name&quot; character varying(80) NOT NULL,&nbsp; &quot;location&quot; point)WITH (&nbsp; OIDS=FALSE);ALTER TABLE cities OWNER TO postgres;\n让我们想看看里面的数据吧\n&nbsp;\n\n&nbsp;\n下面就开始内连接了。不用太多的说明，看图片就知道怎么回事了\n\n看到了吗，inner 和 select * from weather,cities where city =name 输出一样的，都是一一对应的输出。这个我喜欢！\n&nbsp;\n下面在看看全连接，左右连接的图片\n\n可以看得出来，全连接呢，就是2个表的所有数据都被列举出来，如果他表中没有对于的数据呢，就补空。\n左右连接为全连接的子集（我是这么认为的）左连接以前表为基准，后表没有的数据补控\n右连接已后表为基准，前表没有的就补空。\n\n原文：http://www.cnblogs.com/yongjun-zou/archive/2010/08/22/1805870.html\n        ', null);
INSERT INTO `blog` VALUES ('72', '在JSP配置FCK编辑器', '\n            1. 下载：http://www.fckeditor.net/FCKeditor_2.6.4.zipFCKeditor_N.zip\n2. 解压缩\n3. 把FCKEditor内容导入到项目中把FCKeditor_N.zip中的fckeditor文件夹复制到项目WebRoot中\n4. 在网页上使用FCKEditor4.1 在网面导入javascript\n&lt;script type=&quot;text/javascript&quot; src=&quot;fckeditor/fckeditor.js&quot;&gt;&lt;/script&gt;4.2 在页面上加入下载元素\n&nbsp;&nbsp;&nbsp; &lt;form&gt;&lt;script type=&quot;text/javascript&quot;&gt;var oFCKeditor = new FCKeditor(\'FCKeditor1\');oFCKeditor.BasePath = &quot;&lt;%=basePath%&gt;/fckeditor/&quot;;oFCKeditor.Height=300;oFCKeditor.Width=\'80%\';oFCKeditor.ToolbarSet=\'Default\';oFCKeditor.Create();&lt;/script&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;${param.FCKeditor1 }\n5. 测试通过后进入下一步\n6. 修改工具栏\n通过fckconfig.js实现\n6.1 按钮含义EditSource&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示HTML源代码StrikeThrough 删除线Save&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 保存NewPage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新建空白页面Superscrīpt&nbsp;&nbsp;&nbsp; 上标Subscrīpt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下标Preview&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 预览JustifyLeft&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 左对齐Cut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 剪切Copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 复制Paste&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 粘贴JustifyCenter 居中对齐JustifyRight&nbsp;&nbsp;&nbsp;&nbsp; 右对齐JustifyFull&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两端对齐PasteText&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 纯文本粘贴InsertOrderedList 自动编号PasteWord&nbsp;&nbsp;&nbsp; 来自Word的粘贴InsertUnorderedList 项目符号Print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打印Outdent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 减少缩进SpellCheck 拼写检查Indent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 增加缩进Find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查找ShowTableBorders 显示表格线Replace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 替换ShowDetails 显示明细Undo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 撤销Form&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 添加Form动作Redo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还原Checkbox&nbsp;&nbsp;&nbsp;&nbsp; 复选框SelectAll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 全选Radio&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单选按钮RemoveFormat 去除格式Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单行文本框Link&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 插入/编辑 链接Textarea&nbsp;&nbsp;&nbsp; 滚动文本框RemoveLink 去除连接Select&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下拉菜单Anchor 锚点Button&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 按钮Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 插入/编辑 图片ImageButton 图片按钮Table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 插入/编辑 表格Hidden&nbsp;&nbsp;&nbsp; 隐藏Rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 插入水平线Zoom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示比例SpecialChar 插入特殊字符FontStyleAdv 系统字体UniversalKey 软键盘FontStyle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 字体样式Smiley&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 插入表情符号FontFormat 字体格式About&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关于Font&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 字体Bold&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 粗体FontSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 字体大小Italic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 斜体TextColor&nbsp;&nbsp;&nbsp;&nbsp; 文字颜色Underline&nbsp;&nbsp;&nbsp; 下划线BGColor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 背景色\n6.2 修改\n找开FCKConfig.ToolbarSets大约在118行自己定义一个toolbar复制FCKConfig.ToolbarSets[&quot;Basic&quot;] = [[\'Bold\',\'Italic\',\'-\',\'OrderedList\',\'UnorderedList\',\'-\',\'Link\',\'Unlink\',\'-\',\'About\']] ;把Basic修改为MyToolbar\nFCKConfig.ToolbarSets[&quot;MyToolbar&quot;] = [[\'Bold\',\'Italic\',\'-\',\'OrderedList\',\'UnorderedList\',\'-\',\'Link\',\'Unlink\'],[\'Style\',\'FontFormat\',\'FontName\',\'FontSize\'],[\'TextColor\',\'BGColor\',\'-\',\'Smiley\',\'-\',\'FitWindow\']] ;\n6.3 修改网页文件:\n&lt;form&gt;&lt;script type=&quot;text/javascript&quot;&gt;var oFCKeditor = new FCKeditor(\'FCKeditor1\');oFCKeditor.BasePath = &quot;&lt;%=basePath %&gt;/fckeditor/&quot;;oFCKeditor.Height=300;oFCKeditor.Width=\'80%\';oFCKeditor.ToolbarSet=\'MyToolbar\';oFCKeditor.Create();&lt;/script&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;把Default修改为MyToolbar\n6.4 测试\n&nbsp;7. 汉字字体\n在fckconfig.js中大约 162 行，在前面加上中文字体FCKConfig.FontNames&nbsp;&nbsp; = \'黑体;宋体;隶书;Arial;Comic Sans MS;Courier New;Tahoma;Times New Roman;Verdana\' ;如果显示的是乱的话，把fckeditor.js另存为unicode格式就行了\n8. 修改表情图片在fckconfig.js大约319行找到下几行代码\nFCKConfig.SmileyPath = FCKConfig.BasePath + \'images/smiley/msn/\' ;FCKConfig.SmileyImages = [\'regular_smile.gif\',\'sad_smile.gif\',\'wink_smile.gif\',\'teeth_smile.gif\',\'confused_smile.gif\',\'tounge_smile.gif\',\'embaressed_smile.gif\',\'omg_smile.gif\',\'whatchutalkingabout_smile.gif\',\'angry_smile.gif\',\'angel_smile.gif\',\'shades_smile.gif\',\'devil_smile.gif\',\'cry_smile.gif\',\'lightbulb.gif\',\'thumbs_down.gif\',\'thumbs_up.gif\',\'heart.gif\',\'broken_heart.gif\',\'kiss.gif\',\'envelope.gif\'] ;FCKConfig.SmileyColumns = 8 ;FCKConfig.SmileyWindowWidth&nbsp;&nbsp; = 320 ;FCKConfig.SmileyWindowHeight = 210 ;\n如果要添加新的表情图片，首先将图片复制到指定的目录中,然后在FCKConfig.SmileyImages指定文件名就可以了ortant; zoom: 1 !important; filter: none; font-size: 12px; line-height: normal; color: rgb(88, 95, 87); letter-spacing: 2px; text-align: -webkit-auto;&quot; &gt;\n\n        ', null);
INSERT INTO `blog` VALUES ('73', 'spring mvc源码解析', '\n            \n \n\nhttp://www.iteye.com/topic/87692，在源码中打断点跟着前端页面请求遍历了一遍spring mvc源码，再对着这篇文章看了一遍，头晕晕。。。\n\n        ', null);
INSERT INTO `blog` VALUES ('74', '2012-02-10', '\n            \n \n这几天，因为某种需要，看了之前写的一些东西。 很惭愧。写得相当的绕跟臃肿。绕，我想到一本书：代码简洁之道。臃肿，又让我想起一句话：好的软件不是还能增加什么，而是不能去掉什么。\n在OOP中，我们一直强调对象的职责。但站在更高的角度，软件又何尝不是这样呢？我想没有人看过既能洗衣服又能洗碗的东西。不要想着无所不能，那样往往就是没有一样能。接口需要最小化，软件也是如此。\n不要尝试去写无所不能的软件。最后，反思的问一句：你在OOP吗？\n\n        ', null);
INSERT INTO `blog` VALUES ('75', '给JavaScript初学者的24个小窍门', '\n            \n \n为java script做一点性能小提升吧！本文列出了24条能让你的代码编写过程更为轻松高效的建议。也许您还是java script初学者，刚刚写完自己的Hello World，那这里有很多对您的工作将十分有用的小贴士；也许有些技巧您已经知道，那就试试快速浏览一下，看能不能发现一点...\n1. 用 === 代替 ==java script里有两种不同的相等运算符：===|!== 和==|!=。相比之下，前者更值得推荐。请尽量使用前者。“如果两个比较对象有着同样的类型和值，===返回true，!==返回false。”– java script: The Good Parts不过，如果使用==和!=，在操作不同数据类型时, 你可能会遇到一些意想不到的问题。在进行相等判断前，java script会试图将它们转换为字符串、数字或 Boolean量。2. 避免使用eva l函数eva l函数把一个字串作为参数，并把字串作为java script语句执行，返回结果。此函数不仅会降低你脚本的执行效率，而且还大大增加了安全风险，因为它赋予了作为文本的参数太大的权利。千万别用！3. 不要使用快速写法技术上说，你可以省略掉大部分花括弧和句尾分号，绝大多数浏览器都能正确执行以下语句：\n \n  if(someVariableExists)&nbsp; &nbsp;\n  x&nbsp;=&nbsp;false&nbsp;\n 不过，如果是这样的呢：\n \n  if(someVariableExists)&nbsp; &nbsp;\n  x&nbsp;=&nbsp;false&nbsp;\n  anotherFunctionCall();&nbsp;\n 你可能会认为它和下面的语句相等：\n \n  if(someVariableExists)&nbsp;{&nbsp; &nbsp;\n  x&nbsp;=&nbsp;false;&nbsp; &nbsp;\n  anotherFunctionCall();&nbsp;&nbsp;\n  }\n 不幸的是，事实并非如此。现实情况是它等价于：\n \n  if(someVariableExists)&nbsp;{&nbsp; &nbsp;\n  x&nbsp;=&nbsp;false;&nbsp; &nbsp;\n  }\n  anotherFunctionCall();&nbsp;\n 如您注意到的，再漂亮的缩进也不能代替这华丽的花括弧。在所有情况下都请写清楚花括号和句尾分号。在只有一行语句的时候能偶尔省略掉，虽然下这么做也是极度不被推荐的：\n \n  if(2&nbsp;+&nbsp;2&nbsp;===&nbsp;4)&nbsp;return&nbsp;\'nicely&nbsp;done\';&nbsp;\n 多考虑下将来吧，孩子假设，在将来的开发过程中，你需要为这个 if 语句添加更多的命令呢？到时候你还不是得把括号给加上？4. 好好利用JS LintJS Lint是由 Douglas Crockford 编写的一个调试器。你只需要贴上你的代码，它就能快速为您扫描出任何明显的错误和问题。“JSLint 扫描接收的代码。发现问题，描述问题，并给出其在源码中的大概位置。可发现的问题包括但不限于语法错误，虽然语法错误确实是最常见的。JSLint也会用约定俗成的习惯检查代码的格式化风格，以及结构错误。通过JSLint的扫描并不能保证你的程序就完全正确。它只是为您提供了额外一双发现错误的眼睛。” – JSLint 文档完成代码之前，把它放到JSLint里检查一下，快速消灭你的无心之过。5. 在页面底部加载脚本正如下图所示：&nbsp;请记住—— 我们要千方百计保证客户端的页面载入速度尽可能的快。而脚本没载入完成，浏览器就没法加载页面的剩余部分。如果你的JS文件只是添加一些额外功能——例如，为点击某链接绑定事件——那大可以等页面加载基本完成后再做。把JS文件放到页面最后，body的结束标签之前，这样做最好了。更好的写法是\n \n  &lt;&nbsp;p&gt;现在你知道我最喜欢的玉米是哪种了。&lt;&nbsp;/p&gt;&nbsp; &nbsp;\n  &lt;&nbsp;script&nbsp;type=&quot;text/java script&quot;&nbsp;src=&quot;path/to/file.js&quot;&gt;&lt;&nbsp;/script&gt;&nbsp; &nbsp;\n  &lt;&nbsp;script&nbsp;type=&quot;text/java script&quot;&nbsp;src=&quot;path/to/anotherFile.js&quot;&gt;&lt;&nbsp;/script&gt;&nbsp; &nbsp;\n  &lt;&nbsp;/body&gt;&nbsp; &nbsp;\n  &lt;&nbsp;/html&gt;&nbsp;\n  6. 在 For 语句外部声明变量\n  当需要执行冗长的for语句时，不要让java script引擎每次都重复那些没有必要的操作。例如：\n  这样不好\n  \n   for(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;&nbsp;someArray.length;&nbsp;i++)&nbsp;{&nbsp; &nbsp;\n   var&nbsp;container&nbsp;=&nbsp;document.getElementById(\'container\');&nbsp; &nbsp;\n   container.innerHtml&nbsp;+=&nbsp;\'my&nbsp;number:&nbsp;\'&nbsp;+&nbsp;i;&nbsp; &nbsp;\n   console.log(i);&nbsp; &nbsp;\n   }&nbsp;\n  \n  这段代码每次都重新定义数组长度，每次都在遍历DOM寻找container元素 —— 太傻了！\n  这样好多了\n  \n   var&nbsp;container&nbsp;=&nbsp;document.getElementById(\'container\');&nbsp; &nbsp;\n   for(var&nbsp;i&nbsp;=&nbsp;0,&nbsp;len&nbsp;=&nbsp;someArray.length;&nbsp;i&nbsp;&lt;&nbsp;&nbsp;len;&nbsp;&nbsp;i++)&nbsp;{&nbsp; &nbsp;\n   container.innerHtml&nbsp;+=&nbsp;\'my&nbsp;number:&nbsp;\'&nbsp;+&nbsp;i;&nbsp; &nbsp;\n   console.log(i);&nbsp; &nbsp;\n   }&nbsp;\n  \n  7. 快速构建字串\n  要对一个数组或对象做循环操作时，不要老惦记着一表人才的for语句，拿点创意出来嘛！明明就还有很多更快的办法：\n  \n   var&nbsp;arr&nbsp;=&nbsp;[\'item&nbsp;1\',&nbsp;\'item&nbsp;2\',&nbsp;\'item&nbsp;3\',&nbsp;...];&nbsp; &nbsp;\n   var&nbsp;list&nbsp;=&nbsp;\'&lt;&nbsp;ul&gt;&lt;&nbsp;li&gt;\'&nbsp;+&nbsp;arr.join(\'&lt;&nbsp;/li&gt;&lt;&nbsp;li&gt;\')&nbsp;+&nbsp;\'&lt;&nbsp;/li&gt;&lt;&nbsp;/ul&gt;\';&nbsp;\n  \n  “没那么多繁文缛节来烦你；你就信我一次好了（或者你也可以自己试一试）—— 这真的是迄今能找到的最快办法了！\n  用点土办法，也别管它背后究竟发生了什么抽象的东西，通常土办法都比那些优雅的办法要快捷得多！”– James Padolsey, james.padolsey.com\n  8. 减少全局变量\n  “把你踩在全局的那些乱七八糟的脚印都归于一人名下，能显著降低与其他应用、小工具或JS库冲突的可能性。” – Douglas Crockford\n  \n   var&nbsp;name&nbsp;=&nbsp;\'Jeffrey\';&nbsp; &nbsp;\n   var&nbsp;lastName&nbsp;=&nbsp;\'Way\';&nbsp; &nbsp;\n   function&nbsp;doSomething()&nbsp;{...}&nbsp; &nbsp;\n   console.log(name);&nbsp;//&nbsp;Jeffrey&nbsp;--&nbsp;也有可能是&nbsp;window.name&nbsp;\n   更好的写法\n   \n    var&nbsp;DudeNameSpace&nbsp;=&nbsp;{&nbsp; &nbsp;\n    name&nbsp;:&nbsp;\'Jeffrey\',&nbsp; &nbsp;\n    lastName&nbsp;:&nbsp;\'Way\',&nbsp; &nbsp;\n    doSomething&nbsp;:&nbsp;function()&nbsp;{...}&nbsp; &nbsp;\n    }&nbsp; &nbsp;\n    console.log(DudeNameSpace.name);&nbsp;//&nbsp;Jeffrey&nbsp;\n   \n  \n  注意看，我们是如何戏剧化地把“乱七八糟的脚印”都归到“DudeNameSpace”这对象之下的。\n  9. 写好注释\n  可能一开始你会觉得并无必要，但相信我，你将来会主动想要尽可能写好代码的注释的。当你几个月后再回看某项目时，结果却发现很难想起当时写某句东西时脑子在想的什么了，是不是很让人沮丧呢？或者，如果有同事要修订你的代码呢？一定，一定要为你代码里的重要部分加上注释。\n  \n   //&nbsp;遍历数组，输出各自名称&nbsp; &nbsp;\n   for(var&nbsp;i&nbsp;=&nbsp;0,&nbsp;len&nbsp;=&nbsp;array.length;&nbsp;i&nbsp;&lt;&nbsp;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp; &nbsp;\n   console.log(array[i]);&nbsp; &nbsp;\n   }&nbsp;\n  \n  10. 试试渐进增强\n  一定要记得为未启用java script的情况提供替代方案。大家可能会认为，“大部分我的访客都启用了java script的，我才不用担心”。这样的话，你可就大错特错了！\n  你有没有试过看看禁用java script后你那漂亮的滑动器都成啥样了？（你可以下载 Web Developer ToolBar 轻松完成这项任务。）禁用之后你的网站可能就彻底失去了可用性！经验之谈：开发初期总是按照没有java script来设计你的网站，之后再进行渐进地功能增强，小心翼翼地改变你地布局。\n  11. 不要传递字串给 “setInterval” 或 “setTimeout”\n  看看下面的代码：\n  \n   setInterval(&nbsp; &nbsp;\n   &quot;document.getElementById(\'container\').innerHTML&nbsp;+=&nbsp;\'My&nbsp;new&nbsp;number:&nbsp;\'&nbsp;+&nbsp;i&quot;,&nbsp;3000&nbsp; &nbsp;\n   );&nbsp;\n  \n  不仅执行不高效，而且和 eva l 函数有着同样的高风险。千万不要把字串传递给 setInterval 和 setTimeout。恰当的做法是，传递一个函数名：\n  \n   setInterval(someFunction,&nbsp;3000);&nbsp;\n  \n  12. 不要使用with语句\n  初识之下，“with”语句似乎还挺好用的。它用于设置代码在特定对象中的作用域。其基本用法是提供深入到对象中处理元素的快速写法。例如：\n  \n   with&nbsp;(being.person.man.bodyparts)&nbsp;{&nbsp; &nbsp;\n   arms&nbsp;=&nbsp;true;&nbsp; &nbsp;\n   legs&nbsp;=&nbsp;true;&nbsp; &nbsp;\n   }&nbsp;\n  \n  – 等价于 —\n  \n   being.person.man.bodyparts.arms&nbsp;=&nbsp;true;&nbsp; &nbsp;\n   being.person.man.bodyparts.legs=&nbsp;true;&nbsp;\n  \n 不幸的是，测试表明，若你要为对象插入新成员，with的表现非常糟糕，它的执行速度非常缓慢。替代方案是声明一个变量：\n \n  var&nbsp;o&nbsp;=&nbsp;being.person.man.bodyparts;&nbsp; &nbsp;\n  o.arms&nbsp;=&nbsp;true;&nbsp; &nbsp;\n  o.legs&nbsp;=&nbsp;true;&nbsp;\n 13. 使用 {}，而不用New Object()在java script有多种方式能新建对象。最传统的方法是 new 语句，如下：\n \n  var&nbsp;o&nbsp;=&nbsp;new&nbsp;Object();&nbsp; &nbsp;\n  o.name&nbsp;=&nbsp;\'Benhuoer\';&nbsp; &nbsp;\n  o.lastName&nbsp;=&nbsp;\'Yang\';&nbsp; &nbsp;\n  o.someFunction&nbsp;=&nbsp;function()&nbsp;{&nbsp; &nbsp;\n  console.log(this.name);&nbsp; &nbsp;\n  }&nbsp;\n 不过，这一方法读起来却比较糟糕。我强烈建议你采用下面这种在文字样式上更为强健的写法：更好的写法\n \n  var&nbsp;o&nbsp;=&nbsp;{&nbsp; &nbsp;\n  name:&nbsp;\'Jeffrey\',&nbsp; &nbsp;\n  lastName&nbsp;=&nbsp;\'Way\',&nbsp; &nbsp;\n  someFunction&nbsp;:&nbsp;function()&nbsp;{&nbsp; &nbsp;\n  console.log(this.name);&nbsp; &nbsp;\n  }&nbsp; &nbsp;\n  };&nbsp;\n 注意，如果你想新建一个空对象，用 {} 就能行：\n \n  var&nbsp;o&nbsp;=&nbsp;{};&nbsp;\n “对象字面符(Objects literals)帮助我们写出支持很多特性，同时又关联性强、简明直接的代码。没必要直接调用新建语句，然后再费心维护声明变量和传递变量的语句之间的正确顺序，等等。” – dyn-web.com14. 使用[]，而不用New Array()新建数组时的同类型运用。行得通的写法\n \n  var&nbsp;a&nbsp;=&nbsp;new&nbsp;Array();&nbsp; &nbsp;\n  a[0]&nbsp;=&nbsp;&quot;Joe&quot;;&nbsp; &nbsp;\n  a[1]&nbsp;=&nbsp;\'Plumber\';&nbsp;\n 更好的写法\n \n  var&nbsp;a&nbsp;=&nbsp;[\'Joe\',\'Plumber\'];&nbsp;\n “在java script编程中经常遇到的一个错误是，该用数组时却用了对象，该用对象时却用了数组。规则其实很简单：当属性名是小的连续整数时，你应该使用数组。其他情况，使用对象。” – Douglas Crockford15. 一长列变量声明？别写那么多var，用逗号吧\n \n  var&nbsp;someItem&nbsp;=&nbsp;\'some&nbsp;string\';&nbsp; &nbsp;\n  var&nbsp;anotherItem&nbsp;=&nbsp;\'another&nbsp;string\';&nbsp; &nbsp;\n  var&nbsp;oneMoreItem&nbsp;=&nbsp;\'one&nbsp;more&nbsp;string\';&nbsp;\n  更好的写法\n  \n   var&nbsp;someItem&nbsp;=&nbsp;\'some&nbsp;string\',&nbsp; &nbsp;\n   anotherItem&nbsp;=&nbsp;\'another&nbsp;string\',&nbsp; &nbsp;\n   oneMoreItem&nbsp;=&nbsp;\'one&nbsp;more&nbsp;string\';&nbsp;\n  \n …不言自明。我不知道这样做能否提升代码执行速度，但是确实让你的代码干净许多。17. 千万千万记得写分号大部分浏览器都允许你不写句尾分号：\n\n var&nbsp;someItem&nbsp;=&nbsp;\'some&nbsp;string\'&nbsp;\n function&nbsp;doSomething()&nbsp;{&nbsp; &nbsp;\n return&nbsp;\'something\'&nbsp;\n }&nbsp;\n 之前已经说过，这样做会造成潜在的更大、更难以发现的问题：\n 更好的写法\n \n  var&nbsp;someItem&nbsp;=&nbsp;\'some&nbsp;string\';&nbsp; &nbsp;\n  function&nbsp;doSomething()&nbsp;{&nbsp; &nbsp;\n  return&nbsp;\'something\';&nbsp; &nbsp;\n  }&nbsp;\n  18. “For in” 语句\n  遍历对象时，你可能会发现你还需要获取方法函数。所以遇到这种情况时，请一定记得给你的代码包一层 if 语句，用以过滤信息。\n  \n   for(key&nbsp;in&nbsp;object)&nbsp;{&nbsp; &nbsp;\n   if(object.hasOwnProperty(key)&nbsp;{&nbsp; &nbsp;\n   ...这里做点什么...&nbsp; &nbsp;\n   }&nbsp; &nbsp;\n   }&nbsp;\n  \n  引自 Douglas Crockford 所作： java script: The Good Parts \n  19. 使用Firebug的“Timer”功能优化你的代码\n  想要轻松地快速了解某项操作的用时吗？使用Firebug的timer功能来记录结果好了。\n  \n   function&nbsp;TimeTracker(){&nbsp; &nbsp;\n   console.time(&quot;MyTimer&quot;);&nbsp; &nbsp;\n   for(x=5000;&nbsp;x&nbsp;&gt;&nbsp;0;&nbsp;x--){}&nbsp; &nbsp;\n   console.timeEnd(&quot;MyTimer&quot;);&nbsp; &nbsp;\n   }&nbsp;\n  \n  20. 读，读，读……\n  虽然我是Web开发博客的超级粉丝，但吃饭和睡觉前除了看书好像也别无选择~ 在你的床头柜上摆一本Web开发的好书吧！\n  21. 自决的函数\n  相比于调用函数，让函数在页面载入或者某一父函数被调用时自动执行，是十分简单方便的做法。你只需要把你的函数包在父辈之内，然后添上一个额外的括号，本质上这括号就触发了你定义的函数（了解更多）。\n  \n   (function&nbsp;doSomething()&nbsp;{&nbsp; &nbsp;\n   return&nbsp;{&nbsp; &nbsp;\n   name:&nbsp;\'jeff\',&nbsp; &nbsp;\n   lastName:&nbsp;\'way\'&nbsp;\n   };&nbsp; &nbsp;\n   })();&nbsp;\n  \n  22. 原生 java script 总是会比使用代码库来的快\n  诸如jQuery和Mootools这样的java script库，能为你写代码的过程省下不少时间——尤其是当需要 AJAX 操作时。不过你可得记住，只要你的代码写得恰当，原生java script总是会比利用代码库的写法执行得快一些。\n  jQuery的“each” 方法对于循环操作十分便利，但是使用原生态的for语句总归会快很多。\n  23. Crockford 的 JSON.Parse\n  尽管 java script 2会内建JSON处理器，但写这篇文章之时，我们还是需要自己实现。Douglas Crockford，JSON的创建者，已经为我们创作出能直接使用的处理器了。您可以在这里下载。\n  导入这段代码，你就能新建 JSON 全局对象，然后处理你的 .json 文件。\n  \n   var&nbsp;response&nbsp;=&nbsp;JSON.parse(xhr.responseText);&nbsp;&nbsp; &nbsp;\n   var&nbsp;container&nbsp;=&nbsp;document.getElementById(\'container\');&nbsp; &nbsp;\n   for(var&nbsp;i&nbsp;=&nbsp;0,&nbsp;len&nbsp;=&nbsp;response.length;&nbsp;i&nbsp;&lt;&nbsp;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp; &nbsp;\n   container.innerHTML&nbsp;+=&nbsp;\'&lt;&nbsp;li&gt;\'&nbsp;+&nbsp;response[i].name&nbsp;+&nbsp;\'&nbsp;:&nbsp;\'&nbsp;+&nbsp;response[i].email&nbsp;+&nbsp;\'&lt;&nbsp;/li&gt;\';&nbsp; &nbsp;\n   }&nbsp;\n   24. 移去“Language”\n   很多年前，language还是每段script标签必备属性：\n   \n    &lt;&nbsp;script&nbsp;type=&quot;text/java script&quot;&nbsp;language=&quot;java script&quot;&gt;&nbsp; &nbsp;\n    ...&nbsp; &nbsp;\n    &lt;&nbsp;/script&gt;&nbsp;\n   \n  \n  不过现在，这属性已经没啥用很久了…… 所以，删掉算啦！\n  就这些了，朋友们~\n  就是这些了，这就是我给java script初学者的24条小建议。\n \n\n\n        ', null);
INSERT INTO `blog` VALUES ('76', '如何搭建自己的网站', '\n            \n \n\n\n如何搭建自己的网站%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n仅做参考\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\nWikipedia，自由的百科全书 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\n返回技术向导首页&nbsp;(http://wiki.lupaworld.com/index.php/Guide)  目录\n[显示隐藏]\n1 明确网站类型\n2 如何申请域名\n \n2.1 申请域名 2.2 域名估价方法 \n\n3 如何申请网站空间\n4 如何配置域名\n5 如何上传文件\n6 访问你的站点\n[编辑]\n明确网站类型\n这里不讲商业，只以个人娱乐及抒发情感，或与他人交流为目的而建立的小型网站。\n\n（1）个人小型门户（社区）\n\n门户网站：是指通向某类综合性互联网信息资源并提供有关信息服务的应用系统。门户网站最初提供搜索引擎、目录服务，后来由于市场竞争日益激烈，门户 网站不得不快速地拓展各种新的业务类型，希望通过门类众多的业务来吸引和留驻互联网用户，以至于目前门户网站的业务包罗万象，成为网络世界的“百货商场” 或“网络超市”。 个人建立难度较大，现一般只提供小型界面指引进入其相关论坛及博客等。比较完善的有SupeSite/X-Space等。 \n（2）论坛\n\n个人建立论坛的目的无非为了与某个感兴趣的领域的人交流之用，如游戏，音乐，电影等。综合性论坛对于个人难度较大。现常用的有Discuz！、动网（Dvbbs）、PHPWind等。 \n（3）博客（播客）\n\n博客(Blog),是一种简易的个人信息发布方式。任何人都可以注册, 完成个人网页的创建、发布和更新。博客充分利用网络互动、更新即时的特点, 让你最快获取最有价值的信息与资源; 你可以发挥无限的表达力, 及时记录和发布个人的生活故事、闪现的灵感等；更可以文会友, 结识和汇聚朋友，进行深度交流沟通。 \n苹果中国译为播客，“播客”又被称作“有声博客”,是Podcast的中文直译。用户可以利用“播客”将自己制作的“广播节目”上传到网 上与广大网友分享。 「播客」（Podcasting）这个词来源自苹果电脑的&quot;iPod&quot;与&quot;广播&quot;(broadcast)的合成词，指的是一种在互联网上发布文件并允许用 户订阅feed以自动接收新文件的方法，或用此方法来制作的电台节目。这种新方法在2004年下半年开始在互联网上流行以用於发布音频文件。 \n[编辑]\n如何申请域名\n[编辑]\n申请域名\n1、点击新网http://www.xinnet.com 左上角的&quot;注册域名&quot;进入域名查询页面。如下图所示:\n\n \n2、输入您需要查询的域名如:lupaworld.cn,那么请输入lupaworld,然后选择.cn后缀。\n\n \n3、点击&quot;搜索按钮&quot;,即将显示查询结果。\n\n \n4、选择您需要的域名并提交订单\n\n请选择您需要的域名,然后点击&quot;注册&quot;按钮进入资料填写页面。 注意事项:域名所有者代表域名所有权,请千万别填错。 \n \n \n \n5、填写完成后点击&quot;确认注册&quot;,再次点击&quot;确定&quot;\n\n \n此时您将看到订单提交的结果,如果您的帐户上有足够款项,并且您选择的注册方式是&quot;正式注册&quot;,那么域名将马上注册成功并扣除注册款项,如 果您选择的注册方式是&quot;只交订单&quot;,那么域名并没有真正生效,只是提交到了我们的申请订单里,这时,您需要按&quot;汇款方式&quot;办理汇款,并通知我们,我们将马 上为您办理后续事宜。完全不用您自己操心。 \n \n国内顶级域名注册服务商有新网http://www.xinnet.com 、中国万网http://www.net.cn 、35互联http://www.35.com 等。 \n[编辑]\n域名估价方法\n我们经常被问到一个问题：我的域名值多少钱？这是一个很重要的问题，因为客户不愿意以低于实际价值的价格出售自己的域名。 \n域名的价值是一个很抽象的概念，为了正确评估客户的域名价值，我们借鉴国际上的做法，并结合中国的国情提出以下评估模式： 域名的价值可以由以下几个方面来评估： \n1、域名的长度 \n域名长度（不包括后缀名）的重要性是不容质疑的，短的域名不仅易记，而且输入方便，不易出错。我们可以根据域名的长度将域名分为以下几级： \nA级：域名长度小于5，如aaa等。\nB级：域名长度在6-10之间，如amazon等。\nC级：域名长度在11-15之间，如greatdomains\nD级：域名长度在16-20之间\nE级：域名长度在20以上\n\n2、域名的含义： \n域名的含义也是域名价值的要素之一，如以一些常用的英文单词或中文拼音缩写来命名的域名比较有价值，我们也将其分为以下几个级别： \nA级：以一些常用的有意义、简单的英文单词为域名，如bank \nB级：以一些简短、明了的中文拼音或一些不常用但有意义的英文单词为域名，如1hao（1号）、zhaodaola（找到啦）、amazon（亚马逊河） \nC级：由两个词合成的域名：如supermarket等 \nD级：由三个词以上构成的域名：如youcanmakeit等。 \nE级：无明显含义的域名：如wtwewfddg \n3、域名的后缀： \n对于商业应用来说，.com域名无疑是最具诱惑力的。而.net及.org域名就差得多 了。依此可以分为以下几类： \nA级：.com\nC级：.net\nD级：.org及其他顶级域名\nE级：二级域名（如.com.cn若允许转让的话）\n\n域名估价：\n\n根据以上几个方面，我们就可以对域名的价值进行一个大致的评估了。参见下表： 对于.com域名来说： 域名价格指数 \n价格 长度A 长度B 长度C 长度D 长度E\n含义A 50-1000 30-500 5-100 1-25 0-5\n含义B 20-500 5-100 3-50 0.5-5 0-2\n含义C 1-15 0.5-10 0.3-7.5 0.1-4 0-1.5\n含义D 0.5-5 0.3-2.5 0.3-2.5 0.1-2 0-1.5\n含义E 0-2 0-1.5 0-1 0-1 0-1\n\n域名估价=域名价格指数*10000(人民币)\n\n对于.net域名来说，可参考以上方法评估，但价格要乘上0.25这个因子，其他顶级域名则要乘上0.1。 \n举例来说：sina.com长度为A级、含义为B级，估价应在20万-500万元。\n\n域名估价模式\n\n美国Greatdomains是目前Internet上最著名的域名交易商，Loans.com等好几个价值好几百万美元的域名就是通过这家公司出售的。Greatdomains公布的域名估价模式具有很高的权威性和参考价值，域名博士在原文基础上增加了几个域名例子。 \nGreatdomains采用三个C来估计域名的价值，这三个C分别为Characters（域名长度）,Commerce（商业价值）, 和.Com（所在的顶级域名）。每个C都是一个很重要的因素，三个C综合起来决定了域名的价值。对域名每个C的评估结果分为0到4星五个等级，其中4星为 最好。Characters（域名长度）域名的长度（不包括.com，.net）越短越值钱，因为短域名容易记忆和拼写。 \n4星：域名长度小于5，例如163.com、8848.com、Sina.com、Sohu.com、YaBuy.com。\n3星：域名长度在6-10之间，例如EachNet.com、StockStar.com。\n2星：域名长度在11-15之间，例如GreatDomains.com\n1星：域名长度在16-20之间，例如OnTheWayToThePark.com\n0星：域名长度在20以上，例如TheWorldBoxOrganization.com\n\n域名最终的价值体现在它是否能带来流量和利润，这些结果将决定一个公司愿意出多少钱购买你的域名。域名所包含的商业价值大小将直接推动域名的价格， 例如cars.com要比camping值钱。简单、人人皆知的英文单词和词组也很值钱，因为它容易打品牌，例如monster.com。包含已注册商标 的域名毫无价值，注册这种域名是浪费金钱和时间，因为按照最新的域名政策，这种域名只有商标所有人才能注册。例如你不能注册coke.*或 coke*.com，因为coke是一个注册商标。 \n4星：以一些常用的有意义、简单的英文单词为域名，例如Loans.com、Food.com。\n3星：以一些不常用但有意义的英文单词为域名，例如Escrow.com、Amazon.com。\n2星：由字词合成的域名，有一定的商业价值，例如StoreCoupons.com。\n1星：由字词合成的域名，包含的商业价值相当有限，例如UsedLinens.com。\n0星：不包含任何商业价值的域名，例如CantTrustUs.com。\n\n.com用于商业公司，在.com下注册域名意味“我从事商业活动已有好多年了，我是一个严肃的商人，我知道我正在做什么”，使用.com下的域名不仅显得大气简洁，而且可体现你的全球化理念。4星：.com。2星：.net。1星：所有其它顶级域名。 \n根据上面三个条件，可用下列表格估算域名的价格，.net下的域名要在下表的基础上乘以0.25，带国家代码的域名要乘以0.1： \n价格（美元）长度：4星长度：3星长度：2星长度：1星长度：0星\n商业价值：4星50万-1000万30万-500万5万-100万1万-25万0-5万\n商业价值：3星20万-500万 5万-100万3万-50万 5千-5万 0-2万\n商业价值：2星1万-15万&nbsp;&nbsp;5千-10万 3千-7.5万1千-4万 0-1.5万\n商业价值：1星5千-5万&nbsp;&nbsp;3千-2.5万 3千-2.5万1千-2万 0-1.5万\n商业价值：0星0-2万&nbsp;&nbsp; 0-1.5万&nbsp;&nbsp;0-1万&nbsp;&nbsp;0-1万&nbsp;&nbsp;0-1万 \n\n站在SEO角度来给域名估价应该还要考虑更多因素 \n域名有没有被各大搜索引擎惩罚.\n各大搜索引擎对域名的信任度怎么样.\n各大开放目录对域名的收录情况.\n\n[编辑]\n如何申请网站空间\n网站空间分为免费与收费2类。 \n（1）免费空间\n\n免费空间是吸引客户的手段，其空间小，但普通个人网站已够用。用来试手比较不错。基本无时间限制。 相对比较混乱，支持的类型较少，基本只支持Htm格式的网页，且不提供数据库空间。限制较多，比如流量，IIS连接数量等，上传速度较慢。另外一个比较头疼的是广告无处不在。 \n不错的有：www.51.net等。 \n（2）收费空间\n\n正规的虚拟主机运营商质量及服务都比较不错，按不同的要求可以选择不同的空间类型及价格档次，在其网站上可以比较方便的查询到购买流程，且均支持网上付费。 \n不错的有：新网（www.xinnet.com）、中国频道（www.35.com）、中国万网（www.net.cn）。 更多查阅：http://www.rent-cars.cn \n[编辑]\n如何配置域名\n一、用你申请到的域名及域名密码登陆Mydns域名管理平台。 \n二、A记录 \n又称IP指向，用户可以在此设置二级域名并指向到自己的WEB服务器的IP地址上，从而实现通过域名找到服务器找到相应网页的功能。下面我们以dnsepp.com域名为例设置一个二级域名bbs.dnsepp.com并指向某台已经配置好的web服务器。 \n1.如何添加A记录 \n在“主机记录列表”栏目中进行设置，在域名处填写bbs，在类型处选择A，顺序处不必填写保持默认值，在指向处填写服务器的ip地址，如：218.244.47.128，然后点击“增加新纪录”即可。 \n注：如果是对域名本身做指向，如将dnsepp.com指向218.244.47.128，那么在域名处什么都不要填，直接选择类型A，并填写好ip地址后点击“增加新纪录”即可。 \n2.如何修改A记录 \n直接在已有的A记录后面的指向处将原有的地址改写为新的并点击“更新”按钮即可。 \n3.如何删除A记录 点击要删除的A记录后面对应的“删除”按钮即可。 \n三、CNAME记录 \n通常称别名指向。在这里，您可以定义一个主机别名，比如设置test.dnsepp.com，用来指向一个主机www.dns.com.cn那么以后就可以用test.dnsepp.com来代替访问www.dns.com.cn了。 \n1.如何添加CNAME记录 \n在“主机记录列表”栏目中进行设置在域名处填写test，类型选择为CNAME，顺序处不必填写保持默认值，指向处填写目标地址，如：www.dns.com.cn. \n注：在指向处，只能填写完整的域名且在最后要加一个“.”如： www.dns.com.cn.而不能是ip地址或网站下面的某个目录，如：www.dns.com.cn/news，这样填写是不对的。 \n2.如何修改CNAME记录 \n 直接在已有的CNAME记录后面的指向处将原有的地址改写为新的并点击“更新”按钮即可。 \n3.如何删除CNAME记录 \n点击要删除的CNAME记录后面对应的“删除”按钮即可。 \n四、URL转发 \n是指通过服务器端的特殊设置，将您的当前域名和您指定的另外一个网络地址绑定，当用户访问您的当前域名时，系统会自动将用户指引到您所绑定 的网络地址上。如您将域名domain.dnsepp.com和www.dns.com.cn/Html/Hot/production /hot1.htm绑定，那么用户在访问domain.dnsepp.com时将会看到www.dns.com.cn/Html/Hot /production/hot1.htm的内容。 \n1.如何设置URL转发 \n下面我们以dnsepp.com为例设置一个URL转发，将domain.dnsepp.com 转发到www.dns.com.cn/Html/Hot/production/hot1.htm 页面上。 \n进入MYDNS界面，在“网站转发功能”栏目中进行设置，在主机名称处填写domain，转向网址填写目标地址www.dns.com.cn/Html/Hot/production/hot1.htm，然后点击“增加新转发”即可。 \nURL转发记录添加成功后，系统会自动添加一条和URL转发主机记录名称相同的A记录，既domain.dnsepp.com 指向我们的转发服务器218.244.47.45 ，此条记录一定不要删除，否则转发将会失效。 \n2.如何修改URL转发记录 \n直接在已有的URL转发记录后面的转向网址处将原有的地址改写为新的并点击“更新”按钮即可。 \n3.如何删除URL转发记录 \n点击要删除的URL转发记录后面对应的“删除”按钮即可。 \n注：以上所有记录的添加、修改、删除操作成功后，我们的DNS服务器会立即刷新并生效，全球DNS服务器大约会在1-2小时内刷新生效。 \n[编辑]\n如何上传文件\nFlashFXP是一款功能强大的FXP/FTP软件，如果你使用其它ftp工具受到挫折，就改用这款好用的软件吧。FlashFXP使用简单，并且有汉化版。 \n本文介绍FlashFXP最基本的功能，设置站点，上传网站。 \n1.打开FlashFXP，点击“站点”/“站点管理器”。快捷键F4。 \n \n2.在“站点管理器”对话框中，点击“新建站点”，在弹出的对话框中，输入一个站点名称。 \n \n3.在常规面板，输入ftp空间的IP地址，端口，用户名称，密码，然后点击“应用”按钮，站点就设置好了。点击“连接”按钮，连接站点。 \n \n4.连接上站点之后，在本地磁盘，找到要上传的站点目录，选中后右键单击，单击“传输”。上传网站就这样轻易实现了。 \n \n同样的方法，选中远程空间中的文件或者文件夹，点右键，占击“传输”，就可以下载到本地。 \n[编辑]\n访问你的站点\n打开IE浏览器，输入你申请的域名，回车。\n\n\n\n        ', null);
INSERT INTO `blog` VALUES ('77', 'java中ArrayList与Vector的区别', '\n            \n \n\njava中ArrayList与Vector的区别1.vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。 2.如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。 3.如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是o(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为o(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为o(1),而查询一个指定位置的数据时花费的时间为o(i)。 \n\n        ', null);
INSERT INTO `blog` VALUES ('78', '让你的头脑达到顶尖效率的20种方法，你值得拥有！', '\n            \n \n 　　\n引导语：为了保持敏锐，锻炼你的大脑是很重要的。我们思考得越少，它就会变得越迟钝。我们更关心我们的大脑，我们会变得跟有智慧。这里有20个训练大脑的方案。\n\n\n　　\n1、读一本好书。\n\n&nbsp;&nbsp;&nbsp; 读书会激发想象力。当你读书时，你的大脑不能持续在反映画面。读书让你的头脑开始工作。我喜欢让书本带着我走。我总是有一本有时甚至三至四本书在读!大部分书我是从图书馆里借来的，这样就不用花钱买每一本书了。这也使我能够毫无风险地广泛阅读各种书籍。\n　　\n2、适当玩游戏。\n&nbsp;&nbsp;&nbsp; 网络游戏不好的一面是导致脑袋腐烂，但实际上有些也会帮助你增强思维。有些游戏可以很考验脑力活动，要懂得如何去筛选有助于大脑的游戏。\n　　\n3、练习冥想。\n \n&nbsp;&nbsp;&nbsp; 不要担心，不是要在这里离开新时代的最深端。冥想的方式有很多种。对人而言，最简单的形式，冥想是花一点时间独处达到放松和集中思考的方式。它是神奇的治疗。\n　　\n4、获得大量的休息。\n \n&nbsp;&nbsp;&nbsp; 缺少睡眠能够影响你吸收新信息的能力。这意味着大学里通宵达旦地补习的效率比你想象的要低得多。你的大脑需要休息，工作在其最佳效能。这可能是为什么事情总是在睡了好觉后变得更加清晰明朗。\n　　\n5、规律地锻炼。\n&nbsp;&nbsp;&nbsp; 你难道想没一会就从跑步机上下来吗？心血管运动通过改善血液到大脑的流动从而改善大脑功能。一份研究发现体育锻炼实际上帮助扩大大脑的体积。所以，如果你想要一个更大、更好的大脑，那么就去运动吧！\n　　\n6、吃一顿好早餐。\n&nbsp;&nbsp;&nbsp; 这不是不切实际。吃一顿好早餐确实令你有个更好的开始。你应该吃高蛋白和优质碳水化合物的的早餐。两片夹着花生牛油的全麦吐司就符合这一条了。鸡蛋同样是蛋白质的好来源。坚果、牛奶和新鲜水果都能为大脑提供良好的营养。 &nbsp;\n　　\n7、积极地思考。\n&nbsp;&nbsp;&nbsp; 鼓励自己。我相信积极思考会提供大脑效能和帮助避免失望。我想说你的大脑就像电脑一样，垃圾进来、垃圾出去。发现积极，鼓励人们闲逛、能够使你快乐阅读材料，做所有能够使你感觉良好的事情。这些事情将会帮助你的精神变得更有生产力。 &nbsp;\n\n　　\n8、不断地学习。\n&nbsp;&nbsp;&nbsp; 不要停止怀疑你的世界。寻找新的体验、技能和知识。想写你总是想学着去做的事并且开始去做。一份现在着名的研究表明伦敦出租车司机大脑的确定领域比一般的市民得到更大的开发。这是由于他们需要学习懂得如何在迷宫般的城市街道上导航。我们能够运用此项挑战我们大脑的技术来增进我们的能力。 &nbsp;\n　　\n9、戒酒。\n&nbsp;&nbsp;&nbsp; 酒精是抑郁的原因。它降低精神功能。酒能乱性是有充分证据的。如果你想要有顶尖的精神表现，那么停止喝酒吧。另外它能观察到的作用，它也减弱人的睡眠，这是我们已经讨论过的，阻碍你清晰思考的能力。\n　　\n10、扩大你的词汇量。\n&nbsp;&nbsp;&nbsp; 决定每天学习一个新单词。有许多能够帮你做这项努力的网站。你将不止扩大你的思想，而且当你在谈话中引入一个新词汇时能够使你的朋友和同事印象深刻。\n　　\n11、打破你的例程。\n&nbsp;&nbsp;&nbsp; 选择一条新路开车去工作。试着用另外一只手去写字。将一点不同的东西掺杂在一起。这将振作你的大脑因为它需要你思考更多。你不能只是自动驾驶。离开你的定式来挑战你的大脑，它将有所反应。这是使你脑浆流动的好方法。 &nbsp;\n　　\n12、不要看太多电视。\n&nbsp;&nbsp;&nbsp; 研究者发现在1-3岁时看太多电视会导致儿童注意力问题。让我们直面它，电视使心态麻木。从沙发上起来并离开电视机。当然，也有一些好的教育节目给孩子和大人们，但是整体上美国人看太多电视了。如果你想要高效的精神表现就关掉电视吧。\n　　\n13、处理数字问题。\n&nbsp;&nbsp;&nbsp; 心算而不是用计算器计算。我们许多人它是使用它或失去它。我们已经变得精神懒惰了。我们依赖工具而不是自己思考。处理和记忆数字是使大脑恢复状态的好途径。这一路上能够偿还大量股息。 &nbsp;\n\n　　\n14、停止依靠GPS走路。\n&nbsp;&nbsp;&nbsp; 记住第8条里所讲的出租车司机。用你的大脑去指出如何从点A到点B是很好的思维体操。你必须用你大脑的能力来决定空间关系来提高读地图的效率和穿梭城市。在一个陌生的地方旅行就更好了！\n　　\n15、唤起远久的记忆。\n&nbsp;&nbsp;&nbsp; 找出老照片并且开始翻阅。这将进入你头脑中的记忆银行。图像将帮助你想起你已经忘记的东西。深入挖掘就是所有你记得的东西。如果你有别的方法来唤醒你的记忆，就像以前的信件和家庭电影，那么也尽可能得利用它们。\n　　\n16、创造优美的音乐。\n&nbsp;&nbsp;&nbsp; 学习演奏一件乐器是超级改变你的大脑的方法。它需要你大脑的多个不同部分协调工作来创作出你想要的旋律。当然，如果你已经是一个音乐家了，你们学习一件新的东西。迫使你自己学习新技术。音乐是思想伟大的锻炼。 &nbsp;\n\n　　\n17、说一种新语言。\n&nbsp;&nbsp;&nbsp; 许多人同意学习一门新语言是使思想延伸的一种有力途径。如果你曾经尝试学习即使是几个新单词，那么你知道这会很难。当然，给大脑越难的东西越好!你有比你想象的要多得多的思维能力。让它试一下吧！\n　　\n18、记忆一首歌。\n&nbsp;&nbsp;&nbsp; 我们很多人头脑中都储存有许多老歌，但为什么不通过学习一些新的调子来扩充我们的记忆？它将在开始的时候花费一点时间，但如果你坚持怎么做，你将发现会越来越简单。这是你的大脑恢复状态了。\n　　\n19、遮住你的双眼绕你的屋子走。\n&nbsp;&nbsp;&nbsp; 这看起来是一种陌生的活动，但你的大脑能够处理它。一旦你试了几次，你就可能发现它很有趣和有挑战性。另外，这会应用你的记忆、运动技能和推理能力。多么好的锻炼！ &nbsp; &nbsp;&nbsp;&nbsp;\n20、适当的浪漫（尤其是女性）\n&nbsp;&nbsp;&nbsp; 浪漫细胞其实每个人都应该有的，只是可能有些人不懂得如何去表达，因为你在绞尽脑汁想浪漫的事情时，其实大脑在运转了，一举两得呢！\n　　\n编后语：你都知道了！我刚刚已经给了你20条非常实用的能使你的思维敏锐的方法。这些建议将马上使你的大脑回到最佳状态。你为什么还在等待？是时候锻炼你的思想神经了。\n&nbsp;\n\n\n \n【点击这里：哇！看了99次了，还想再看！原因你懂的！】 \n\n\n        ', null);
INSERT INTO `blog` VALUES ('79', '从 iBatis 到 MyBatis，你准备好了吗？', '\n            \n \n\n从 iBatis 到 MyBatis，你准备好了吗？\n对于从事 Java EE 的开发人员来说，iBatis 是一个再熟悉不过的持久层框架了，在 Hibernate、JPA 这样的一站式对象 / 关系映射（O/R Mapping）解决方案盛行之前，iBaits 基本是持久层框架的不二选择。即使在持久层框架层出不穷的今天，iBatis 凭借着易学易用、轻巧灵活等特点，也仍然拥有一席之地。尤其对于擅长 SQL 的开发人员来说，iBatis 对 SQL 和存储过程的直接支持能够让他们在获得 iBatis 封装优势的同时而不丧失 SQL 调优的手段，这是 Hibernate/JPA 所无法比拟的。具体而言，使用 iBatis 框架的主要优势主要体现在如下几个方面：\n首先，iBatis 封装了绝大多数的 JDBC 样板代码，使得开发者只需关注 SQL 本身，而不需要花费精力去处理例如注册驱动，创建 Connection，以及确保关闭 Connection 这样繁杂的代码。\n其次，iBatis 可以算是在所有主流的持久层框架中学习成本最低，最容易上手和掌握的框架。虽说其他持久层框架也号称门槛低，容易上手，但是等到你真正使用时会发现，要想掌握并用好它是一件非常困难的事。在工作中我需要经常参与面试，我曾听到过很多位应聘者描述，他们所在的项目在技术选型时选择 Hibernate，后来发现难以驾驭，不得不将代码用 JDBC 或者 iBatis 改写。\niBatis 自从在 Apache 软件基金会网站上发布至今，和他的明星兄弟们（Http Server，Tomcat，Struts，Maven，Ant 等等）一起接受者万千 Java 开发者的敬仰。然而在今年六月中旬，几乎是发布 3.0 版本的同时，iBatis 主页上的一则 “Apache iBATIS has been retired” 的声明在社区引起了一阵不小的波澜。在 Apache 寄居六年之后，iBatis 将代码托管到 Google Code。在声明中给出的主要理由是，和 Apache 相比，Google Code 更有利于开发者的协同工作，也更能适应快速发布。于此同时，iBatis 更名为 MyBatis。\n从 iBatis 到 MyBatis，不只是名称上的变化，MyBatis 提供了更为强大的功能，同时并没有损失其易用性，相反，在很多地方都借助于 JDK 的泛型和注解特性进行了简化。iBatis 确实该退休了，因为一个更为出色的继任者经过 10 个 Beta 版本的蜕变已然出现在我们的面前。\n本文将主要针对 MyBatis 和 iBatis 的变化之处进行讨论，以便于读者顺利从 iBatis 向 MyBatis 过渡。\n\n回页首\n由一个 MyBatis 示例开始\n如果读者接触过一些常用的 Java EE 框架，应该都知道这些框架需要提供一个全局配置文件，用于指定程序正常运行所需的设置和参数信息。而针对常用的持久层框架而言（Hibernate、JPA、iBatis 等），则通常需要配置两类文件：一类用于指定数据源、事务属性以及其他一些参数配置信息（通常是一个独立的文件，可以称之为全局配置文件）；另一类则用于指定数据库表和程序之间的映射信息（可能不止一个文件，我们称之为映射文件）。MyBatis 也不例外，虽然其中的一部分可以通过注解的形式进行，但是这两部分内容本身仍是必不可少的。\n根据 iBatis 的习惯，我们通常把全局配置文件命名为 sqlMapConfig.xml，文件名本身并没有要求，在 MyBatis 中，也经常会将该文件命名为 Configuration.xml （读完全文后读者也许会发现，在 iBatis 中经常出现的 “sqlMap” 在 MyBatis 中被逐渐淡化了，除了此处，还比如 iBatis 配置文件的根元素为 &lt;sqlMapConfig&gt;，指定映射文件的元素为 &lt;sqlMap&gt;，以及 SqlMapClient 等等，这个变化正说明，iBatis 仅是以 SQL 映射为核心的框架，而在 MyBatis 中多以 Mapper、Session、Configuration 等其他常用 ORM 框架中的名字代替，体现的无非是两个方面：首先是为了减少开发者在切换框架所带来的学习成本；其次，MyBatis 充分吸收了其他 ORM 框架好的实践，MyBatis 现在已不仅仅是一个 SQL 映射框架了）。在全局配置文件中可以配置的信息主要包括如下几个方面：\n\n properties --- 用于提供一系列的键值对组成的属性信息，该属性信息可以用于整个配置文件中。\n settings --- 用于设置 MyBatis 的运行时方式，比如是否启用延迟加载等。\n typeAliases --- 为 Java 类型指定别名，可以在 XML 文件中用别名取代 Java 类的全限定名。\n typeHandlers --- 在 MyBatis 通过 PreparedStatement 为占位符设置值，或者从 ResultSet 取出值时，特定类型的类型处理器会被执行。\n objectFactory --- MyBatis 通过 ObjectFactory 来创建结果对象。可以通过继承 DefaultObjectFactory 来实现自己的 ObjectFactory 类。\n plugins --- 用于配置一系列拦截器，用于拦截映射 SQL 语句的执行。可以通过实现 Interceptor 接口来实现自己的拦截器。\n environments --- 用于配置数据源信息，包括连接池、事务属性等。\n mappers --- 程序中所有用到的 SQL 映射文件都在这里列出，这些映射 SQL 都被 MyBatis 管理。\n\n上面提及的大多数元素都不是必需的，通常 MyBatis 会为没有显式设置的元素提供缺省值。一个简单的全局配置文件示例如下：\n\n清单 1. 简单的全局配置文件示例\n\n     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!--iBatis 和 MyBatis 的全局配置文件使用不同的 DTD 约束，在将应用由 iBatis 升级至 MyBatis 时需要注意（两者的映射文件 DTD 约束也不相同）--&gt;  &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  &lt;configuration&gt;  &lt;!-- 配置数据源相关的信息 --&gt;  &lt;environments default=&quot;demo&quot;&gt;  &lt;environment id=&quot;demo&quot;&gt;  &lt;transactionManager type=&quot;JDBC&quot;/&gt;  &lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value= … /&gt;  &lt;property name=&quot;url&quot; value= … /&gt;  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;  &lt;/dataSource&gt;  &lt;/environment&gt;  &lt;/environments&gt;  &lt;!-- 列出映射文件 --&gt;  &lt;mappers&gt;  &lt;mapper resource=&quot;footmark/mybatis/demo/UserInfoMapper.xml&quot;/&gt;  &lt;/mappers&gt;  &lt;/configuration&gt; \n\n有了这些信息，MyBatis 便能够和数据库建立连接，并应用给定的连接池信息和事务属性。MyBatis 封装了这些操作，最终暴露一个 SqlSessionFactory 实例供开发者使用，从名字可以看出来，这是一个创建 SqlSession 的工厂类，通过 SqlSession 实例，开发者能够直接进行业务逻辑的操作，而不需要重复编写 JDBC 相关的样板代码。根据全局配置文件生成 SqlSession 的代码如下：\n Reader reader = Resources.getResourceAsReader(&quot;Configuration.xml&quot;);  SqlSessionFactory sqlSessionFactory =  new SqlSessionFactoryBuilder().build(reader);  SqlSession sqlSession = sqlSessionFactory.openSession(); \n\n可以把上面的三行代码看做是 MyBatis 创建 SqlSession 的样板代码。其中第一行代码在类路径上加载配置文件，Resources 是 MyBatis 提供的一个工具类，它用于简化资源文件的加载，它可以访问各种路径的文件，不过最常用的还是示例中这种基于类路径的表示方式。如果读者对 Hibernate 有所了解，一定会发现 MyBatis 不论是使用风格还是类名都和 Hibernate 非常相像，笔者曾今多次在国内外 Java 社区看到有人说 MyBatis 在向 Hibernate/JPA 靠拢。暂且不论这是否属实，持久化技术在经过一番蓬勃的竞争和发展，最终在社区形成统一的认识并被广泛接受，这对开发者而言未必不是一件好事，MyBatis 在这一点上只是向事实上的标准靠近了一步。\n在完成全局配置文件，并通过 MyBatis 获得 SqlSession 对象之后，便可以执行数据访问操作了。对于 iBatis/MyBatis 而言，要执行的操作其实就是在映射文件中配置的 SQL 语句。两者的配置基本相同，如下所示：\n\n清单 2. 在映射文件中配置 SQL 语句\n\n     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  &lt;mapper namespace=&quot;mybatis.demo.UserInfoMapper&quot;&gt;  &lt;select id=&quot;selectUser&quot; parameterType=&quot;int&quot; resultType=&quot;mybatis.demo.UserInfo&quot;&gt;  select * from UserInfo where userid =#{userid}  &lt;/select&gt;  &lt;/mapper&gt; \n\n在 iBatis 中，namespace 不是必需的，且它的存在没有实际的意义。在 MyBatis 中，namespace 终于派上用场了，它使得映射文件与接口绑定变得非常自然。关于接口绑定，后面会有篇幅专门描述。使用 SqlSession 执行 SQL 的方式如下：\n\n清单 3. 使用 SqlSession 执行映射文件中配置的 SQL 语句\n\n     try  {  UserInfo userinfo = (UserInfo) sqlSession.selectOne  (&quot;mybatis.demo.UserInfoMapper.getUser&quot;, 2);  System.out.println(userinfo);  } finally  {  sqlSession.close();  } \n\n需要注意的是，SqlSession 的使用必需遵守上面的格式，即在 finally 块中将其关闭。以保证资源得到释放，防止出现内存泄露！\n以上就是一个简单而完整的 MyBatis 程序。其中涉及了全局配置文件，映射文件，构建 SqlSession 对象，执行数据访问操作等四个步骤。下面将针对除构建 SqlSession 对象之外的三块内容进行分解。\n\n回页首\nMyBatis 全局配置文件的改变\nMyBatis 全局配置文件的各主要元素基本和 iBatis 相同，只是在用法和个别名称上做了调整。元素的意义就不再描述，下面主要讲述针对 iBatis 和 MyBatis 配置文件的主要区别之处。\n首先，两个版本的 DTD 约束不同，MyBatis 的 DTD 文件已经包含在发布包下的 mybatis-3.0.x.jar 包中。这直接影响到的是，iBatis 配置文件的根元素是 &lt;sqlMapConfig&gt;，而 MyBatis 使用的是 &lt;configuration&gt;。\n其次，&lt;settings&gt; 的用法发生了改变，之前的格式为：\n\n清单 4. 在 iBatis 中设置属性的方式\n\n     &lt;settings props1=&quot;value1&quot; props2=&quot;value2&quot;… /&gt; \n\n要设置的属性直接以键值对的形式作为 &lt;settings&gt; 的属性。而在 MyBatis 中调整为略显复杂但却更有条理的方式：\n\n清单 5. 在 MyBatis 中设置属性的方式\n\n     &lt;settings&gt;  &lt;setting name=&quot;props1&quot; value=&quot;value1&quot;/&gt;  &lt;setting name=&quot;props2&quot; value=&quot;value2&quot;/&gt; …… &lt;/settings&gt; \n\n另外，之前配置事务管理器和数据源的方式如下：\n\n清单 6. 在 iBatis 中配置事务管理器和数据源的方式\n\n     &lt;transactionManager type=&quot;JDBC&quot; &gt;  &lt;dataSource type=&quot;SIMPLE&quot;&gt;  &lt;property name=&quot;JDBC.Driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;!-- 其他数据源信息省略 --&gt;  &lt;/dataSource&gt;  &lt;/transactionManager&gt; \n\n在 MyBatis 中调整为如下的方式：\n\n清单 7. 在 MyBatis 中配置事务管理器和数据源的方式\n\n     &lt;environments default=&quot;demo&quot;&gt;  &lt;environment id=&quot;demo&quot;&gt;  &lt;transactionManager type=&quot;JDBC&quot;/&gt;  &lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;JDBC.Driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;!-- 其他数据源信息省略 --&gt;  &lt;/dataSource&gt;  &lt;/environment&gt;  &lt;/environments&gt; \n\n通过 &lt;environments&gt; 来进行数据源管理，主要是为了简化在多套数据源配置之间的切换，比如开发和发布使用不同的配置。\n最后，在 iBatis 中指定映射文件的方式如下：\n\n清单 8. 在 iBatis 中指定映射文件的方式\n\n     &lt;sqlMap resource=... /&gt;  &lt;sqlMap resource=... /&gt;  &lt;sqlMap resource=... /&gt; \n\n在 MyBatis 中调整为如下方式：\n\n清单 9. 在 MyBatis 中指定映射文件的方式\n\n     &lt;mappers&gt;  &lt;mapper resource=... /&gt;  &lt;mapper resource=... /&gt;  &lt;/mappers&gt; \n\n上面的这些调整，主要出发点其实并不是使得 MyBatis 功能更为强大，而是使配置更为合理，让开发者更容易阅读和理解。\n到目前为止，我们主要讨论了 XML 形式的全局配置，其实这也不是唯一选择，MyBatis 还提供了通过代码来进行配置的方式：\n\n清单 10. 在 MyBatis 中使用代码进行配置\n\n     DataSource ds = …… // 获取一个 DataSource  TransactionFactory txFactory = new JdbcTransactionFactory();  Environment env = new Environment(&quot;demo&quot;, txFactory, ds);  Configuration cfg = new Configuration(env);  cfg.addMapper(UserInfoMapper.class);  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(cfg); \n\n结合前面的配置文件，很容易理解这段代码的意思，故不再赘述。不过，需要注意的是 Configuration 的 addMapper() 方法，该方法的参数通常是一个接口，可以在接口里面定义若干方法，在方法上使用注解来指定映射的 SQL 语句。一个典型的接口定义以及对应的数据访问方法如下：\n\n清单 11. 将映射的 SQL 语句与接口中的方法绑定\n\n     // 映射 SQL 绑定接口 public interface UserInfoMapper  {  @Select(&quot;select * from userinfo where userid = #{userid}&quot;)  public UserInfo getUserInfo(int userid);  }  // 接口绑定对应的数据访问方法 try  {  //UserInfo userinfo = (UserInfo) sqlSession.selectOne  (&quot;mybatis.demo.UserInfoMapper.selectUser&quot;, 2);  UserInfoMapper userinfoMapper =  sqlSession.getMapper(UserInfoMapper.class);  UserInfo userinfo = userinfoMapper.getUserInfo(1);  System.out.println(userinfo);  } finally  {  sqlSession.close();  } \n\n\n回页首\nMyBatis 映射文件的改变\nMyBatis 针对映射文件进行格式调整的地方很多，但大部分仅仅只是名称上的变化，现代的 IDE 都支持联想功能，可以很方便的获取到当前位置可以有哪些元素、哪些属性等。所以这基本不会给开发者造成什么麻烦。\n针对映射文件，首先是一系列的属性名称的改变，这些仅仅是名称的改变，用法和含义并没有发生变化：\n\n 和全局配置文件一样，由于 DTD 约束发生变化，根元素也由原来的 &lt;sqlMap&gt; 调整为 &lt;mapper&gt;。\n &lt;select&gt; 等元素的 parameterClass 属性改为了 parameterType 属性。\n &lt;select&gt; 等元素的 resultClasss 属性改为了 resultType 属性。\n &lt;parameterMap&gt; 等元素的 class 属性改为了 type 属性。\n &lt;result&gt; 元素的 columnIndex 属性被移除了。\n 嵌套参数由 #value# 改为了 #{value}。\n &lt;parameter&gt; 等元素的 jdbcType 属性取值中，原来的 &quot;ORACLECURSOR&quot; 取值改为了现在的 &quot;CURSOR&quot;，&quot;NUMBER&quot; 取值改为了 &quot;NUMERIC&quot;。\n\niBatis/MyBatis 对存储过程的支持一直是值得称道的。之前通过使用 &lt;procedure&gt; 元素进行存储过程的定义，示例如下：\n\n清单 12. iBatis 中调用存储过程的方式\n\n     &lt;procedure id=&quot;getValues&quot; parameterMap=&quot;getValuesPM&quot;&gt;     { ? = call pkgExample.getValues(p_id =&gt; ?) }  &lt;/procedure&gt; \n\n在 MyBatis 中，&lt;proccedure&gt; 元素已经被移除，通过 &lt;select&gt;、&lt;insert&gt; 和 &lt;update&gt; 进行定义：\n\n清单 13. MyBatis 中调用存储过程的方式\n\n     &lt;select id=&quot;getValues&quot; parameterMap=&quot;getValuesPM&quot; statementType=&quot;CALLABLE&quot;&gt;     { ? = call pkgExample.getValues(p_id =&gt; ?)}  &lt;/select&gt; \n\n如上所示，通过 statementType 属性将该语句标识为存储过程而非普通 SQL 语句。\n\n回页首\n代码层面的改变\n通过前面的示例可以看出，MyBatis 在编码中的最大的改变就是将一个最常用的 API 由 SqlMapClient 改为了 SqlSessionFactory。另外，类型处理器接口也由原来的 TypeHandlerCallback 改为了 TypeHandler。最后 DataSourceFactory 也进行了调整，移动到 org.apache.ibatis.datasource 包下，其中的方法也作了微调。总之，代码层面公开的部分改动较少，不会给开发者造成较大的移植成本。\n\n回页首\n总结\n本文主要描述了从 iBatis 向 MyBatis 移植过程中可能遇到的问题，大部分的变化已经体现在上文中，如果希望从头开始学习 MyBatis，则建议从头开始阅读官方的 user guide 文档。\n\n参考资料 \n学习\n\n 参考 MyBatis 官方网站，这里有丰富的学习文档。\n 浏览 寄放在 Google Code 上的 MyBatis 项目，这里可以下载源码、发布包和文档。\n 随时关注 developerWorks 技术活动和网络广播。 \n 访问 developerWorks Open source 专区获得丰富的 how-to 信息、工具和项目更新以及最受欢迎的文章和教程，帮助您用开放源码技术进行开发，并将它们与 IBM 产品结合使用。\n\n讨论\n\n 加入 developerWorks 中文社区，developerWorks 社区是一个面向全球 IT 专业人员，可以提供博客、书签、wiki、群组、联系、共享和协作等社区功能的专业社交网络社区。\n 加入 IBM 软件下载与技术交流群组，参与在线交流。\n\n关于作者\n张建平，长期专注于 Java 技术，精通 SpringSource 框架集 (Spring Framework，Spring Security，Spring Roo 等 )，善于使用基于 Spring 和 Hibernate 为中心的轻量级框架进行项目开发，并对 Java EE 规范有深入研究，擅长使用 EJB 和 JPA 进行复杂业务的架构和开发。\n&nbsp;\n引用：http://www.ibm.com/developerworks/cn/opensource/os-cn-mybatis/\n\n        ', null);
INSERT INTO `blog` VALUES ('80', '正则表达式', '\n            \n \n\n^表示字符串必须以后面的规则开头, 在这里就是说字符串必须以\\s*开头.\n\n\\s 是空格的意思, * 表示有0个或多个\n\n\\s* 就是有0个或多个空格\n\n(^\\s*) 表示的就是以0个空格或者多个空格开头\n\n| 表示或的意思, 也就是满足| 左边的也成立, 满足 | 右面的也成立.\n\n\\s*前面说过了\n\n$ 的意思是字符串必须以前面的规则结尾\n\n(\\s*$) 的意思就是, 以0个空格或者多个空格结尾\n\n/.../g  是正则表达式的属性, 表示全文匹配, 而不是找到一个就停止.\n\n所以这个正则表达式替换的就是前导空格和后导空格\n因为有前导空格, 就说明以0个或多个空格开头, 满足正则表达式中 | 前面的条件: (^\\s*)\n而如果有后导空格, 就说明以0个或多个空格结尾, 满足正则表达式中 | 后面的条件: (\\s*$) &nbsp;\n//g就是表明是用正则表达式，g表示全局搜索\n\n(^\\s*) ^表示串开始,\\s表示任意一个空字符,比如空格.制表符啥的,*表示前面的字符0个或多个,也就是匹配串前面的任意长度空字符\n\n| 表示或,表示同时匹配\n\n(\\s*$) $表示串最后,也就是匹配串最后的任意长度空字符\n\n\n也就是说这个表达式匹配串前后的空格等空字符  正则表达式的介绍:\n\n1.可以使用字符作为一个通配符来代替除换行符(\\n)之外的任意一个字符,例如: .at可以与&quot;cat&quot;,&quot;sat&quot;,&quot;mat&quot;等匹配.通常,这种通配符用于操作系统中文件名匹配.\n\n2.[a-z],任何含在[]中的内容都是一个字符,只匹配一个字符.\n\n如:[a-zA-Z]代表任意大小写字母.\n\n3.[^a-z].匹配任何不属于a-z中的字符.\n\n4.[a-z&amp;&amp;[hij]].匹配hij任何一个(交集)\n\n5.\\s.匹配空字符(空格,tab,\\n,换页,回车)\n\n6.\\S.匹配非空字符(和[^\\s]一样)\n\n7.\\d.匹配数字,相当于[0-9]\n\n8.\\D.匹配非数字,相当于[^0-9],匹配中文,空格,换行符\n\n9.\\w.匹配词字符,相当于[a-zA-Z0-9],不包含中文,不能代表空格,换行符\n\n10.\\W.匹配非词字符,相当于[^\\w],匹配一个中文字\n\n逻辑运算符:\n\n|:管道符.如:x|y表示x或y\n\n():捕获组.(abc)|(xyz)表示abc或xyz\n\n边界匹配符:\n\n^:从头匹配\n\n$:从尾匹配\n\n\\b:词界.\n\n\\B.非词界\n\n量词:\n\n量词描述一个模式吸收输入文本的方式.\n\n*:前面字符或组匹配0或多个\n\n+:前面字符或组匹配1或多个\n\n?:前面字符或组匹配0或1个\n\n{n}:前面字符或组的数量为n个\n\n{n,}:前面字符或组的数量至少n个\n\n{n,m}:前面字符或组数量至少n个,最多m个 1.可以使用字符作为一个通配符来代替除换行符(\\n)之外的任意一个字符,例如: .at可以与&quot;cat&quot;,&quot;sat&quot;,&quot;mat&quot;等匹配.通常,这种通配符用于操作系统中文件名匹配.\n\n2.[a-z],任何含在[]中的内容都是一个字符,只匹配一个字符.\n\n如:[a-zA-Z]代表任意大小写字母.\n\n3.[^a-z].匹配任何不属于a-z中的字符.\n\n4.[a-z&amp;&amp;[hij]].匹配hij任何一个(交集)\n\n5.\\s.匹配空字符(空格,tab,\\n,换页,回车)\n\n6.\\S.匹配非空字符(和[^\\s]一样)\n\n7.\\d.匹配数字,相当于[0-9]\n\n8.\\D.匹配非数字,相当于[^0-9],匹配中文,空格,换行符\n\n9.\\w.匹配词字符,相当于[a-zA-Z0-9],不包含中文,不能代表空格,换行符\n\n10.\\W.匹配非词字符,相当于[^\\w],匹配一个中文字\n\n逻辑运算符:\n\n|:管道符.如:x|y表示x或y\n\n():捕获组.(abc)|(xyz)表示abc或xyz\n\n边界匹配符:\n\n^:从头匹配\n\n$:从尾匹配\n\n\\b:词界.\n\n\\B.非词界\n\n量词:\n\n量词描述一个模式吸收输入文本的方式.\n\n*:前面字符或组匹配0或多个\n\n+:前面字符或组匹配1或多个\n\n?:前面字符或组匹配0或1个\n\n{n}:前面字符或组的数量为n个\n\n{n,}:前面字符或组的数量至少n个\n\n{n,m}:前面字符或组数量至少n个,最多m个\n\n^表示字符串必须以后面的规则开头, 在这里就是说字符串必须以\\s*开头.\n\n\\s 是空格的意思, * 表示有0个或多个\n\n\\s* 就是有0个或多个空格\n\n(^\\s*) 表示的就是以0个空格或者多个空格开头\n\n| 表示或的意思, 也就是满足| 左边的也成立, 满足 | 右面的也成立.\n\n\\s*前面说过了\n\n$ 的意思是字符串必须以前面的规则结尾\n\n(\\s*$) 的意思就是, 以0个空格或者多个空格结尾\n\n/.../g&nbsp; 是正则表达式的属性, 表示全文匹配, 而不是找到一个就停止.\n\n所以这个正则表达式替换的就是前导空格和后导空格\n因为有前导空格, 就说明以0个或多个空格开头, 满足正则表达式中 | 前面的条件: (^\\s*)\n而如果有后导空格, 就说明以0个或多个空格结尾, 满足正则表达式中 | 后面的条件: (\\s*$)&nbsp;\n\n\n任务提醒\nx\n\n        ', null);
INSERT INTO `blog` VALUES ('81', '一个小公司老板的日常管理，希望能让创业的朋友学到东西', '\n            \n \n\n1. 小公司如何留住骨干：2.关于授权3.有的钱不能省5.关于招聘6.老板尽量唱红脸7.公司里的亲戚8.当老板和开车9.按时发工资10.学会说“不”11.不要在公司内部奢望交朋友12.避免当场做决定13.政策的制定14.矬子里拔将军15.有些事情越透明越好16.发劳保用品17.财务制度之签字与凭证18.关于股份制，分红与年终奖19.关于涨工资20.充分运用科技手段进行管理21.从结果管理到过程管理\n&nbsp;\n1. 小公司如何留住骨干：　　这些年物价上涨，费用上涨，公司利润却未涨多少。每个员工都希望工资大幅增加，但估计90%以上小公司无法做到这点。有时我这当老板的恨不得将公司门一关，自己拿着资金炒股或炒房，图个清净。虽说近几年由于给每个员工上5险1金，人均费用每月增加几百元，但员工并不领情，员工只算每月到手多少钱，至于公司的支出与己无关。　　既然无法让所有人都满意，我就只满足公司20%的骨干。　　首先发展骨干员工入股：我将公司股份买一送一，半价销售给骨干员工，五年内退股只退还本金，五年以上退股我三倍赎回。每年拿出利润的60%分红。反正有钱大家赚，但股东一旦做了对不起公司的事，加倍惩罚，由股金中扣除。这招还真好使，在近5年里没有一个股东离职，而且公司重点岗位都有股东，省了我不少精力。　　为什么不白送骨干员工股份？其实我并不是在乎钱，主要是白给的东西别人不珍惜，而且入股的钱又可作为押金，以防股东做出格的事，再说员工入股的钱不出5年即可通过分红收回，不投入哪来的产出啊\n2.关于授权　　记得公司刚有十几个人的时候，全公司我最忙，经常同时接两三个销售电话，还得安排送货，结账，进货，每天来得最早，走得最晚。一次我弟弟到公司，看了半天，发表感慨说：“哥我怎么觉得你在养活公司所有人哪？”我当时还挺自豪。结果公司四五年也发展不大，一直十几个人，而且公司员工感觉备受压抑，无发展空间。后来终于明白该放权就得放权，哪怕员工只能做到你的70%。有时候真着急啊，明明能谈下的客户销售人员就是差那么一点谈不下来，恨不得立刻自己冲上去，该忍还得忍，要不手下员工如何进步。　　小公司发展过程中15人是个坎，50人是个坎，200人又是个坎，管理方法不改进，一般无法进一步发展。老板事事亲力亲为的公司，很难过15人。一个人能力强，可直接管理七八个人，能力一般，则只能直接领导四五个人。各个国家效率最高的部门就是军队，看看军队的组织结构：一个班十一二个人，除班长外还有一个副班长，三个班一个排，三个排一个连，以此类推。团长管一千多人，可能只认识其中百十来人。团长看见某个士兵有问题，绝对不会骂士兵，他只会骂士兵所在营的营长，营长则再骂连长，一级管理一级，最后班长把该士兵剥皮了事。所以军队尽管有千军万马，依然能做到令行禁止。　　现在客户找我买东西，我经常说：“哎呀真对不起，价格我不知道，我给您介绍个销售人员，我让他跟您联系吧。”3.有的钱不能省　　刚创业时也就一两个人，自己销售，进货，维修，跑银行。当时没有注册资金，借朋友的营业执照。自己到外面学习了几个月会计就开始瞎做报表。月底到税务局报税，报表一交，专管员看了两眼，开始问问题。问的问题我根本不明白，更别说回答了。专管员一脸不高兴，问：“你懂不懂？”。我陪着笑脸：“不懂，不懂。”“不懂你来干嘛。换个懂的来。”“好，好，下次一定换个懂的来。”下个月我又瞎做了张报表去税务局报税。专管员显然对我又印象：“怎么又你来了？”我只好顺嘴胡编:“会计怀孕来不了，只好我来。”。“！” 。第二天我就找了个会计公司，一月300元钱，以后再不自己跑税务局了。一直到公司十几个人，我仍然让会计公司做账，公司只有一个出纳，没有专职会计和库管。随后几年业务开展的不错，没少挣钱，可年底公司帐上资金却没增多少。后来我发现公司只要一过十个人，老板一人根本看不过来，整个公司就像个筛子一样，到处都是洞，能剩下钱才怪。指望公司员工都是焦裕禄和雷锋，门都没有，哪怕提成给员工70%，他还会惦记剩下的30%，傻瓜才不贪污。只有制度健全，让心数不正的人无懈可击，才能管好公司。感谢我现在的会计，工作极为负责。下辈子再办公司，公司只要有4个人，一定是一个老板，一个会计，一个出纳，一个库管，打死再不省那点钱了。\n　　这句话放在90%的公司身上是对的，当然，如果您觉得自己是那剩下的10%，也不妨一试。　　一般公司只要能坚持个三五年，挣了点钱，老板就开始琢磨再干点什么。大部分人总觉得自己的行业不如别人的行业挣钱，很不幸，我就是其中一个（我觉得自己的经历整个可编个小企业错误大全）。上世纪末，脑袋一热，开了个饭馆，从此厄运开始了。当初本人觉得自己销售方面颇有天赋，开饭馆肯定没问题。谁知这该死的饭馆光有销售根本不行，做的不好吃别人最多只来一次。本人不好吃喝，也没耐心和大厨琢磨新菜。而且开饭馆不光进货结账，卫生防疫，工商公共安全专家样样要跟上，起早贪黑累的要死，跟开公司不一个路数，本人实在没耐心，找了个公司部门经理去负责，管得一塌糊涂，半年赔了几十万，关门了事。现在谁再跟我提开饭馆我跟谁急，去饭馆吃饭行，别的一概免谈。　　如各位有兴趣要开饭馆，一定先想明白以下几点：　　A: 你是否能起早贪黑吃得了苦　　B: 如是接别人转让的饭馆搞明白上家为何转让（不可只听一面之辞，一定在该饭馆蹲两天）　　C: 饭馆租金，人员开销等费用核到每天每张桌子是多少钱，饭馆定位，面向什么层次客户，一天能翻几次台，平均每桌消费多少，毛利率多少，是否能赚回来（一定要掰着手指头算好，不行连脚趾头一块上，否则赔死你）。　　D: 附近的工商，卫生，公共安全专家，地痞流氓你是否搞得定。　　E: 停车问题。　　F: 找大厨。找着后如何管理，是后厨承包还是流水提成？　　G: 你老婆是否愿意做采购或找个向你老婆一样对你忠心的人做采购。　　H: 饭馆服务员可得管吃管住，而且工资近期增长很快，预算要留出富裕。计算不好你就只能剥削你自己外加你爸你妈你老婆。　　I：……还有N多问题自己想吧。　　据我的经验，饭馆和美容美发都不好干，只要看看报纸上转让信息就知道，基本就这两个行业。　　另：本人的副业还曾有过服装，节电设备等，都没挣到钱。本人比较惭愧，从未在大公司待过，也未系统地接受过管理培训。刚毕业时虽进入大部委工作两年，可惜职务太低，没学到真谛。一说起管理，总感觉别人讲得头头是道，就好像武侠小说里的名门正派，而自己则是街头打群架的小混混出身，没有理论，只有教训。有时感觉成功是不可以复制的而错误则是可以重复的。比如大家就算知晓了微软运行的每一个步骤也不可能成为另一个比尔盖茨，但若有人像我原来一样不重视财务管理十有八九公司在钱财上会有损失。　　在随后一段时间内，我会把自己的经验教训逐步列出，想到哪写哪吧。不过各位新创业的朋友读过我的文章后估计还会犯同样的错误，只是希望大家犯的错误小点，过程短点，毕竟在岸上看过一百遍游泳教学片下水后还得喝点水。\n　5.关于招聘　　这些年没少招聘，几年前最多时我一下午面试五六十人。刚开始没有经验，每回招人都找最好的，工资一千多的售后服务岗位经常招名牌大学本科生，英语过四级。后来发现，招来人根本留不住。本来简单工作的岗位中专生完全能够胜任，找个本科生双方都不合适，只是在写公司简介时方便吹牛。另外面试时应聘人员说的话不可全信，有时对方刚失去工作后比较失落，为得到新工作，他们什么都敢承诺。某次公司招聘商务，岗位工资定为两千左右，一个女孩投简历面试，本科学历，3年工作经验，上份工作工资在两千五，我问她这次工资比上份工作工资低，能否接受。她毫不犹豫表示没问题。由于她比较适合商务职位，我就录用了她。半个月后，前任商务和她交接完离职后第二天她也离职，理由居然是工资低，搞得公司非常被动。再次招聘我招了个原工资一千五百元的女孩，现在还在该岗位，不但干得好，而且对工资也很满意。大部分人对待新工作职位及待遇都是只能上不能下，能上能下的人太少了，Dengxp应该算一个。　　招人的经验是：宁可漏过一千，不可错招一个（源于历史上某个著名人物语录）。据我的经验，公司招聘如低一档用人，高一档发工资效果比较好（也就是招三流的人才，干二流的工作，发一流的工资。当然，以上一流三流都是相对的）。招聘时应不嫌麻烦，仔细核对应聘人员身份。去年我公司连续发生两起新员工携款潜逃事件，打电话找人时对方有恃无恐：反正我应聘时的身份证学历证家庭住址都是假的，几千块钱pol.ice都不管。别说pol.ice还真不管。现在招聘，本地人公司都一一核实，外地人一律要有本地人担保，弄虚作假者一概不要。从此再无类似情况发生。　　对于下岗职工我个人有一定偏见。大部分下岗职工，特别是岁数稍大的国营单位下岗职工基本上牢骚满腹，觉得社会对他不公，而且把不满情绪及原单位的种种不良习气都带到新公司，觉得公司给他什么福利都是应该的，别人都欠他的，很难融入新公司，踏实肯干的占少一部分。大概私营企业不适合下岗职工吧。此外亲戚朋友能少用就少用吧，这个话题以后我还将涉及。\n6.老板尽量唱红脸　　每天公司里总有很多事发生，有的应该表扬，有的应该批评。批评和表扬到底该由谁来执行呢？　　刚干公司时，找不着当老板的感觉，平素又最烦管人，所以员工有什么问题我很少说。结果公司员工自由散漫，谁也不服谁，工作无法开展。后来觉得再这样下去实在不行，于是开始板起脸管人，这下新的问题又出来了，公司里几乎所有的矛盾都集中到我和公司员工之间，经常有员工当面与我理论是非曲直，这老板当的真郁闷，而我又实在不想当一个声色俱厉的管理者。后来与日本企业接触多了，发现不少奥秘。日本公司总经理很少骂公司普通员工，对公司底层员工可和蔼了，但他经常当着员工的面训斥公司中层干部，而普通员工犯错误则由该员工的直接领导负责处理，当然月底发工资时总经理心里可不含糊，这样公司不仅管理得井井有条，而且员工心里也比较平衡。　　他山之石可以工玉，说干就干，咱公司不大，好歹也有几个主管。于是开会明确职责，谁的手下出问题谁自己处理，别什么问题都往我这推。平常我一般只表扬好人好事，鼓励为主，而主管自身犯错时我也很少当众批评，通常是私下交流。时间不长，公司管理顺畅了，我在公司里的形象也大为改观，员工更尊敬我了。　　有时觉得，老板对于公司有点像古代皇帝对于国家。如果皇帝很贤明而大臣很昏庸，老百姓通常觉得国家还是有希望的，大不了清君侧，换个大臣了事。而如果皇帝很昏庸，则老百姓通常觉得这个国家没希望了，开始琢磨造反改朝换代。咱当老板总不能让公司员工揭竿而起或用脚表态一走了之吧，既然主管和部门经理享受着公司岗位津贴当然应该为老板分忧，该唱黑脸作恶人时就应当仁不让，而老板一般应保持一个超然的态度，置身于事件之外，旁观者清吗。不过部门经理需要支持时，只要不是原则性错误，我通常态度鲜明予以支持。\n7.公司里的亲戚　　这个问题，我只有教训，没有经验。还好，老婆工作单位一直不错，世界500强，对我的小公司没什么兴趣，因此公司刚成立时，我根据平时耳濡目染的各类情况，决定尽量不用亲戚朋友。后来公司到一定规模时，外地一个长辈打来电话，说她儿子（也就是我表弟）毕业一年，在当地我们这个行业的一个小公司当业务员，收入不是很高，希望来北京发展。我这个亲戚家庭比较困难，其中一个孩子因为特殊情况无法上班，而要来北京的这个表弟我原来见过，现在十八九岁，相当聪明，当时想公司正缺人，用谁不是用，因此我爽快地同意了。　　表弟刚来北京时，吃住都在我父母家，年轻人和老年人生活习惯不同，搞得我妈经常找我抱怨。过了一段时间，我将其安排到公司宿舍，算是解决了问题。表弟人很机灵，又会来事，几个月时间就完全适应公司环境，而且在部门里业务完成的很好，提成总在前几名。后来我发现，表弟经常在公司里表白自己的特殊身份，对同事吆五喝六，公司其他员工反响很大。为此我找他谈过几回，他都表示一定改正，不过收效不大。转眼一年过去，表弟在这个行业里已经如鱼得水，挥洒自如。这时，表弟找我说他在老家有几个同学，又聪明又可靠，希望带过来一起在公司发展。我想这是好事啊，来吧，照单全收。麻烦开始了。　　表弟和他的几个朋友吃住都在一起，相互之间只说家乡话，公司里除了我谁也听不懂。而且他们虽在不同部门，但被部门主管察觉他们相互勾结挣黑钱。表弟非常聪明，他散布说公司股东之间有矛盾，他是我这一派的，让他的直接主管不要站错队，否则后患无穷。公司不少员工真被他唬住了，过了一段时间，问题才反映到我这来。公司对待此类问题一向是第一次罚款警告，第二次开除。我和表弟谈了一回，他拍胸脯表示绝不再犯类似错误。没过一个月，又有部门主管向我反映表弟的小团伙在干黒活，而且不但不避讳其他员工，甚至鼓励其他人一起干。我真的很为难，再不管该养虎为患了，我还指望公司做强做大，让一起创业的股东老有所依呐。长痛不如短痛，一咬牙，我将表弟和他的小团伙陆续请出了公司。公司业务为此震荡半年。　　表弟靠着从公司带走的客户，现在还在这个行业做，每年也挣不少钱还买了车。　　亲戚朋友能不用还是不用吧，否则最后亲戚朋友也没得做了。　　曾经听过其他公司老总讲他在公司做大后如何对待亲戚。他的五六个亲戚在他创业时不计得失帮他干，做大后亲戚跟不上公司发展步调，且占据高位不好管理。这时，他采取牺牲钱财保全亲情的方法：岁数大的给一笔钱帮其另外创业，岁数小的公司出钱送到国外留学并负担所有开销，读成MBA后帮其再找工作从而顺利解决这一棘手问题，高！\n8.当老板和开车　　去年回老家，坐一个亲戚开的车。亲戚刚拿本没多久，属于实习司机。一道上马路又宽又直，司机的手却在不停地动，左一下右一下，车也在画龙，我坐在副座上，心里很紧张，系上安全带，嘴里话也少了，脚下直使劲，旁边车道上的车不停地在按喇叭，还好，最后终于安全到达。回想十年前自己刚拿本时，已是老司机的弟弟坐我的车也提过同样问题，当时自己信心很足，根本不理解坐车的人怎么会有这种感觉，现在方才明白。　　总结自己开公司，也经常犯类似的错。政策朝令夕改，看见别的公司有什么新章程常常一拍脑门拿来就用，过段时间发现效果不好又推倒重来，弄得公司员工无所适从。原有的提成奖励方法有的已经很好，经过实践检验较为合理，员工也认可，偏偏听完什么专家讲座或看完某本管理书后，不经过深思熟虑并结合公司实际情况进行改造照搬照抄，立刻重新制定政策，结果会计抱怨不好操作，员工抱怨政策不合理，一通折腾后又改回原样。　　现在常想，办公司和开车很像，老板就好比驾驶员，车在路上跑，只要在本车道的两条白线内就OK，不必时刻调整方向盘，否则司机累，乘客累，车还画龙易出危险，费力不讨好。同样办公司只要公司运营在可控范围内不犯大错，政策就应稳定执行，保持连贯性，让员工心里有底。小公司老板权力集于一身，缺乏监督，制定政策更应该小心谨慎，不然公司总在调整，员工缺乏稳定感，不跑光才怪呢。想想当初Dengxp为什么承诺香港回归后体制50年不变。\n　9.按时发工资　　其实这一条是当老板最基本的素质。估计每一个老板都不会反对这一点（至少在口头上不会反对），但实际情况是很多公司做不到这一点。　　公司在日常运营时，会经常遇到资金紧张的情况，比如月底或年底压一批货从厂家拿个高额折扣，做工程甲方押着工程款未能及时支付，银行贷款到期需立即归还等等，所有这一切对于老板来说都是未能及时发工资的充分理由。老板一般想：又不是不发工资，只不过稍微晚几天，公司资金紧张，员工应该理解。真实情况是：无论任何理由，对于不按时足额发工资，员工都无法理解。员工的工资不是老板赏赐的，而是他辛苦所得，没准他正等着到日子拿工资交房租，还月供或支付孩子的学费。未能及时领到工资员工可能马上就会面临生存问题。正常情况下，老板兜里的钱总比员工活分些，所以老板经常想当然认为员工晚拿几天工资没关系。　　那么如果碰到资金紧张时该怎么办？一般情况下，做生意量力而行吧，有多少本挣多少利，不行就找银行贷款。如果银行贷不到款，也可公司内部或亲戚朋友之间集资，讲明用钱的地方，谈好借款期及利息，大部分员工对于公司有把握的业务还是愿意参与的。到月底实在发不出工资，如果公司还想继续做下去，老板还是先从自己做起把私房钱拿出来吧，还不够把房子车子先典当了，资金周转过来再赎回。　　拖欠工资这事有点像吸毒，有一回就会有第二回，只要资金一紧张老板就会用拖欠员工工资来缓解，结果员工对公司和老板的信任荡然无存。调查表明，员工对于公司最无法容忍的就是拖欠工资，这也经常是某些企业人员流动的最主要因素。\n10.学会说“不”　　中国人好面子，“不”字很难说出口，而老板又是公司的最后一道关口，有时不得不拉下脸说“不”。　　我们公司有规定，公司的钱一律不借个人，当然，特殊情况员工可以预支部分工资。前两年，公司一个骨干员工找我聊天，他问：“如果公司里一个员工，对公司贡献是其他人的好几倍，公司会不会借钱给他？”对这个问题我真的很犹豫，想了半天，我说：“公司有规定，公司的钱一律不借个人。”他还不甘心，又问：“对骨干员工也这样？”。我说：“对所有人公司一视同仁，骨干员工工资奖金可以多发，可以优惠条件入股，但对于这项规定谁也不能例外。”随后我问他是不是自己要借钱，他承认说要买房子想借三十万。我很奇怪，买房可找银行贷款呀，这个员工说找银行贷款要付利息和手续费，想着找公司借钱可以不付利息了。后来我了解到他已经有一套住房想着再买一套住房等升值挣钱呢。一年后，该员工因为其他原因离职了。想想当初要是借钱给他，此时还真不好要回来。回绝过一回，以后类似情况就好处理了。这些年，公司包括我在内的所有股东买房钱不够都是找银行贷款，没人借用公司流动资金。想想公司再有钱又怎能代替银行的功能。　　有时公司的不少规定都有特殊情况，但在原则问题上老板一定站稳立场，规定面前人人平等，所谓不患多寡患不公，没有不透风的墙，只要开了先例以后其他员工就不好管了。近些年媒体上不是一直嚷嚷要法制不要人治，一定有他的道理。当老板该说“不”时就说“不”，无论对谁，虽然当时被人骂难受一下总比公司歇菜难受一辈子强，有很多公司就因为老板抹不开面子盲目给别人担保或随意借款给人结果最后自己公司倒闭了。当老板不对自己的公司负责别人是不会为你着想的。\n　11.不要在公司内部奢望交朋友　　 刚当老板时不习惯管人，总觉得公司里应该人人平等，大家都是朋友，有什么事好商量。干了一段时间后，感觉公司里比较混乱，制度形同虚设，犯错误成本非常低，大家日常基本是想干啥就干啥，月底工资还谁也不能少发。　　一天，一个在大公司工作的朋友到我这待了半天，走时深有感触地对我说：你这管理要加强啊，在公司半天都看不出谁是老板，员工既不怕你也不听你呀。我听后觉得很有道理，但具体怎么做也搞不明白。后来问题终于集中爆发了，公司里贪污现象严重，效率低下，员工觉得没有奔头，几个骨干自己一合计单挑一滩，十几个人的公司跑了七八个并带走了一半客户。　　好在此时我还有另外一个较小的分公司，新招了几个业务员。毕竟本人是白手起家，心理承受能力足够强，一咬牙重新开始。这次吸取教训，制定严格的规章制度并认真执行，业务很快有了起色，一年后人员又恢复到十几个，利润也超过以前。　　想想还是自己当初还是心态不对，认为自己的公司应象国营企业一样，人人都是公司的主人翁，人人都平等，大家自觉把事干好，纯粹是扯淡。公司内部大家利益不同，岗位不同，哪来什么绝对平等。虽然大家人格上是平等的，但岗位职权工资奖金上怎么可能平等呢？为什么除了垄断行业外，大部分国营企业都倒闭了？因为国营企业的经营观念管理方法不符合目前的市场经济和社会环境，我觉得我们从小接受的教育从根本上不符合人的本性。当初红灯记里鸠山说“人不为己天诛地灭”一直被当作反面典型加以批判，其实我现在认为这话好像符合每个人自然的第一反应。世人熙熙皆为利来，使人攘攘皆为利往，连出家的和尚都明白这个道理。当老板就当老板吧，甘蔗没有两头甜，我不再奢望与公司员工做朋友，一切按规章制度来，只要管理好公司，让大家尽量拿到更多的工资奖金，人人都上保险，骨干员工入股共享公司发展成果，对得起自己的良心就完了。老板本来就是个孤独的职业，交朋友就在公司以外吧。　　要说规章制度，每个稍具规模的公司都有一大本，但不同公司的管理水平相差可大了去了，关键还在于规章制度是否被认真执行，老板能不能自己认可规章制度并亲自或安排专人监督落实。规章制度执行好了，人员管理就水到渠成，一切按规矩来，老板也无用一天到晚训斥员工。其实，从办公司到现在，我没有骂过任何一个员工，有几次公司员工离职后又回来，原因竟然都是无法忍受新公司老板发脾气骂人，呵呵，不过我感觉现在我在公司还挺有威信，至少朋友来公司不会说看不出谁是老板了。\n　12.避免当场做决定　　影视作品，报纸广播里经常有这样的场景：领导干部现场办公或下基层走访，有人民群众扶老携幼涕泪滂沱地反映当地官员久拖不决的某些问题，领导同志大手一挥，无比激动地斥责那些不作为的贪官污吏，该免职的免职，该法办的法办，几年解决不了的问题五分钟之内现场解决，真是大快人心，爽！　　当老板没多久，公司人员渐渐多起来，我的领导欲望也逐渐膨胀，常常脑袋一热手一挥解决问题。有一回，业务员甲向我投诉，另一个业务员乙恶性竞争抢他的客户，同一单生意故意报低价致使用户未从甲业务员处购买，公司也在利润上受到损失。我一听，非常生气，这种极端自私的行为如何能够容忍，于是贴出通知：此担生意，乙业务员不仅没有提成，而且通报批评，所有提成奖励归甲业务员。后来乙业务员反应激烈地找到我说该用户他已经跟了半年多，价格型号都基本谈妥，前些天有次他外出拜访其他用户时该用户打电话到公司落实细节问题结果甲业务员接了电话，过后甲不仅未转告乙业务员，而且还让用户直接找甲业务员自己并许诺更多优惠，差点将生意搅黄。我听完后非常诧异，怎么与甲说的完全不一样啊。后又找其他几个业务员核实，乙业务员说的基本属实。唉，通告已经张贴了，这可如何是好？于是一通补救并制定相应规章制度避免以后类似情况发生。过后反思：当初为什么不调查一下再做决定呢？如果乙业务员性格内向些没准不找我申辩直接开路走人了，这对公司损失更大而且公司其他员工又会有何想法呀。再回想最近经常快速做出一些鲁莽的决定，非常后悔，看来官僚的口头禅：这个问题要考虑考虑研究研究确有其道理。过去的皇帝金口玉言，说的话不能随便改，今天的公司老板也不能不过脑子不全面调查随口做决定，否则天天朝令夕改威信尽失。　　现在员工找我解决问题我一般都说：行，我知道了，等我查一下，几天之内给你回复。这样类似错误就很少发生了。看来做事不能只图一时痛快，要全面考虑，职位越高越应避免当场做出决定。要不怎么很多人感觉大公司办事反应慢，估计如果大公司反应都向个体户一样快很快大公司也就变成个体户了。\n13.政策的制定　　经过几年的努力，公司终于拿到某个著名品牌在北京的代理权，我非常高兴。为完成该品牌在北京全年的销售任务，公司召开销售会议，在会上，我详细给销售部每个员工布置了任务，订好全年的销售目标。　　三个月过去了，公司代理品牌的销量未能达到年初制定的季度销售目标，什么原因呢？公司整体销售不错呀，只是所销售产品品牌比较分散，难道是业务员不擅长销售主打产品？销售培训没跟上？　　偶尔听到业务员之间的对话让我解开了谜团。　　下班后，我正准备走，听到门外两个业务员在聊天.　　甲业务员：“今天你卖得不错呀，一单就走了5万多。哎你为什么不推咱主打产品呀？”　　乙业务员：“顾客用惯了另一个牌子，再说卖那一个牌子利润多500元，我的提成不也能多一百多吗。”　　原来如此。按说乙业务员不仅是公司骨干而且还是公司小股东，他尚且如此，更别说其他业务员了。　　我反省了半天，错误还在我。卖主打产品虽说有时眼前利润可能稍小，但如果考虑售后服务成本及完成任务后厂家的各种促销支持还是利大于弊的，关键是这些员工并不关心，他们只关心自己的收益，毕竟人的本性是自私的（呵呵，不符合主旋律，不和谐），还是公司的销售政策没定好。　　第二天，我重新制定了销售奖励政策，向主打产品倾斜，凡销售主打产品不光有利润提成，还有流水提成，而且每季度如完不成主打产品流水任务将影响该季度的季度奖。政策一改，立竿见影，当年第二季度主打产品销量顺利完成。　　一般来说，公司员工的利益与公司老板的利益是不一致的，二者之间经常会有冲突。指望公司员工牺牲个人利益去成全公司利益基本上是天方夜谭。但老板有老板的优势，老板是公司政策的制定者，他可以利用人趋利避害的本性制定政策，将公司员工利益尽量与公司利益统一起来，让二者一荣俱荣，一损俱损。这样根本不需要做思想工作，员工自己就朝着老板希望的方向使劲了。就像古代大禹治水一样，疏导为主，堵塞为辅。一个明智的政策必须符合人的本性，所有那些假大空的言论都应该被摒弃。有些领导（包括我原来就经常想少发奖金，多给员工讲人生哲理）在台上给员工做报告大道理一套一套，说的话有时自己都不信，现在谁比谁傻呀，无利可图，政策不对头再讲大道理也没用。上个世纪农村实行土地承包制改革，一包就灵，归根到底还是因为政策终于符合了人的本性。\n　14.矬子里拔将军　　公司销售部很长一段时间没有主管，十几个业务员都由我来管，不是我不想设立主管，而是觉得部门里几个骨干能力差不多，没有特别突出的，并且由于行业的限制及所制定的销售政策决定了每个业务员基本上都是单打独斗，相互之间合作很少，日子长了大家都变得比较自私。而其他员工能力与骨干员工比差的比较多，流动性也比较大，因此销售部无部门负责人。　　于是每天我除了与其他几个部门经理沟通外还得对销售部十来个人事无巨细进行管理，烦死我了。销售部有事与其他部门协调时由于本部门无主管，其他部门经理经常不买账。地位不对等呀，于是又来找我，唉。　　实在难以忍受，矬子里拔将军也得提拔一个销售部主管。　　于是制定提拔标准，再根据业绩，能力，与其他同事相处是否融洽等考核，终于选出了一个主管，虽然不是很理想，一边干一边培养吧。　　一年过去了，主管并不十分出彩，但日常事务倒也管得井井有条。原来公司到货时需要卸车，销售部公共区域卫生需要打扫，节假日值班安排等头疼的事都需要我亲自去指派，有时还得又唱红脸又唱黑脸。现在好了，有主管了，既然每月多拿几百元岗位津贴当然就得承担更多责任，食君俸禄为君分忧吗，我只要找到销售主管，让他安排就行了。此外如联系厂家安排新产品培训，与其他部门协调等工作我都交给销售主管去做，一年也未出什么大错。看来有个平凡的主管也比没有强呀。人的能力不是天生的，就像蜜蜂一样，刚出生时大家都一样，只要从小喂它蜂王浆，按蜂王培养，它就能成长为蜂王。\n　15.有些事情越透明越好　　但凡老板，公布各种销售政策时基本都会对商品的实际成本有所保留，无论是对公司员工还是合作伙伴或下级经销商，老板一般都不交实底。　　2006年我们因业务发展需要在北京周边的一个城市设立了分公司，分公司是采取收购当地一个合作伙伴部分股份，我公司派驻骨干员工的形式开办的，当地合作伙伴公司的老板马总继续当总经理,负责日常经营。由于对方是一个成熟的盈利企业，所以不用担心新开公司第一二年会赔本的问题。当初合作时大家商定：分公司作为我公司所代理某项产品在当地唯一经销商，享受我公司从厂家进货相同底价及同样的各类促销政策，接受总公司各类业务业务指导，年底分公司利润双方按股份比例分红。　　一切走上正轨之后，我将与分公司合作的各项业务交由公司管理渠道的副总经理老何负责，直到年底，相安无事。　　第二年，矛盾出现了。由于分公司从总公司进货需要开增值税票，而且每次都需总公司派车将货物从厂家库房提出送到货运站再发至分公司所在城市，这就会产生很大一笔物流和税务方面的费用。　　老何考虑到费用没地方出，于是在新的一年给分公司发产品报价及厂家政策时暗自留了2%。没有不透风的墙，分公司马总在这行业里经营多年，与全国各地经销商都有联系，不到一个月，就看出了老何所提供的销售政策有问题。在一次厂家的销售会议上，马总找老何对质，老何当然极力掩饰，两人几乎翻脸。　　马总对老何彻底失去信任，直接找到我，提出这个问题如不解决，双方无法继续合作。　　我好言安抚，将与厂家签订的本年度代理协议原件和盘托出，同时将从厂家库房提货及发货的费用，资金占用费用，仓储费，开发票所需交的税等详细列了个清单逐一计算，计算结果大致为流水的2%。马总看完后心里顺了气，坦言只要在厂家销售底价及政策上对他不加隐瞒，这2%的费用他完全能够理解并接受。我接着承诺利用双方合作销量大的优势向厂家申请争取更多额外的销售支持，一定让分公司享受到比自己做更优惠的价格及政策。马总满意而归，一场纠纷烟消云散。我想：其实合作伙伴所要求的只是一个知情权，一个平等了解厂家真实销售政策的权利。　　在通讯极其发达的今天，几乎很难保守什么秘密。那种城南布头便宜两毛城北半个月不知道的情况再也不会出现了。只要不涉及个人隐私不影响公司根本利益，我公司各项事务基本都是透明的。商品的底价向所有业务员公开，只是事先向他们说明物流仓储税金等各项费用的计算摊销方法，规定销售最低价，其他一概由业务员自己做主，这样不仅增强了员工与公司双方之间的相互信任而且简化了很多销售中间环节，提高了反应速度。\n16.发劳保用品　　刚成立公司时，习惯了国营单位那一套，时不时在过节时发点劳保用品，饮料食用油之类，每回公司派车采购回来，乱哄哄一阵忙，员工每人拿到手后有的用自行车驮，有的打车，还有的零打碎敲往家拿。后来公司人逐渐增多，业务也忙了就逐渐停止发劳保用品了。　　去年春节前去一个朋友公司，正赶上他们过节前发东西，每个员工两大捆卫生纸，一小桶食用油，几大桶可乐，一箱芦柑。十几个员工每人前面一小堆，不少人正发愁怎样往家拿，打个车吧不值，坐公共汽车吧又拿不了。　　我进了朋友办公室，他正在算账呢。见我进来嘿嘿一乐，对我说：　　“看我们公司热闹吧，正发过节的东西呢。”　　我问他：“发那些东西干嘛，又不好拿。”　　朋友故作高深地对我说：　　“这你就不明白了吧，我过节发这些东西让员工拿回家，员工家属一看就觉得咱公司福利待遇好，员工多有面子啊，这些东西摊到每人头上才一百多元看起来又一大堆，多合算呀。”　　我又问他：“你公司员工不一直嚷嚷要上劳动保险吗？有钱你还不如把保险给员工上了”　　“谁上那个呀，每人每月公司要多负担好几百元。”　　节后，朋友公司的业务骨干走了不少。　　三月份我公司招聘，应聘人员中就有一个曾经在朋友公司干过。　　我问他：“你为什么离职呀，原来公司不是挺好的，过节还发东西哪。”　　他不屑一顾：“就那点东西，加起来也就百十来块，蒙谁呀。劳动保险不给上，年底奖金不兑现，老板算得也太精了。”　　听了这话，我不禁汗颜，早几年发劳保用品时我内心深处也想着能省点奖金什么的， 那时员工私下不定怎么发牢骚呢。　　现在这社会，谁比谁傻呀，老板知道卫生纸不值钱员工一样也知道，商品供过于求，超市要啥有啥，明码标价。当老板的做决定时最好还是站在员工角度考虑考虑，这样才能尽量少犯低级错误。否则老觉得自己比别人聪明早晚要摔跟头。\n17.财务制度之签字与凭证　　几年前的一天，我正在座位上改广告稿，忽听到财务室传来争吵的声音，不一会，出纳小丽与业务员小马脸红脖子粗地走到我跟前。小马说：　　“上周五我把一张三千元的支票交给小丽，今天会计又让我交货款，我说交给小丽了，可小丽不承认。”　　小丽委屈地直掉眼泪：“我根本就没收到那张支票，我刚翻遍了所有的票夹，又查了银行对账单，根本就没有。”　　小马说：“我明明放到小丽桌上，怎么会没有呢!”　　小丽说：“经理您可以问问财务室的人，他们都能证明我绝对没收过小马的支票。”　　一场糊涂官司，吵得我头都大了。　　我说：“再去财务室仔细找找，墙角柜子后面桌子低下都翻翻。”　　10分钟后，财务室传来一阵欢呼，支票从两张桌子的夹缝中找到了。　　这件事对我触动很大，财物流程还有漏洞，万一这张支票找不到，算谁的责任？真让我判断，我也无法决定。一直以来，公司对现金的管理比较严格，凡业务员交回现金，都由当班出纳现场收好并验明真伪，然后开具现金收据交给业务员，收据上写明金额，交款人，客户名称，日期并由交款人签字确认。业务员将收据的一联交给会计做账，会计每天根据现金收据对公司现金结存进行盘点。现金方面这些年从未出过差错。但对支票的管理相对松懈，一般就是由业务员交给当班出纳完事。　　在这件事发生以后，公司立刻修改流程，规定凡当班出纳收到业务员交回的支票后，必须在业务员工作单上签字确认，而业务员事先也须在工作单上注明所交支票的支票号及金额，如有纠纷，随时备查，这样一环套一环，责任明确了，就很难再发生类似纠纷了。　　总结这些年的教训，我觉得办公司，财务制度一定要健全并被严格执行，公司大了，人员素质参差不齐，如果财务制度上有漏洞，难免有人会加以利用并非法得利，这样不仅公司利益受到损失，而且起了一个坏的带头作用，其他员工会觉得自己不利用公司财务漏洞相对来说就是吃亏，如此下去公司风气越来越坏，老板到时哭都来不急了。千里长堤溃于蚁穴，任何小的财务漏洞都应予以弥补。同时，原始凭证亦极为重要，好脑子不如烂笔头，谁也不可能记住半年一年前每一笔花销的细节，而一张规范的原始凭证正好可以弥补这一点。财务制度及规范自有他的道理，有时看起来连老板的自由也限制了，但财务人员是否配齐，财务制度是否健全正是做企业和干个体户的重要区别之一，当我们从单干或夫妻店发展到三五个人的时候，这一环节是无论如何也绕不过去的。可惜当初自己比较愚笨不懂这些，也没有过来人给我指点迷津，所以创业之初我走了不少弯路，要不早发财了。\n18.关于股份制，分红与年终奖　　各公司搞股份制方法是不一样的。上市公司的股价怎样计算怎样转让我也不太明白，估计大家都得考虑公司固定资产，流动资金，年盈利能力，无形资产，市盈率，负债率等几方面吧。　　我公司员工入股，什么无形资产，市盈率等都未计算在内，老板让利，员工实实在在得到实惠。我们只算公司的净资产。每年年底会计出张报表，列清楚公司的固定资产，流动资金，应收应付，待摊折旧，当年利润，费用税金等等，明明白白，对于希望入股的骨干员工全部公开。因为平常员工对我十分信任，大部分人连报表看都不看，只要明白公司净资产值多少钱，投资入股后每年大概的分红比例和增值比例就满意了。当然正规的方法应该让第三方会计师事务所进行资产评估并出具报告，但员工都认为没必要我也就乐得省事。员工入股后，公司给每个人一张收据，写清楚该员工出资金额，再与每个股东签订一份入股协议，写清楚员工实际出资金额，占公司总股份百分比，每年分红方案，双方权益责任，退股方法等等，双方签字盖章，各留一份，一切OK。至于五年后如员工想要退股，我们定的是或者按当时公司净资产计算股价赎回，或者按员工实际投资额的三倍赎回。现在公司第一批股东入股时间早已超过五年了，由于公司发展不错，还未发生退股现象。　　入股时我发现一个现象：销售部员工入股最积极，财务部员工入股最消极。这大概与两个部门员工日常工作性质与看问题方法有关吧。销售人员做事总是比较积极冲动，容易只注意事情有利的一面，忽视不利的一面。财务人员做事比较谨慎，看问题容易忽视积极的一面，只看到消极的一面。所以在公司每当做重大决定时我经常同时听取这两个部门的意见，并在不同意见当中权衡协调。　　蒙牛老板牛根生说的好：财聚人散，财散人聚。将公司股份分一部分给员工不仅留住了人才，而且还能激励员工更好地为公司工作，因为给员工股份的同时也赋予了员工相应的责任，当老板将公司50%以上股份分给公司员工时他一定感觉到肩上的担子轻了不止50%，每年他就能踏踏实实地陪家人放松度假去了。其实公司老板控股并不一定要占公司50%以上股份，如果其他小股东每人所占公司股份比例都不到5%那老板股份只要占到公司总股份的20%至30%就已经是公司绝对大股东了，当老板总不至于当到公司所有小股东都团结起来发对你吧。　　头些年我每年将公司当年盈利的30%用于分红，虽然总数不少，但对于小股东来说，有些不疼不痒。近两年听取高人建议，一方面公司自有资金目前足够支撑日常运转，另一方面最近通货膨胀率太高，我索性将年底分红的比例提高到当年净利润的60%，消息一公布，公司小股东乐得嘴都合不拢了，一些原来犹豫的员工也纷纷向我打听入股的事。　　年终奖从前一向是我亲自分配，现在公司人多了，我不可能了解公司每个员工在这一年里的工作细节，因此，公司就根据当年效益定个年终奖总数，我再根据年终奖总数及各部门贡献和部门人数按比例分配到各个部门，让各部门经理与人力资源经理参照考核标准分配到每个员工，最后我只要根据每个部门这一年的工作业绩评定部门经理的年终奖就可以了。　　以前年底分红与年终奖财务上都是作为费用在第二年按月摊销，方法不甚科学，现改为当年按月计提，每月在利润中将这部分费用预留出来，这样年底发奖金时就能做到心中有数，每部门在计算年终奖总数时也有依据了。\n　19.关于涨工资　　想起这个问题我就头疼，这两年物价上涨厉害，通货膨胀率很高，垄断行业及国家公务员纷纷大张旗鼓地涨工资，公司员工也不时议论纷纷，经常问我：“老板，咱什么时候涨工资呀。”　　我也想给大家涨工资，但我们所在行业销售的产品偏偏每年都在不停地降价，利润空间越来越薄，而且由于需要给每个员工上五险一金，公司的用人成本每人每年比几年前增加了近万元，只不过增加的部分没发到员工手里，一般员工看不见。唉，地主家里也没有余粮啊。　　管理书上经常说：要给员工树立远大理想，创造发展空间，制定个人职业规划，分析公司现状及长远规划，激励团队精神，激发员工士气。通过这些年的实践，我发现要完美做到以上几点真的很难，我自己就不善言辞，给员工做报告更不是我的长项。再说光有精神力量缺乏物质奖励管得了一时管不了一世。涨工资的问题不可回避。　　除股东外的大部分普通员工对于公司的经营困境并不感兴趣，员工认为公司经营不好是老板没本事，我的工资该涨还得涨，如果涨不到我满意的程度，那么我就用脚投票，只要找到比现在收入高的职位就拜拜走人。　　既然这个问题回避不了，就得想法解决。根据二八法则，公司80%的利润都是由20%的骨干员工创造的，因此公司的首要问题就是留住这20%的骨干员工。给20%的员工涨工资公司还是负担得起。另外80%的普通员工工资根据工作年限适当调整，多做思想工作，如果还不行就一切随缘吧。通过近几年的情况看，85%的骨干员工比较稳定，公司经营没有产生大的波折。　　公司有一个部门，一共有三名员工：张师傅，王师傅，李师傅。来公司前三人全是国营单位下岗职工，其中张师傅来公司六七年了，比较踏实肯干，王师傅来公司四五年，中规中矩，李师傅来公司两年，工作中有时爱偷懒，经常发牢骚。这天，李师傅找我说：“经理，我们部门工资好久没涨了，师傅们平常工作都很辛苦，您看是不是意思意思，工资往上涨涨，要不该影响工作积极性了。我跟几位师傅合计了一下，想找个时间和您一块开个会讨论一下。”　　我一听，明白了，这李师傅私下准做好了部门其他人工作，想要一起向我发难呢。此风不可长，否则公司人人都学他岂不乱套了，再说该部门平均工资在同行业里已高于平均水平。于是我回答道：　　“这两天我很忙，要不后天下班咱们开个会吧。”　　“好嘞。”李师傅笑了。　　第二天，我找了个机会将张师傅叫进办公室，先聊了聊家常，对他的日常工作予以肯定，然后对他说鉴于他工作一向比较努力，从下月起每季度给他单独增发一部分季度奖，但这额外奖励只有他一人有，希望他保密，最后问他对该部门现有工资的看法。他说：　　“经理，其实我觉得现有工资也差不多了，当然对于工龄长的老员工稍微有点低，您给我涨了季度奖后我就很满足了。我保证好好干！”　　下午快下班时，我又将王师傅叫进了办公室。同样，先聊了会家常，然后我对王师傅说：　　“今年公司盈利方面比较困难，可能暂时无法都涨工资。由于业务量下降，你们部门估计很快需要精简一个人，另外两个人会比较忙一些，公司在年终奖上会有所考虑，对留下的二人适当增加。你对此有什么好的建议？”　　王师傅考虑了下说：“经理，我明白了。我觉得目前的工资还行，涨工资的事等公司利润增加时您自然会考虑。我没的说，该怎么干还怎么干。”　　第三天下班时，会议如期举行。　　首先，李师傅先发言：“经理，我们三个师傅商量了下，都觉得目前的工资水平比较低，公司是不是考虑给涨涨，要不该影响大家工作积极性，这不对公司也不好吗。”　　我说：“目前的你们部门的工资在同行业里已经算比较高的，今年市场环境不好，公司正在调整，又上了新的项目，估计利润会比去年少一些，希望大家克服一下，等公司利润增加后大家工资都会增加。”　　李师傅很不高兴：“经理，公司利润的事是公司经理考虑的事，跟我们没关系。一个公司利润下降是老板没本事，员工工资不应受影响，该涨还得涨。再说我们出来打工不就图个挣钱吗，发多少钱我们就干多少活，是不是二位师傅？”李师傅转头问其他人。　　张师傅和王师傅什么表情也没有，一言不发。　　会议又进行了二十分钟，基本是我解释几句，李师傅慷慨激昂几句。突然，张师傅说：“经理，我想起来了，还一个活今天必须干完，我得马上走。”　　“行，辛苦了，您去吧。”我回答。　　“经理，”王师傅趁机也说：“我闹肚子，得去上个厕所。”　　“去吧，去吧，上厕所能不批吗。”我说到。　　一瞬间，除我之外，只剩下目瞪口呆的李师傅坐在会议桌前。\n　20.充分运用科技手段进行管理　　现代科技日新月异，解决了不少管理上的难题。　　公司刚成立时，上下班考勤是靠考勤员来记录的，但这存在很多问题：首先，无法保证考勤员自己每天按时上下班，其次，考勤员请假时公司没人接替负责记录考勤，再者考勤员与公司其他员工关系有近有远，谁也不能保证考勤员一年365日天天公正无私。　　九十年代后期，打卡钟逐渐普及，公司也购买了一个打卡钟，放在公司门口，员工上班或下班时拿自己的考勤卡在打卡钟上打印个时间，月底人事部一统计一目了然。可随后马上出现了代打卡现象，关系好的员工互相帮忙代打卡，虽然公司每回抓着代打卡的都会重罚，但仍屡禁不止。　　进入新世纪指纹技术渐渐成熟，公司只花几百元买了一个指纹考勤机就彻底解决了以上问题。　　到目前为止，公司还未发生员工互相借手指头帮忙输入指纹的现象。　　随着公司销售网点逐渐增多，办公地点越来越分散，管理起来也日渐麻烦。有时某种商品甲门市积压半年卖不出去，乙门市接着用户订单又重新进货，门市之间信息相互沟通不畅。　　四五年前，公司花重金购买了网络版财务软件，使公司各门市，北京总公司与外地分公司之间做到了实时沟通。公司所有库存商品一目了然，每个业务员的每笔业务随时可查，应收应付账款明明白白，各类报表随要随有，我再也不用老问会计：现在库存多少？账上还剩多少钱？某某某这月销售额多少了？只要有台能上网的电脑，无论何时何地，动动手指头，我所需要的数据立即就会出现在眼前。　　最近为了提高售后服务部门接电话的质量，减少与客户的纠纷，公司在集团电话上加装了录音卡，每天所有的呼入呼出电话全部录音，售后服务部门的客服人员定期开会听电话录音，分析每人接电话的优缺点，大家一起讨论提高。过了一段时间，我发现不仅客服人员接电话水平有所提高，而且公司电话费也节省不少，大概电话一录音员工不好意思再用公司电话打私人电话了吧，真是一举两得。　　运用科技手段管理公司，不仅效率大为提高，而且能尽量避免各种人为因素所引起的偏差。现在人工成本越来越高，购买先进设备代替人来完成工作对公司来说是个节省成本的好方法。\n　21.从结果管理到过程管理　　一直以来，公司基本上采用的都是结果管理，每年年初定好这一年的各项任务指标，然后再根据公司总的年任务向下分配到各个部门，部门继续向下分配到每个人，每个人将一年的任务参考上一年的历史情况细分到新一年的每个月，公司依据每人每月的任务制定考核标准。每月月初财务部汇总算出上月各员工的实际完成任务情况，将报表交到部门经理和总经理处，经理研究完上月报表再制定新的政策并对未完成任务员工进行个别辅导或调整。以上传统方法按部就班，比较可行，但由于目前竞争越来越激烈，市场变化加快，公司原有的管理方法有点跟不上竞争对手的节奏。如果问题在本月初出现，下月初才能反应到报表上，经理根据报表修改销售政策在开会布置下去，40天已经过去了，有时候40天足以把小问题拖成大问题。　　前一段时间了解了戴尔对销售部的管理方法，戴尔刚开始也是对销售人员一月一考核，后改为一周一考核，最后改为一日一考核。每天晚上，销售主管将销售人员的当日销售报表收上来后分析总结，完成任务的OK，完不成任务的挨个留下来单独辅导，分析失败原因，制定新的行动方案，规划第二天的任务，第二天晚上再对前一天制定的方案进行总结考核并重新制定下一天的方案。这样改进之后，戴尔销售部的业绩大为提高，当然，销售人员也快被逼疯了，据说很少有人能在戴尔销售部门忍受三年以上。　　他山之石可以攻玉，虽然目前我公司要做到一天一考核还有点不现实，但做到每周一考核还是可以的。于是我们将业务部门的报表改为一周一汇总，每周一必须将上周每人的业务开展情况及任务实际完成情况总结并核实，对于异常现象立刻采取措施，对于任务完成较差的员工马上单独交流，弄清原因，及时解决问题。新措施实行了一段时间后，我感觉公司对市场反应速度大大提高了，对业务方面的实际情况各级经理也基本做到心里有底，当月问题不必积压到下月初才被发现解决了。　　我一直在琢磨，是否非业务部门也可采取过程管理呢，这样公司整体反应速度将大为提高，各种问题就会被及时反应出来并得到解决，执行力也会大为加强。不过，非业务部门由于没有具体数字硬指标考核，要想达到过程管理的要求估计比较费时费力。\n\n        ', null);
INSERT INTO `blog` VALUES ('82', 'SEO', '\n            \n \n\n1、百度是否能抓取CSS样式表并识别分析?百度是能够抓取并分析CSS的。2、百度5.20大更新，你有什么看法?简而言之：我们的系统在更新数据的过程中出了点状况，问题被及时发现后，已经于5月20日中午修复，目前还有部分内容由于缓存等原因正在更新中，很快就会恢复正常。今后我们会加强相应的保障机制，避免再次出现同类问题。同时也很抱歉让大家造成一些误解。3、百度蜘蛛爬行不存在的路径?Baiduspider只抓取能从互联网上找到的url，如果Baiduspider大量抓取你网站上不存在的url，可能有两个原因：1)你 网站内有部分网页指向其他网页的url格式不正确。2)互联网上有其他网站指向了你网站内不存在的网页。另外，Baiduspider抓取到不存在的网 页，服务器应该返回404错误。4、我在robots.txt中设置了禁止百度收录我网站的内容，为何还出现在百度搜索结果中?如果其他网站链接了您robots.txt文件中设置的禁止收录的网页，那么这些网页仍然可能会出现在百度的搜索结果中，但您的网页上的内容不会被抓取、建入索引和显示，百度搜索结果中展示的仅是其他网站对您相关网页的描述。5、新域名在百度下的权重比旧域名高的情况下，将旧域名301重定向到了新域名会有什么影响?或者说百度下的301是将权重替换还是叠加的呢?将旧域名301重定向到新域名，旧域名的权值会叠加到新域名上。6、网站的gzip压缩对网站的收录和权重有没有影响?gzip对收录和权重没有影响。对搜索引擎唯一的影响，是抓取速度会快一些。7、域名A曾经301至域名B ，如果现在又将域名B301回A是否还能保持原来权重?会，但会有一段时间的考查和权值转移期。8、百度的真正外链是什么命令，是否无法查询?百度目前没有查询外链的查询命令，但我们已经计划在站长平台中支持外链查询。9、标题长短对于网站权重的影响有多大?正如同一个页面上的导出链接越多，每个链接获得的权重越小一样，title上的关键词越多，单个关键词获得的权重也会越低。这是很直观的逻辑。 但是，如果为追求某个关键词的权重，极力压缩标题长度，那么真正合乎该页面的搜索需求，又很难被命中。所以，一般性的建议就是，实事求是的将页面主旨反映 在标题中即可。如果要做长青树，不要在乎一时一刻的seo效果(那个很累、很烦)，把网站的忠实用户人气做起来就成了。10、修改页面标题(如增加前缀或后缀)是否会影响网站排名?title是极重要的内容，大幅修改，只会带来大幅波动，所以请慎重对待网页标题。11、修改首页的description标签，会不会受到惩罚?这个肯定是多虑了，我们鼓励大家通过description来撰写网站的简介，只是过于频繁的修改，可能不会及时反馈在摘要中。12、更换服务器是否对排名有影响?原则上是不会的。除非新换的服务器太糟糕，三天两头访问失败，或者服务器从国内换到国外，这就很可能被和谐。13、百度对重复内容是如何处理的?搜索引擎的排序出发点，是用户的搜索体验。虽说，很多时候尊重原创和用户体验是一致的，但是，毕竟也有一些案例，转载的体验会比原创更好，这时原创的排序未必会高于转载者，但是，原创的应该以另外一种方式被肯定，而不是简单的被聚合掉。14、我买了一个老域名，重新建站，权重会继承吗?正常的域名转手，域名会被当做一个全新的域名看待，前帐一笔勾销。15、百度对如何看待nofollow?如果您不想搜索引擎追踪此网页上的链接，且不传递链接的权重，请将此元标记放入网页的 HEAD 部分：meta name=”robots” content=”nofollow”;如果您不想百度追踪某一条特定链接，百度还支持更精确的控制，请将此标记直接写在某条链接上： a href=”signin.php” rel=”nofollow”&gt;登录/a16、修改robots之后多久生效?不同的站点略有不同，但通常会在几天内生效。根据笔者的经验，只要保持外链的增长和原创内容的更新，大概是4天对于老站，而新站大概一个星期左右。17、一个页面有多个重复的链接，并且链接文字相同，搜索引擎在传递权重时，只传递一次权重，还是每个链接都要传递权重?另外，这几个重复的链接获得的权重一样么?重复的链接不会增加链接权重18、百度是否能识别和处理纯文本形式的链接(非标签)?可以，搜索引擎的spider需要及时发现和抓取互联网上的链接，至于链接是什么形式，并不重要，也许有一天，我们还可以识别图片里、语音里、视频里或是其它形式的链接。19、option标签里面的链接可以被蜘蛛抓到么?可以提取，效果等同于A标签。20、标题过长是否会对百度搜索不利?这个自然是没有限制的。很多人喜欢往标题里塞很多关键词，以为那样就全面开花，但很可能适得其反，这个原理跟在一个页面上有多个超链接一样。分一杯羹的人越多，每个人所得的羹越少。21、百度什么时候更新?没有“更新前”和“更新后”，百度无时无刻不在更新。22、假如竞争对手恶意群发我网站链接到非法站点，对我网站有影响吗?我们有很完善的识别算法，这些行为并不会导致你的网站受到影响。23、很多人说.info和.hk等域名被降权了，是不是真的?使用何种后缀的域名，对搜索引擎没有直接的影响。但.com、.cn、.net等常见的域名后缀更容易记忆，增加用户的判断成本。24、百度建议URL静态化吗?还是像Google一样，不建议URL静态化?对伪静态怎样看待?和真的静态文件一样吗?对URL的动静态，没有歧视政策。之所以以前有过提倡静态的说法，是因为很多动态URL，带了很多参数，而实质上内容是一样的。这个给spider以及站长都带来不必要的麻烦。 我们在这上边花了不少精力。所以，总的原则就是，URL的动静态无所谓，只是尽可能的避免重复即可。但是动态url也不要动态得太变态，搞几十个参数，那 会吓着蜘蛛。酝酿中的sem指南，会有对url优化方面的详细说明。25、搜索结果中显示标题与实际标题不一致?原因比较复杂，需要针对性分析。主要原因可能是tag title提取失败，系统只好从其他地方取了一些文本作为标题。这种提取失败的原因，有网页设计层面的(比如全是flash或者ajax)，也有 robots封禁层面的(某些重要网页虽然不抓取，但会保留url本身)。还有一些系统异常也会造成类似的现象。如果不符合一般性的预期，这类问题都可以 直接提交至webmaster#baidu.com。会有工程师跟进的。26、在百度快照里页面没有显现完整，首页底部(友情链接及版权信息那块)代码和页面都没在快照中出现，那么友情链接对其他网站还有用吗?这种情况不会影响友情链接。另外，我们建议尽量将页面大小控制在合适范围内。27、以前百度显示网页体积的时候最大是125K，超过这个范围快照显示就不正常，是不是意味着网页体积大于125K就对搜索引擎的抓取或收录有影响了?页面大小和搜索引擎的抓取之间没有直接关系。但我们建议网页(包括代码在内)不要过大，过大的网页会有抓取截断;而内容部分，也不要过大，过大会被索引截断。当然，抓取截断的上限，会远大于索引截断的上限。28、Google倾向于说每个网页的导出链接不要超过100为宜，百度有没有什么建议?这个暂时没什么建议。一般情况下，链接数量，会影响到这些链接从该页面上所获得的权重;少就多分一些，多就少分一些。29、js代码弹窗是否会影响自然排名?任何对用户体验有增益或者减益的做法，其实会影响到用户的”投票”行为。而这些投票行为，又会影响搜索引擎对这个网站的评价算法。所以，弹不弹窗并不重要呀，关键是这种弹窗会对用户造成什么样的影响。30、百度针对连接上存在不存在有效期的问题,意思上是说,一个链接的权重会不会过一段时间后就会没有了,或者逐渐降低?如果各位站长要揣摩百度的策略细节，我觉得不如站在用户的角度，用一种合乎常理的逻辑去做推断。比方链接时效性问题，实际是有利有弊。利在于， 过去的投票，只反映被投票者在过去的价值，不见得能反映现时情况;弊在于，正常投票不大会重复投，过去投过了，现在就可能不投了，但不代表现在对被投票者 的不认可。那么究竟应该怎么做呢?呵呵。我也不清楚。31、原创内容不能被识别怎么办?这个，只能说百度的策略还不是很完善，我们也一直在改进。另外，从用户体验角度，有些转载未必比原创差。比方一篇科技原创博文，被知名门户网站 的科技频道转载。如果这种转载保留原创者姓名和出处链接，实际上对原创者是有利的，因为起到了更好的传播效果。只是国内的转载，很多是掐头去尾，使原创者 比较受伤。32、百度是否跟踪JavaScript链接?javascript的解析，是很多搜索引擎正在做的事情;同理，对flash的解析。毕竟有那么多应用javascript或者flash的 网站，其实并没有意识到，他们的做法给搜索引擎的收录和索引带来的麻烦。所以，如果期望不被搜索引擎收录的话，最直接的手段，还是写robots文件。33、链接点击率是否计入排名算法，百度是否有会估算某网页的某个反向链接被点击次数(例如：从工具条、流量统计等工具得到的部分数据)?比如是否把链接的点击率计入算法之中?是否会利用这点来判断哪些是隐藏链接?或者判断外链的相关性等因素。我只能说，一切有利于排序改进的因素，都有可能被搜索引擎尝试应用。34、为什么蜘蛛每天爬n次，而收录网页只有一两篇?网页抓取和建立索引是不等同的。这些网页会经过一些必要的chk过程之后才会被建入索引。\n&nbsp;\n提醒大家考核搜索引擎优化的效果，不要只关注流量，更应关注转化率文章。如果要做长青树，不要在乎一时一刻的seo效果(那个很累、很烦)，把网站的忠实用户人气做起来就成了。\n\n        ', null);
INSERT INTO `blog` VALUES ('83', '”C语言之父去世“来匆匆，去匆匆，留给我们的，是无价的财富.....', '\n            \n \n\n昨晚夜观天象，一星陨落；今天得知原来是C语言之父、推动计算机发展的先驱——Dennis Ritchie去世了，在此谨以一个“;”表示崇高的敬意......\n作为一个程序员，你可以不知道Dennis Retchie是谁，但你肯定知道C语言和Unix，正是他发明了这两个东西，他也因此获得了图灵奖。不夸张地说，Retchie是计算机行业的奠基人之一。如果没有C语言，也不会有iphone了,他的贡献比乔布斯大,和乔布斯比他更应该让人去缅怀，也许上帝想学C语言了.....哎......真的有点难过........\n&nbsp;\n走好，Retchie，还是套用网友对他的特有祭奠方式哀悼他吧：printf(&quot;Goodbye, world!\\n&quot;);\n&nbsp;\n再次默哀一分钟......\n\n        ', null);
INSERT INTO `blog` VALUES ('84', 'javabean生成柱状图练习', '\n            \n \n\n//Chart.java文件\npackage test;import java.io.*; import com.sun.image.codec.jpeg.*; import java.awt.image.*; import java.awt.*; public class Chart{BufferedImage image; public Chart(){}public void createImage(String fileLocation){try{ //构建输出流FileOutputStream fos = new FileOutputStream(fileLocation);BufferedOutputStream bos = new BufferedOutputStream(fos);JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(bos);encoder.encode(image);bos.close();}catch(Exception e){ System.out.println(e);}}public void graphicsGeneration(int h[],String path){ final int X=20;//画布的宽度int imageWidth = 320; //画布的高度&nbsp;&nbsp;int imageHeight = 320;int columnWidth=20;&nbsp;&nbsp;//柱的宽度 int columnHeight=280;&nbsp;&nbsp;//柱的最大高度 image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics graphics =image.getGraphics();&nbsp;&nbsp;//画布颜色graphics.setColor(Color.white); graphics.fillRect(0,0,imageWidth,imageHeight);&nbsp;&nbsp;//设置画笔的颜色 graphics.setColor(Color.blue); &nbsp;&nbsp;//画长方形柱for(int i=1;i&lt;=h.length;i++) {&nbsp;&nbsp; graphics.fillRect(X+i*columnWidth, columnHeight-h[i-1], columnWidth, h[i-1]);&nbsp;&nbsp; }graphics.setColor(Color.black); graphics.drawRect(X+18, columnHeight, 250, 2);graphics.drawRect(X+18, 40, 2, columnHeight-40);&nbsp;&nbsp;//画柱的边框for(int n=1;n&lt;=h.length;n++) {&nbsp;&nbsp; graphics.drawRect(X+n*columnWidth, columnHeight-h[n-1], columnWidth, h[n-1]); }graphics.setColor(Color.blue);  //画横坐标for(int u=0;u&lt;=h.length;u++){String n=new Integer(u).toString();graphics.drawString(n,25+u*20,columnHeight+20);} //画纵坐标for(int q=1;q&lt;=10;q++){String qq=new Integer(q).toString();graphics.drawString(qq,25,columnHeight+3-q*20);}for(int j=1;j&lt;=10;j++) {&nbsp;&nbsp; graphics.drawRect(X+18, columnHeight-j*20, 250,0); }&nbsp;&nbsp;//设置文字字体 Font font = new Font(&quot;黑体&quot;, Font.BOLD, 18); graphics.setFont(font); //设置要插入的文字 graphics.drawString(&quot;全年各月同比增长率&quot;,80,40); //按指定路径产生图片this.createImage(path); }}\n\n/*==================================index.jsp文件============================*/\n&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;&lt;%@ page language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;test.Chart&quot; %&gt;&lt;HTML&gt;&lt;head&gt;&lt;title&gt;动态柱状图&lt;/title&gt;&lt;/head&gt;&lt;BODY&gt;&lt;CENTER&gt;&lt;%String path=request.getRealPath(&quot;/&quot;);//获取要读取的文件路径String newFile=path+&quot;imagename.jpg&quot;;//定义柱状图的高度int[] hh={60,20,80,120,50,80,90,50,160,90,70,80};Chart charg=new Chart();charg.graphicsGeneration(hh,newFile);out.print(&quot;柱状图生成测试！&lt;BR&gt;&quot;);out.print(&quot;&lt;IMG src=\'imagename.jpg\' /&gt;&quot;);%&gt;&lt;/CENTER&gt;&lt;/HTML&gt;&lt;/BODY&gt;\n\n\n/*====================================结果图===================================*/\n\n\n        ', null);
INSERT INTO `blog` VALUES ('85', 'JavaBean在JSP中的作用范围(page,session,application,request)', '\n            \n \n\nJavaBean在JSP中的作用范围(page,session,application,request)JavaBean是一种可复用，跨平台的组件。共有两种JavaBean：一种无用户界面，这种一般用于处理数据运算，操作数据库等。另一种是有用户界面(User Interface)的JavaBean.&nbsp;&nbsp; 在Jsp中一般访问无用户界面的JavaBean。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jsp中访问JavaBean语法:1. 使用page指令导入 JavaBean 类:&nbsp;&nbsp;&nbsp;&nbsp; &lt;%@page import=&quot;包名 . 类名&quot; %&gt;2. 使用&lt;jsp:useBean&gt;标签声明JavaBean对象：&nbsp;&nbsp;&nbsp;&nbsp; &lt;jsp:useBean id=&quot;实例名&quot; class=&quot;包名 . 类名&quot; scope=&quot;作用范围&quot;/&gt;注意：要给出完整的（包名 . 类名）,否则报ClassNotFoundException&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 例:&lt;jsp:useBean id=&quot;bean&quot; class=&quot;com.CountBean&quot; scope=&quot;session&quot;/&gt;&nbsp;&nbsp;&nbsp;&nbsp; 上面的代码相当于:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CountBean bean = new CountBean();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.setAttribute( &quot;bean&quot; , bean );注意：如果在scope指定范围内，该JavaBean已存在，则&lt;jap:useBean&gt;不会生成新的JavaBean对象，而是直接获得已经存在的 JavaBean 对象的引用.3.使用&lt;jsp:getProperty&gt;和&lt;jsp:setProerty&gt;标签访问JavaBean属性:&lt;jsp:getProperty name=&quot;实例名&quot; property=&quot;Bean中的属性名&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp; 调用Bean中的get方法得到某属性的值&lt;jsp:setProperty name=&quot;实例名&quot; property=&quot;Bean中的属性名&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用Bean中的set方法给某属性赋值例子: &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt; &lt;%@page import=&quot;com.CountBean;&quot;%&gt; &lt;jsp:useBean id=&quot;bean&quot; class=&quot;com.CountBean&quot; scope=&quot;[page][request][session][application]&quot; /&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;title&gt;Count.jsp\'&lt;/title&gt;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;&lt;/head&gt;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp; count values is:&lt;jsp:getProperty name=&quot;bean&quot; property=&quot;num&quot; /&gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt;jsp:setProperty name=&quot;bean&quot; property=&quot;num&quot; value=&quot;&lt;%=bean.getNum()+1 %&gt;&quot;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CountBean obj = null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String scope = null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = (CountBean)request.getAttribute(&quot;bean&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( obj != null ) scope = &quot;request&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = ( CountBean )session.getAttribute(&quot;bean&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( obj != null ) scope = &quot;session&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = ( CountBean )application.getAttribute(&quot;bean&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( obj != null ) scope = &quot;application&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( scope == null ) scope = &quot;page&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; %&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt; scope = &lt;%=scope %&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;补充: 1.JavaBean在page作用域中:&nbsp;&nbsp;&nbsp;&nbsp; 在这种情况下，客户每次访问Jsp页面时，都会创建一个JavaBean对象,仅在当前Jsp页面中有效。&nbsp;&nbsp;&nbsp;&nbsp; 例子的结果:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count values is: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scope = page&nbsp;&nbsp;&nbsp;&nbsp;此时JavaBean在将以下两种情况下结束生命周期&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)当客户访问当前Jsp页面通过forword转发请求到另一文件时&nbsp;&nbsp;&nbsp;&nbsp; (2) 当客户访问当前Jsp页面执行完毕并向客户端发回响应时2.JavaBean在request作用域中:&nbsp;&nbsp;&nbsp;&nbsp; 与pgae一样，客户每次访问Jsp页面时，都会创建一个JavaBean对象。&nbsp;&nbsp;&nbsp;&nbsp; 例子的结果:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count values is: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scope = request&nbsp;&nbsp;&nbsp;&nbsp;此时 , 当客户访问当前Jsp页面执行完毕并向客户端发回响应时 ,JavaBean结束生命周期3 JavaBean在session作用域中:&nbsp;&nbsp;&nbsp;&nbsp; JavaBean对象被创建后，一直存在于当前回话中，在同一会话中,共享同一JavaBean&nbsp;&nbsp;&nbsp;&nbsp; 例子结果:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count values is: 0 ( 每刷新一次，增长1，当打开另一浏览器窗口重新发出请求时，就不在同一会话中了，将创建一个新的会话,从0开始重新增长。 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scope = session4.JavaBean在application作用域中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaBean对象被创建后，一直存在于当前Web应用程序的生命周期中，在此应用程序中,共享同一JavaBean 例子结果:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count values is: 0 ( 每刷新一次，增长1，当打开另一浏览器窗口重新发出请求时，此时还在同一Web应用程序中了，从原有基础上增长。 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scope = application&lt;转自&gt;Jenhy的专栏\n\n        ', null);
INSERT INTO `blog` VALUES ('86', 'JSP中九个常用内置对象', '\n            \n \n\n1.request对象  客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。  序号 方 法 说 明  1 object getAttribute(String name) 返回指定属性的属性值  2 Enumeration getAttributeNames() 返回所有可用属性名的枚举  3 String getCharacterEncoding() 返回字符编码方式  4 int getContentLength() 返回请求体的长度（以字节数）  5 String getContentType() 得到请求体的MIME类型  6 ServletInputStream getInputStream() 得到请求体中一行的二进制流  7 String getParameter(String name) 返回name指定参数的参数值  8 Enumeration getParameterNames() 返回可用参数名的枚举  9 String[] getParameterValues(String name) 返回包含参数name的所有值的数组  10 String getProtocol() 返回请求用的协议类型及版本号  11 String getScheme() 返回请求用的计划名,如:http.https及ftp等  12 String getServerName() 返回接受请求的服务器主机名  13 int getServerPort() 返回服务器接受此请求所用的端口号  14 BufferedReader getReader() 返回解码过了的请求体  15 String getRemoteAddr() 返回发送此请求的客户端IP地址  16 String getRemoteHost() 返回发送此请求的客户端主机名  17 void setAttribute(String key,Object obj) 设置属性的属性值  18 String getRealPath(String path) 返回一虚拟路径的真实路径  2.response对象  response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。  序号 方 法 说 明  1 String getCharacterEncoding() 返回响应用的是何种字符编码  2 ServletOutputStream getOutputStream() 返回响应的一个二进制输出流  3 PrintWriter getWriter() 返回可以向客户端输出字符的一个对象  4 void setContentLength(int len) 设置响应头长度  5 void setContentType(String type) 设置响应的MIME类型  6 sendRedirect(java.lang.String location) 重新定向客户端的请求  　  3.session对象  session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.  序号 方 法 说 明  1 long getCreationTime() 返回SESSION创建时间  2 public String getId() 返回SESSION创建时JSP引擎为它设的惟一ID号  3 long getLastAccessedTime() 返回此SESSION里客户端最近一次请求时间  4 int getMaxInactiveInterval() 返回两次请求间隔多长时间此SESSION被取消(ms)  5 String[] getValueNames() 返回一个包含此SESSION中所有可用属性的数组  6 void invalidate() 取消SESSION，使SESSION不可用  7 boolean isNew() 返回服务器创建的一个SESSION,客户端是否已经加入  8 void removeValue(String name) 删除SESSION中指定的属性  9 void setMaxInactiveInterval() 设置两次请求间隔多长时间此SESSION被取消(ms)  4.out对象  out对象是JspWriter类的实例,是向客户端输出内容常用的对象  序号 方 法 说 明  1 void clear() 清除缓冲区的内容  2 void clearBuffer() 清除缓冲区的当前内容  3 void flush() 清空流  4 int getBufferSize() 返回缓冲区以字节数的大小，如不设缓冲区则为0  5 int getRemaining() 返回缓冲区还剩余多少可用  6 boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常  7 void close() 关闭输出流  5.page对象  page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例  序号 方 法 说 明  1 class getClass 返回此Object的类  2 int hashCode() 返回此Object的hash码  3 boolean equals(Object obj) 判断此Object是否与指定的Object对象相等  4 void copy(Object obj) 把此Object拷贝到指定的Object对象中  5 Object clone() 克隆此Object对象  6 String toString() 把此Object对象转换成String类的对象  7 void notify() 唤醒一个等待的线程  8 void notifyAll() 唤醒所有等待的线程  9 void wait(int timeout) 使一个线程处于等待直到timeout结束或被唤醒  10 void wait() 使一个线程处于等待直到被唤醒  11 void enterMonitor() 对Object加锁  12 void exitMonitor() 对Object开锁  6.application对象  application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这 样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启 动和关闭决定了application对象的生命。它是ServletContext类的实例。  序号 方 法 说 明  1 Object getAttribute(String name) 返回给定名的属性值  2 Enumeration getAttributeNames() 返回所有可用属性名的枚举  3 void setAttribute(String name,Object obj) 设定属性的属性值  4 void removeAttribute(String name) 删除一属性及其属性值  5 String getServerInfo() 返回JSP(SERVLET)引擎名及版本号  6 String getRealPath(String path) 返回一虚拟路径的真实路径  7 ServletContext getContext(String uripath) 返回指定WebApplication的application对象  8 int getMajorVersion() 返回服务器支持的Servlet API的最大版本号  9 int getMinorVersion() 返回服务器支持的Servlet API的最大版本号  10 String getMimeType(String file) 返回指定文件的MIME类型  11 URL getResource(String path) 返回指定资源(文件及目录)的URL路径  12 InputStream getResourceAsStream(String path) 返回指定资源的输入流  13 RequestDispatcher getRequestDispatcher(String uripath) 返回指定资源的RequestDispatcher对象  14 Servlet getServlet(String name) 返回指定名的Servlet  15 Enumeration getServlets() 返回所有Servlet的枚举  16 Enumeration getServletNames() 返回所有Servlet名的枚举  17 void log(String msg) 把指定消息写入Servlet的日志文件  18 void log(Exception exception,String msg) 把指定异常的栈轨迹及错误消息写入Servlet的日志文件  19 void log(String msg,Throwable throwable) 把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件  7.exception对象  exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象  序号 方 法 说 明  1 String getMessage() 返回描述异常的消息  2 String toString() 返回关于异常的简短描述消息  3 void printStackTrace() 显示异常及其栈轨迹  4 Throwable FillInStackTrace() 重写异常的执行栈轨迹  8.pageContext对象  pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。  序号 方 法 说 明  1 JspWriter getOut() 返回当前客户端响应被使用的JspWriter流(out)  2 HttpSession getSession() 返回当前页中的HttpSession对象(session)  3 Object getPage() 返回当前页的Object对象(page)  4 ServletRequest getRequest() 返回当前页的ServletRequest对象(request)  5 ServletResponse getResponse() 返回当前页的ServletResponse对象(response)  6 Exception getException() 返回当前页的Exception对象(exception)  7 ServletConfig getServletConfig() 返回当前页的ServletConfig对象(config)  8 ServletContext getServletContext() 返回当前页的ServletContext对象(application)  9 void setAttribute(String name,Object attribute) 设置属性及属性值  10 void setAttribute(String name,Object obj,int scope) 在指定范围内设置属性及属性值  11 public Object getAttribute(String name) 取属性的值  12 Object getAttribute(String name,int scope) 在指定范围内取属性的值  13 public Object findAttribute(String name) 寻找一属性,返回起属性值或NULL  14 void removeAttribute(String name) 删除某属性  15 void removeAttribute(String name,int scope) 在指定范围删除某属性  16 int getAttributeScope(String name) 返回某属性的作用范围  17 Enumeration getAttributeNamesInScope(int scope) 返回指定范围内可用的属性名枚举  18 void release() 释放pageContext所占用的资源  19 void forward(String relativeUrlPath) 使当前页面重导到另一页面  20 void include(String relativeUrlPath) 在当前位置包含另一文件  9.config对象  config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）  序号 方 法 说 明  1 ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象  2 String getInitParameter(String name) 返回初始化参数的值  3 Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举\n\n        ', null);
INSERT INTO `blog` VALUES ('87', '随手记录', '\n            &nbsp;&nbsp; &nbsp;现在是晚上12：46分，天气真的很冷啊，特别是这两天，一直在下小雨，博罗这地方四周是山，山里的冬天，原来真的好冷啊。&nbsp;&nbsp; &nbsp;今天已经定好车票准备十五号那天考完试后就回家了，都快一年了呢！一直都好想回家，特别是这几天，简直是归家心切啊，以前都没有过这种感觉过。说来日子过得也快，一下子，已经是出来快一年了，这一年来好像什么都没做，又好像什么都做了，一年，多了个女朋友，多了点社会经验，多了点小成熟，多了点&middot;&middot;&middot;少了点情感，少了点单纯，少了点小忧愁&middot;&middot;&middot;是啊，这一年，也就这样结束了，一下子就到了2011年，2011，多陌生的数字啊，好像有好多说好要在10年做完的事都还没做，可又想不起来是漏了哪些是没做的，一下子，那个数字就这样永远不在了，就好像你明明在等待着24：00分，当指针指向23：59的时候，我们都还在过分的以为着还有一秒，可却突然发现没有少掉了一秒，00：00，好可怕的数字啊，甚至有点冰冷，容不得你半点迟疑。&nbsp;&nbsp; &nbsp;这些天开始在准备考试了，日子也过得稍微紧张了些，这学期也就剩下那么的几天了，说起来我觉得这学期我过得还可以，蛮充实的，至少我认为对得起辛辛苦苦的老师在讲台上的那几十分钟，对得起自己因每天在阶梯教室第一排仰着头听课导致自己现在晚上睡觉时脖子的酸痛&middot;&middot;&middot;&nbsp;&nbsp; &nbsp;今年八月底就可以离开学校出去实习了，说是实习，其实也就是毕业了，广技师，前年我带着伤痛走进你的门槛，今年我是不是会笑着走出去呢?我已经不记得我是从什么时候喜欢上了我的专业，尽管这专业在这学校里只是个附属品，计算机软件技术？呵呵&middot;&middot;&middot;念着多顺口，还好我对这些都不敏感。说上喜欢，其实只是喜欢那种在键盘上敲代码的感觉，看着那一行行自己辛辛苦苦写出来的东西编译成功，可以让我找回以前高中时代熬夜做数学题时的感觉。提到毕业，就不得不和考证联系到了一起，计算机软件设计师？中级程序员？这难道就是今年毕业以前要完成的任务？算是吧，还有比这更让人兴奋的事情了吗？可能这个寒假会过得比较枯燥，抑或会比较轻松，毕竟这本身对我而言已经成为了一种享受，至于结果如何，我不在乎！就像去年一样，付出的代价，尽管没有得到我预计要的东西，但在过程中，我已收获到许多意想不到的惊喜，我想，生活或许就应该是这样子的吧，偶尔给予的玩笑，却可以造就你成熟的脸上那一抹自信的笑意。\n        ', null);
INSERT INTO `blog` VALUES ('88', '程序员从初级到中级10个秘诀', '\n            \n \n\nJustin James曾发表过一篇博文《10 tips for advancing from a beginner to an intermediate developer》，为我们分享如何才能完成程序员从初级到中级的蜕变，现将中文译文转载于此，供大家借鉴。\n在一封与TechRepublic会员交流的邮件当中，他提到了面向程序员的博客、文章及杂志分成两类：面向初学者类（“hello world”这种类型的教程）以及面向专家类（MSDN杂志）。这个观点很好，有关程序员如何从初级跃升到中级的信息极少。以下是为了实现这种转变需要你去做的10件事。\n1.学习另一门语言\n其实你学的是哪一门语言并没有关系，但是学习另一门语言（不管你已经了解多少种语言）将把你打造为更好的程序员。能学会一门与你日常使用的语言风格迥异的语言则更佳。打个比方，如果你是C#程序员，学习VB.NET或者Java对你的帮助就没有学习Ruby或者Groovy大。\n我说“学另一门语言”的意思是要真正学会它。学习一门语言包括三个领域的知识：语法、内置操作符和库，以及“如何使用”。前面两个简单；我认为一名有经验的程序员，根据语言的不同，能在半小时到几小时内掌握足以维护代码的语法知识。操作符和库只不过是知识逐步积累的过程，你什么时候想清楚要了解什么了，再去查阅参考材料也不迟。只有第三项，“如何使用它”-要花上你几个月的时间去跟这门语言打交道，真正的奇迹就在此发生。我建议用这门语言的风格去做一个适合该语言的项目。\n真正学会了另一门语言之后，我敢保证你的程序员水平一定会突飞猛进。\n2.学习先进的搜索技术、手段和及策略\n作为一名好的程序员，不仅仅是技能的问题了，而是你寻找信息的技巧，这个趋势越来越明显。对大部分人而言，仅仅输入“现代语言及开发框架”，这都是泛泛之谈，记不住多少的。因此，你完成工作的能力通常取决于你的检索能力。不幸的是，了解到如何找到准确而高质量的信息可不仅仅是跑到TechRepublic来找答案，或者在你选好的搜索引擎上敲几个字那么简单。\n“技术（Techniques）”、“手段（tactics）”和“策略（strategies）”看起来是一回事，实际上并非如此。你需要学会的技术是掌握你喜爱的搜索引擎的高级搜索系统；你需要了解诸如布尔操作符，如何过滤结果（像“非”关键字，域限制等等），关键字的词序扮演什么角色，等等。一句话，RTFM（Read The Fucking Manual，读那些他妈的手册）吧。\n你应该学会这些手段，诸如如何接近特定的搜索，以及了解自己实际上想查些什么。查错误很容易—只需查出错代码即可—但是许多搜索的关键字选择要困难得多。\n至于策略，你需要学会的东西，包括像应该使用哪种搜索引擎（提示：普通的搜索引擎不一定就是最佳选择），使用普通搜索引擎前应该访问哪个网站，甚至是应该到哪个论坛去寻求帮助，等等。\n3.帮助别人\n教别人始终是学习一切东西的最好方法之一。相对而言，由于你在开发领域还是个新手，认为自己没什么可教给人家的，这可以理解。但这毫无意义。记住，你所学到的一切都是你从别人或别处学到的；因此请尝试一下，成为另外一个人要请教的“别人”。每天尽量花一点时间试着回答TechRepublic上的问题，其他网站的亦可。读读其他会员的回答，你也可以学到很多东西。\n4.有耐心，常练习\n研究表明，要成为一名“专家”，需要花费10年，或者10000到20000小时的刻意练习时间。真的很久。还有，成为专家不尽然就是执行10年同样的任务；通常这意味着要在特定领域内执行广泛的任务。需要花费大量的时间和精力才能成为“专家”；做几年程序员是不够的。想在30岁左右成为一名高级软件开发工程师？要么尽早接受教育/培训，要么你得愿意在闲暇时间进行大量的工作、阅读和练习。我从高中开始编程，还牺牲了许多休息时间去跟踪行业发展、学习新技能等等。结果，我获得中级和高级程序员的时间就比我的大部分同事都要早得多，随着时间的推移，这些就转化成为很多的金钱。\n5.对教条拒之门外\n是时候开诚布公了：也许初级程序员了解的东西还不足以说出做某件事情有一种最好的方式。尊重朋友或者权威的观点是好的，但直到你更有经验之前，不要把他们的观点说成是你自己的。很简单，如果你所了解的不足以让你独立地找出这些东西来，你又怎么会认为你知道哪一位“专家”是对的呢？话是难听了点，不过请相信我；由于受某些愚蠢建议的蛊惑，或者追随某些根本不知道自己在说些什么的所谓专家，白白把自己的职业生涯耽搁了几年，这样毛头小伙程序员，我见过多了。这一点有一个很好的例子，就是面向对象结构的滥用。比如说，许多初级者读了一些有关面向对象的信息后，突然间，他们那简单的应用程序的类图看起来就像埃菲尔铁塔一样了。\n6.深入学习一点先进理念\n成为一名中级程序员，很大一部分是要在代码里面体现出一些所擅长的概念。就我而言，是多线程/并行性，是正则表达式，以及如何对动态语言进行变化（后两个在我离Perl渐行渐远后开始退化）。这是如何发生的？多线程和并行处理是因为我读了相关文章，觉得它看起来很有趣，然后再自己把它弄清楚了；然后我就一直使用这些技术来写应用。我做过一件工作，是用Perl写的，里面运用了大量的正则表达式。我也用一个过程引擎模板和内置数据库系统写过我自己的电子商务引擎；那时我几乎花了2年时间在这上面。\n找到真正令你着迷的东西。也许是图像处理，也许是数据库设计，等等。即便你是一个入门级的程序员，也要尝试一下成为某一自己所关注领域的专家。这会让你相当快速地进入到中级水平，一旦你到了那个水平，你的专家之路也走到一半了。\n7.学习你的领域里面的基本理论\n写出“Hello World”，跟理解那些字是如何显示到屏幕上的是两码事。通过学习支撑你所从事的工作的“基础/底层工作（groundwork）”，你会变得更加在行。为什么？因为你会理解事物为何会以这种方式运作，当东西坏了就能知道是哪里的问题，等等。通过掌握工作的底层机制，你变会得更出色。\n如果你是Web程序员，读读HTTP RFC和HTML规范。如果你使用代码生成器，好好看看它生成的代码；如果你使用数据库工具，看看它生成的底层SQL语句，不一而足。\n8.看看高级程序员的代码\n在工作中看看高级程序员写的代码，然后问一问事情是如何以某种特别的方式完成的，为什么？可能的话看看开源的项目。甚至即使其他程序员没有最好的编程习惯，你也会学到许多编程经验。当然，要小心别学到坏习惯。我的意思是说不要生搬硬套人家的东西；你要能领会到哪些是能行的通的，哪些是有道理的，然后再模仿人家。\n9.学习好的习惯\n愚蠢的变量名，糟糕的缩进习惯以及其他一些凌乱的迹象就是一个没有经验的程序员的最好标记。一个程序员在学会如何编程时，却经常没有被传授到那些不那么有趣的细节，像代码格式编排。甚至尽管学习这些东西并不会令你的代码更好，也不会令你成为更好的程序员，它也会确保你不被同事视为入门级的程序员。甚至即使某人是高级程序员，如果他的变量是以他那97只猫的名字来命名，或者其函数叫做“doSomething（）”的，他们看起来也不像是知道自己在干什么的人。而且会令其代码在过程中更难以维护。\n10.要玩的开心\n想要痴迷于单调乏味的工作？痛恨工作吧。要想升级为中级程序员可不仅仅是为了拿到不断增长的工资不达目的誓不罢休，而是要真正享受工作。如果你不喜欢自己的工作，且还是初级程序员，你怎么会认为成为中级或高级程序员情况就会有所好转呢？换工作或改职业吧。反过来说，如果你喜爱所从事的工作，那就好！只要你坚持下去，我保证你能成为一名更好的程序员。（Justin James）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----------源自CSDN\n\n        ', null);
INSERT INTO `blog` VALUES ('89', 'Photoshop教程~喜欢PS的同学不要错过！', '\n            \n \n\n&nbsp;\n\n照片名称：调出照片柔和的蓝黄色-简单方法\n1、打开原图素材，按Ctrl + J把背景图层复制一层，点通道面板，选择蓝色通道，图像 &gt; 应用图像，图层为背景，混合为正片叠底，不透明度50%，反相打钩， 2、回到图层面板，创建曲线调整图层，蓝通道：44，182，红通道：89，108 3、新建一个图层，填充黑色，图层混合模式为正片叠底，不透明度为60%，选择椭圆选框工具选区中间部分，按Ctrl + Alt + D羽化，数值为70，然后按两下Delete键删除，再打上文字，完成最终效果。\n\n照片名称：调出照片漂亮的红黄色\n1、打开原图素材，Ctrl + J把背景图层复制一层，按Ctrl + Shift + U去色，执行：滤镜 &gt; 模糊 &gt; 高斯模糊，数值4，图层混合模式为滤色，图层不透明度改为27%。 2、新建一个图层，按Ctrl + Alt + Shift + E盖印图层，图层混合模式为颜色。 3、创建渐变映射调整图层，紫色-橘色，Alt+Ctrl + G加上剪贴蒙版。 4、创建亮度/对比度调整图层，-5，-21 5、创建智能锐化调整图层，设置为默认值，数量46，半径0.8，高斯模糊， 6、创建色阶调整图层，8，1.00，255 7、创建可选颜色调整图层，红色：+17，-8，+16，0，黄色：-54，0，+10，+18，白色：-5，0，0，0，\n\n照片名称：打造美女冷艳张扬蓝色调\n&nbsp;\n1、在做图之前，可以先对图进行：图像-调整-自动色阶，自动对比度，自动颜色的调节， 2、打开原图，复制背景图层， 3、新建色相饱和度调整层，红：-80，黄：-80，蓝：+32 4、色彩平衡：-20，+20，+50 5、曲线调整，数值：38，36 6、色相饱和度，蓝色：-45 7、可选颜色，青：-10，+20，+24，0，蓝色：+20，0，+10，0，中性色：（黑色）+5，黑色：（黑色）+5 8、载入蓝色通道选区，做曲线调节，数值：74，119 9、亮度对比度：0，+10 10、盖印所有图层，（Ctrl+Shift+Alt+E），把图片进行磨皮等简单柔化处理， 11、把开始复制的背景副本层置顶，混合模式为柔光，不透明度25% 12、再次盖印所有图层，打上光照效果，滤镜-渲染-光照效果，不透明度50%,其他数值为默认值。添加蒙版，把曝光过度的地方擦回来， 13、刷上自己喜欢的笔刷，添加文字，完成&nbsp;\n照片名称：精心制作水做的女人\n&nbsp;\n1、打开原图素材，先用钢笔工具把人物勾出来，按Ctrl + Enter 把路径转为选区，按Ctrl + J 把人物复制到新的图层。 2、按Ctrl + M 对抠出的人物调整曲线，数值：47，60 3、新建一个图层，填充颜色：#0A6A60 4、把人物皮肤到头部这上半部分抠出来，复制到新的图层。 5、把前景颜色设置为翠绿色，（水的颜色可以根据作图需要设定所需要），背景设置为白色，选择菜单：图像 &gt; 调整 &gt; 渐变映射。调节出有明暗对比的单色图像。 6、滤镜 &gt; 艺术效果 &gt; 塑料包装，数据根据个人需要做调节，主要是提取有水效果的高光部分，所以作图的是很可以想象一下水做的人脸上的高光密度和疏散度进行调节，根据水的特征，人物眼睛能接收到的信息就是只有高光和最暗的部分，其它部分则是透明的。 7、选择图层3副本，按Ctrl + Alt + Shift + ~ 调出高光选区，再按Ctrl + Alt + Shift 鼠标点击图层3副本，这样把人物外部的选区减掉，然后新建图层4填充白色。\n8、按住Ctrl键点击图层4转成选区，按Ctrl + Shift + I 反选，按Delete删除，多点几次删除干净点。 9、把图层4转为选区，选中图层3副本，点蒙版按钮（可把图层暗调隐藏掉）。再用画笔把人物上多余的高光擦掉，同样图层3副本也建立蒙版，把多余的高光擦掉。 10、图层3设置为“正片叠底”，图层1建立蒙版把衣服保留，按Ctrl + B 把衣服调成绿色，找有关水的图片拼贴上去。水珠素材网上找。 11、最好是能找到黑色背景的水素材，如果是白色或其他颜色背景的水素材，可以通过减饱和度或者反向把背景变成黑色，图层属性设置成滤色会把黑色屏蔽掉，只留下白色透明度的水，拼贴的时候要看水的方向找到适合的位置拼贴上去，要会利用蒙版把水根人物之间的衔接位置处理好。 12、最后把背景颜色处理好。\n\n照片名称：制作恐怖电影\n&nbsp;\n需要使用两种笔刷： 破碎玻璃笔刷：Broken Glass brush 血液笔刷：Blood stain brush. 1、按CTRL+U调整色相/饱和度，着色打钩，数值：220，26，-9 2、改变眼的颜色，用套索工具选择眼睛。然后调整色相/饱和度，着色打钩，数值：117，47，7 3、使用一个13px -15 px 暗调的笔刷在眼睛周围绘制，设置黑色，模式为正片叠底，不透明度25%，流量25%，在眼睛周围绘制，同样方法修改嘴唇。 4、建立新图层，填充颜色为#31425e， 5、破碎玻璃画笔绘制。 6、添加图层样式，投影，正片叠底，不透明度75%，角度120&deg;， 7、CTRL+E合并图层，用套索工具选择破碎区域，改变不透明度为80%，复制图层，调整模式为正片叠底， 8、滤镜-渲染-光照效果，点光，强度53，聚焦69， 9、最后再用血液笔刷绘制一些血液\n\n照片名称：Photoshop合成创意的打印机海报\n&nbsp;\n1、打开背景和打印机素材，把打印机抠出来，复制进来适当摆好位置。 2、打开豹的素材，拖进来适当调整好大小和角度，用钢笔工具把豹子抠出来复制到新的图层。 3、用钢笔工具勾出打印机纸张的轮廓路径，转为选区后按Ctrl + Shift + I 反选，按Delete 删除， 4、给纸张图层描边，再加蒙版去除多余部分， 5、在纸张图层上面新建一个图层，适当用黑色画笔画出豹子前脚的阴影，打印机以及纸张的阴影，适当降低透明度， 6、最后更加需要加上广告词及文字，完成最终效果。\n\n照片名称：调出怀旧的风景照片\n&nbsp;\n1、打开原图，复制一层 2、曲线调整，数值RGB：109，99 3、色相饱和度，数值：0，-39，0 4、色彩平衡，数值：0，0，-34 5、可选颜色，中性色：0，0，-20，0 6、新建图层，填充d7b26c，图层模式叠加，不透明度56%， 7、把云彩素材拉进图中，放到原图上面，图层模式柔光，把除了天空之外的部分擦出来，盖印图层（Ctrl+Alt+Shift+E） 8、可选颜色，黑色：0，0，-14，-5 9、新建图层，填充0d1d50，图层模式排除，复制一层，填充52% 10、曲线调整，数值RGB：128，155 11、色彩平衡，数值：+24，+7，-64，填充70% 12、色阶，数值：29，1.00，227，填充58% 13、可选颜色，中性色：+16，+12，-11，+5 14、盖印图层（Ctrl+Alt+Shift+E），色彩平衡，数值：+24，+7，-64，填充38% 15、盖印图层（Ctrl+Alt+Shift+E），不透明度46%，填充48%， 16、Ctrl+E合并可见图层，锐化一下&nbsp;\n照片名称：年轻化处理出人物的细嫩肌肤\n&nbsp;\n1.复制背景层。滤镜-模糊-高斯模糊，半径设为10。 2.设置层的混合模式，为“颜色”。双击层右边的名称打开混合选项。在高级混合，取消R与G的高级通道， 3.利用曲线平衡色彩的形象，根据图片来决定 4.新建图层，选择修复刷（ J ），选中“对所有图层取样”。对大的雀斑或污点，仿制去除。 5.ctrl+shift+alt+E，盖印所有图层，勾出皮肤部份，可以选择适合自己的方法，我个人比较喜欢钢笔工具，当然你也可以使用多边形套索工具，要注意的是，要处理的是皮肤，所以要去除眼睛，眉毛，嘴唇，鼻孔。反选（ctrl+shift+i ）删除除皮肤，多余部份。 6.滤镜-模糊-高斯模糊，半径为20。设置层的透明度为75 % 7.CTRL+J，复制图层3，滤镜-其他-高反差保留，半径为4，混合模式为“线性光”，不透明度为40 ％ 。\n照片名称：调出照片的灿烂颜色\n&nbsp;\n1.打开原图，Ctrl+U，色相饱和度，色相-79，饱和度-22，明度+17， 2.Ctrl+M，调曲线，红通道，稍稍提上去一些， 3.新建图层，把前景颜色设置为：#F9DA06，背景颜色设置为黑色，滤镜 &gt; 渲染 &gt; 云彩，Ctrl + Alt + F加强一下，图层混合模式改为“颜色加深”，脸上如果有杂色，保持前景颜色不变用画笔工具涂一下， 4.新建图层，Ctrl + Shift + Alt + E 盖印图层，滤镜 &gt; 艺术效果 &gt; 绘画涂抹，画笔大小6，锐化程度0，画笔类型简单，加图层蒙版，把人物部分及下面的地面部分用黑色画笔擦出来 5.新建图层填充颜色：#ADF871，图层混合模式改为“颜色加深”，加上图层蒙版把除绿色的地方都用黑色画笔擦掉，把背景的绿色调鲜嫩。\n6.新建图层，Ctrl + Shift + Alt + E盖印图层，Ctrl + Shift + U 去色，图层混合模式改为“滤色”，图层不透明度改为：40%， 7.新建图层，Ctrl + Alt + ~ 调出高光选区，填充颜色：#FBF4C4，图层混合模式改为“颜色减淡”，图层不透明度改为：30% 8.新建图层，Ctrl + Shift + Alt + E盖印图层适当的把细节修饰一下，最后锐化一下\n\n照片名称：旧调的一种简单方法\n&nbsp;\n1.打开原图，色相饱和度：饱和度-55 2.做个红色通道的曲线对比，数值和程度根据图片来，在做绿色通道的颜色对比，蓝色通道反向对比， 3.色相饱和度：饱和度-35 4.复制图层，滤镜-其他-高反差保留，我用的数值是250，混合模式为正片叠底， 5.做个渐变映射的调整层，黑-白， 6.滤镜-模糊-高斯模糊，半径4，可以增加图片的神秘感，擦出人物， 7.把图片上不协调的蓝色的饱和度-100，明度-100\n\n照片名称：黑白片复古上色\n&nbsp;\n1.打开图像，复制图层，用套索工具（比较细致，干净）把皮肤勾出来，（通道也可以），复制勾出来的皮肤， 2.图像-调整-可选颜色，中性色：-49，-5，+100，0 3.勾出上一部分，复制，图像-调整-可选颜色，中性色：+35，-37，+64，+22 4.勾裤子，复制，图像-调整-可选颜色，中性色：-29，-48，-31，0.Ctrl+L色阶调整裤子的光感，色阶：0，0.81，175 5，勾出头发，复制，不需要很干净，边缘有点背景色，可以让头发更融合，勾出背景， 6.调色，图像-调整-可选颜色，中性色：-30，-47，+100，0. 7.选中背景层，（没有头发，没有皮肤，没有裤子那层），按Q进入快速蒙板，选择渐变工具，黑色到透明，从左上角往右下角拉渐变，觉得黑色的范围已经选出来了，就可以按Q退出快速蒙板，色阶：0，0.32，255 8.用同样的方法把左边的光源调出来，按Ctrl+A，Ctrl+Shift+C，Ctrl+V，把所有图层都复制到了一层，放到最上层，叠加，使颜色更鲜艳， 9.细节部分（眼白，眼珠，嘴唇，拖鞋，指甲）上色，在最后的图上加光照效果，感觉有车子开过来\n\n照片名称：经典电影海报的制作\n&nbsp;\n1.打开原图，复制图层， 2.新建空白层，填充黑色，放到背景副本下面， 3.调整副本涂层，选择套索工具，将人物大半身圈出来，羽化30，Ctrl+Shift+I反选，Delete删除， 4.新建一个图层。混合模式为“颜色”选择ecd039（金黄色），用画笔仔细的图出戒子的颜色。这样在全副黑白的照片中，这种颜色的点缀很漂亮。 5.Ctrl+L调出色阶，把图像压暗一点，116，1，255 6.新建图层，添加文字，每添加一段文字最好新建一个图层，这样对排版比较灵活\n\n照片名称：《魔幻》海报\n&nbsp;\n1.打开原图，复制对比度最大的蓝色通道， 2.然后用色阶把对比度进一步加大，目的是只让石头有层次 3.把调整好的蓝色通道副本复制到图层里面，并为其添加你希望的颜色，我用的深橙色 4.把底图的红色通道复制到图层，用蒙版去掉天空和石头，只保留草地，并且用渐变映射为其添加色彩 5.打开素材闪电球，复制对比度最大的红色通道到刚才的文件 6.选择图层混合模式为叠加，调整位置及大小，使其成为一个光源，去除一些多余的东西（自己决定），然后用径向放射模糊滤镜处理一下，让其形成发射的光束 7.去通道里面复制底图的红色通道，加强对比度，让草地的高光部分显露得更明显，然后选择高光部分粘贴到图层里面，用白色填充，图层模式为叠加，然后用蒙版去掉天空部分的白色，只保留草地的部分，让草地出现被强光照射的光感 8.选择图层1的蒙版然后反选，得到天空的选区，添加曲线和色相/饱和度调整层，根据个人喜好调整自己喜欢的色彩及纯度 9.最后加入一些海报元素，让假海报看起来真实一点，在色彩运用方面，我尽量选择了金色来和石头的颜色相点缀，让色彩之间有所呼应\n\n照片名称：引经据典，和创意大师的思想交流\n&nbsp;\n1.打开原图，建立曲线调整图层，单击“自动”，混合模式为亮度， 2.操作曲线层，Ctrl+A全选，Ctrl+Shift+C复制，Ctrl+V粘贴，得到图层2，混合模式为正片叠底， 3.打开天空素材，Ctrl+A全选，Ctrl+C复制，Ctrl+V粘贴，Ctrl+T自由变换拉至合适大小位置，混合模式为叠加，用橡皮或者画笔将山体和湖面上的蓝色云层擦掉 4.Ctrl+J复制天空图层，Ctrl+T右键“垂直翻转”，拉直下方底线对齐，混合模式为叠加，擦掉山体和重叠在天空的部分， 5.在复制一层天空图层，加深天空中云彩的质感， 6.盖印可见图层（Ctrl+Alt+Shift+E），滤镜-模糊-高斯模糊。半径15，混合模式为柔光， 7，添加色相饱和度调整图层，饱和度-35，让画面更柔和， 8.添加通道混合器调整层，红通道+100，60，-8，绿通道30.+100，如果亮度高的话，可用最开始的曲线调整层压低亮度，可以更改通道混合器调整层的混合模式“点光”，或者“其他”来看效果\n\n照片名称：海边滩涂\n&nbsp;\n1.打开原图，新建图层（Ctrl+Shift+Alt+N），然后盖印可见图层(Ctrl+Alt+Shift+E)， 2.进入通道，复制对比比较强的绿色通道，然后把对比度加大，白的变白，黑的变黑，或者用画笔（叠加模式）Ctrl+绿通道副本，提取选区 3.把天空素材拖进来，建立蒙版，擦出人物 4.建立图层，柔光模式，让天空好看些， 5.做水面的倒影，Ctrl+T垂直翻转，建立蒙版，用画笔画出自己想要的效果，正片叠底模式效果好些，因图而异， 6.调色，按个人习惯调，可选颜色很好用， 7.Shift+Ctrl+Alt+E，盖印可见图层，图层模式正片叠底，再用蒙版把四角压暗些，主要针对水面压暗，让画面平衡些， 8.滤镜-杂色-添加杂色，数量3，高斯分布，单色，使人物和天空的颗粒感一致， 9，最后补上天空素材\n\n照片名称：PS中照片转手绘效果\n1.打开原文件，根据自己的感觉通过色彩调整将片子调整，然后磨皮，磨皮值不要太大，（Neat image插件） 2.新建图层，颜色为FEE7D6，（根据片子人物的肤色来设置），图层模式为叠加25%，用画笔20%在脸部和脖子处皮肤轻涂， 3.五官的细化工作，抠出嘴部，进行羽化复制（Ctrl+J），用涂抹工具对唇部进行涂抹，使唇部皮肤变得柔和细腻（强度不要太大） 4.新建图层，给唇部和脸部上色，颜色为FDC1D6，图层模式为颜色，用画笔在唇部和脸侧进行涂抹， 5.用减淡工具，范围是高光，曝光度25%画出唇部的高光部分，用加深工具，范围是中间，曝光度20%，加强唇部对比， 6.新建图层，颜色为8E1A25，画笔像素为3，画出内侧内线，然后像素为2画出唇部外侧线条，（高光部分线条建蒙板减淡些） 7.对鼻子进行圈选羽化，复制，用涂抹工具对鼻子周围进行柔和细化，接着用减淡工具范围是高光，曝光度20%，加强下鼻子的高光部分，然后用颜色422B2D，笔刷为2像素画出鼻子的轮廓线（线条如果淡了用加深工具来弥补下）\n8.对眼睛眉毛圈选羽化复制，用涂抹工具对眼睛眉毛周围皮肤进行柔和细化，接着用减淡工具范围是高光，曝光度15%，加强下眼眶的高光部分，用加深工具范围是中间，加深眼睛周边的线条， 9.用涂抹工具对眼珠部分进行涂抹细化，看起来更柔和些，用加深工具对黑眼珠部分加深，用减淡工具范围是高光，曝光度20%加强眼珠的高光部分，使看起来眼睛更明亮， 10.颜色080101，画笔像素3，画出睫毛部分，（线条颜色深浅可用加深减淡工具来弥补）睫毛线条也可以用路径等一些方法勾出， 11.用涂抹工具把眉形涂抹的漂亮些，眉头粗点颜色稍深一点，后面顺着涂抹淡化下去，然后用画笔2个像素在眉前端画出眉毛线条，使眉毛更有层次， 12.涂抹工具选择适合头发的画笔，（根据头发的纹理设置画笔形状），涂抹过程中要顺着头发的纹理涂抹，不要太过力，涂抹的要均匀， 13.发梢部分用正常的画笔涂抹来衔接上，（涂抹头发一定要细心）\n14.画出头发的质感来，新建图层，图层模式为叠加，选择铅笔像素为1，（数值根据人物图片大小来定），颜色为DFDFDF顺着头发的纹理画出流畅的线条 15.马尾部分可选择画笔工具，带分叉的一些笔刷淡淡顺着纹理画上，颜色图层模式同上， 16.新建图层，正常模式，选择画笔工具，像素为1，不透明度60%，流量80%，颜色为白色，画出前额动感发丝， 17.衣服和项链部分用涂抹工具涂抹的柔和些，然后选择用减淡工具，范围是高光，曝光20%，加强衣服和项链的高光部分 18.合成，对图片整体进行锐化，锐化值为8，用减淡工具对高光部分进行稍微加工下，整体颜色校正下，（可以添加一些背景灯修饰，突出主题）\n\n照片名称：后期妆容攻略\n&nbsp;\n1.打开文件，复制一个图层副本 2.选中复制的图层按自由变换快捷键ctrl+t改变人物的脸形使更修长 3.按合并图层（ctrl+e）后，用载剪工具使画面从新构图，裁去多出的部份， 4.图像-调整-可选颜色：红色--70，-20，-20，-50.黄色--40，-20，-30，-80.白色-0，0，0，-50.中间色-0，-5，-5，-5 5.按曲线（ctrl+m）调整整体颜色，RGB全通道-输出214，输入174，蓝通道-输出131，输入124， 6.图像-调整-色彩平衡（ctrl+b），阴影-10，0，+15。高光--10，0，+2. 7.用图章工具将嘴周围皮肤盖均匀， 8.用钢笔把眼袋和脸部暗部圈起，羽化60，曲线把选区调亮使减淡眼袋和减小脸部肌肉不放松的表情， 9.继续选区羽化60，曲线调亮，使脸部饱满点，输出146，输入113. 10.把高光部份圈出来，羽化60\n11.曲线调亮，使脸部饱满点，输出138，输入118. 12.修眉，把眉毛顶部连皮肤用套索工具圈起，羽化5，复制一层，把复制图层往下移，以达到修眉作用，图章修眉，这个要很仔细 13.开始调整眼睛，选把眼球部份圈出来，复制一层 14.钢笔圈出要做眼影的区域，复制一层后，曲线压暗，颜色要调整好， 15.再把眼影颜色统一，色彩平衡（中间调）：+50，0，0。（阴影）：+20，0，0， 16.细节颜色调整，上眼睑1/3部分,色相饱和度：0，-40，0 17.圈出细节，上眼睑睫毛根处，下眼睑前眼角1/3处，按DELETE键删除选区，使露出高光位， 18.删除多出的眼影部份，羽化40 19.圈出细节，内眼角到上眼睑1/2处，按DELETE键删除选区，使露出高光位 20.把眼珠圈出来，复制一层，羽化1，眼白部份减饱和度，退杂色，色相饱和度：0，-50，0 21.眼白细节调整，曲线调整调高光， 22.眼珠复制一层后曲线调亮，用笔刷刷退左眼上半部份，显示些阴影，\n23.删除瞳孔部份 24.用曲线调整眼部色彩，使一致 25.加眼神高光 26.圈出嘴唇，羽化2，曲线调整嘴唇高光，调整嘴唇颜色 27.调整鼻梁高光，调整眼影高光 28.用可选颜色作整体调色，中间色-0，0，-2，2. 29.用色颜平衡微调，（高光）：0，2，-2. 30.液化把头发拉顺，加上镜头光晕，亮度182，35毫米聚焦， 31.最后在适当的地方加上闪光笔刷完成\n\n照片名称：将照片转为水墨效果\n&nbsp;\n1.复制图层，调整-去色， 2.曲线调节，加大明暗对比，输入114，输出186 3.复制图层，滤镜-画笔描边-墨水轮廓，描边长度5，神色强度10，光照强度10，降图层改成柔光模式，调整不透明度， 4.滤镜-高斯模糊，半径2.0像素， 5.滤镜-画笔描边-喷溅，喷色半径1，平滑度3， 6.添加浅棕色纯色层，，图岑附魔师为颜色，调整不透明度，不透明度尽量小些， 7.点掉纯色层及图层前边的眼睛将其隐藏，新建图层用笔刷在灯笼，树，瓦片等处用适当颜色图层， 8.将隐藏图层重新恢复，修改图层模式为叠加，看效果来调细节， 9.对画面整体效果进行细调，直到达到满意的效果，没有具体步骤，因人而异\n\n照片名称：油画效果\n&nbsp;\n1 首先拿出事先拍好的图片。 2 用蒙板遮罩天空部分。 3 添加天空部分，并放置于底层，可根据画面适当调整。 4 新建一层为第三层，主要是调整画面色调。 5 根据需求修改不透明度，修改图层属性为柔光。 6 为了寻求油画中的肌理效果，在色调层上面再添加了一个素材层 7 修改图层属性为柔光，根据需求修改不透明度。这里不透明度为86% 8 添加蒙板，根据画面需要适当取舍内容。 9 为了加强肌理感，再新建一层，填充灰色。 10 在滤镜中添加杂色为高斯分布并勾选单色，数量自定。 11 图层改为柔光。 12 根据画面需要用蒙板适当加以调整。 13 噪点，添加杂色-数量400，高斯分布\n照片名称：广告片的调色与设计\n&nbsp;\n1.复制图层,新建通道混合调整图层,灰色通道，红色+64%，绿色+2%，蓝色+10%，单色 2.新建纯色混合图层，选择575046颜色，混合模式为颜色， 3.新建曲线调整图层，①-输入68，输出32，②-输入114，输出68，③-输入208，输出197， 4.新建一纯色图层，选择443B25颜色，混合模式为颜色，按住Alt单击蒙板， 5.Ctrl+D恢复默认的背景颜色，Ctrl+Delete给蒙版填充黑色的背景色， 6.改变画面，中高光与暗部过渡部分的色调，以丰富画面的色彩，用画笔在蒙板 插出需要上色的部分，300像素，不透明度10%，流量100% 7.字体的安排与设计\n8.为了使人物与画面的色调有个呼应，给人物的嘴唇上点唇彩，新建一个图层，选择线性减淡混合模式，添上90753D颜色，选择适合上唇彩的画笔，散点的画笔，像素39， 9.放大 ，在唇的反光部位画出唇彩，注意观察，不断的调整，画好唇彩之后看下总体，这个时候画面已经有个呼应了，色彩变得丰富，又不喧宾夺主，正好衬托出了产品， 10.如果产品直接带在模特身上了，在给人物调好色之后，在给产品上色或者用蒙板把产品直接给插出来都可以。\n\n照片名称：精灵的灵异效果\n&nbsp;\n1.打开图片，复制图层， 2.进行简单磨皮，选择-色彩范围，用吸管点脸上皮肤颜色，颜色容差103左右，Ctrl+J得到新图层，Ctrl点击继续选上，添加蒙版，用画笔（前景色为黑色），去掉头发跟周围部分， 3.滤镜-模糊-高斯模糊，像素1.7，降低图层的不透明度，达到自然的磨皮效果， 4.选择-色彩范围，用吸管吸取头发颜色，用中间吸管+增加选取范围，新建曲线调节图层，增加对比度，根据图片适当调节， 5.鼠标左键点曲线1的蒙版，出现选区，新建色阶调节图层，色阶：16，1.11，214 6.新建色相饱和度调节图层，红色：-54，黄色：-100 7.创建新组，把以上所有调整图层纳入其中，方便整理修整， 8.新建组，为头发上色装饰，新建图层，用画笔（白色），硬度为0，图层属性柔光模式， 9.新建图层，用钢笔工具勾线条（珍珠路径），线条任意，整齐点，理顺头发，令头发乱中有序， 10.用画笔工具，F5快捷键调出画笔设置对话框，像素13，硬度100%，间距 105%，形状动态，平滑，角度0，圆度100%， 11.切换到路径面板，点右三角选择描边路径，确定，\n12.双击珍珠路径图层，设置图层模式，投影：结构-正片叠底，黑色，不透明度28%，角度120&deg;，距离0，扩展0，大小5像素，品质-杂色0.斜面和浮雕：结构-浮雕效果，平滑方法，深度120%，方向上，阴影-角度120&deg;，正片叠底模式，白色，不透明度33%，阴影模式正片叠底，天蓝色，不透明度36%。 13.用橡皮工具修整外形，添加蒙版，不透明度32%，涂抹珠子，使珠子和下面头发有虚实结合， 14.新建图层，用雪花笔刷大小不一的排列画面中，调整雪花图层样式，投影：结构-正片叠底，黑色，角度120&deg;，使用全局光，距离7，扩展5%，大小1。内投影：正片叠底，黑色，不透明度12%，角度120&deg;，距离7，阻塞10%。外发光：结构-滤色，不透明度73%，湖蓝色，图素-方法柔和，大小5像素，品质-范围50%。斜面和浮雕：结构-外斜面样式，方法平滑，深度281%，方向上，阴影-角度120&deg;，使用全局光，高度30&deg;，高光模式滤色，不透明度75%，阴影模式正片叠底，黑色，不透明度75%\n15.新建柔光涂层，复制背景图层，选区前景色（湖蓝色），R=133，G=244，B=244 16.新建图层，刷头发范围， 17.新建颜色图层，前景色-#6fc8c8，R=111，G=200，B=200， 18.新建颜色图层，刷头发和雪花珠子之上，可用橡皮擦，设置低不透明度，过渡。头发范围局部着色，多几层能更自然一些。 19.载入星光画笔装饰界面， 20.给皮肤整体刷蓝色柔光图层，加冷调子与画面统一。 新建无关皮肤上色组，新建皮肤柔光图层，线画笔，硬度为0，前景色为湖蓝色。给脸上上色，高光和暗部冷暖区别，用到蓝色和粉色。多画几层过渡就自然。\n\n照片名称：给风景PS水彩效果\n&nbsp;\n1.照一张带白边的图片风景图，有白边为做边缘溢出效果 2.色相饱和度：饱和度+80，调整出印象派的效果， 3.编辑-定义图案。 4.建白色填充层，不透明度50%，再建一个透明图层 5.图案图章工具，画笔主直径200，画笔选自带湿介质画笔45，模式正常，不透明度100%，印象派效果前面打勾， 6.在透明图层图案图章画画，远景次景笔触大，反之笔触小细节多，调不透明度查看上面图层的笔触， 7.复制背景层去色，滤镜-喷溅，不透明度71%，图层模式为叠加 8.滤镜-纹理-纹理化，不透明度100%， 9.滤镜-扭曲-扩散光亮37%&nbsp;\n照片名称：一种魔幻画面效果\n&nbsp;\n1.用钢笔在背部勾勒一个翅膀的外形， 2.在当前的工作路径转换成路径1，双击工作路径即可。 3.将路径转换成选区（Alt+回车），复制一层，羽化3像素， 4.填充白色，选择合适的强度使用涂抹工具，进行适当的边缘的涂抹。 5.复制图层，填充不同颜色，合图层1有区别即可，调节透明度呵图层属性， 6.按照前面的方法制作第二个翅膀，调节合适的透明度，可以用黑白渐变调整层及蒙板调整， 7.新建图层，画一个圆形选区，在选区中用画笔画圈，调节适当的透明度， 8.复制背景图层粘贴入新建的Alpha通道，除左上角外其他地方填充黑色，使用滤镜-模糊-径向模糊：数量90，模糊方法：缩放， 9.选择Alpha通道（在通道上按住Ctrl），在图层区新建图层，填充淡黄色， 10.用钢笔生成光束的路径，将路径转换成选区，填充黄白渐变色， 11.调节透明度，用橡皮擦擦光的底部，是光线变得自然， 12.用钢笔在人物身上勾勒光线路径，将路径转换成选区，在选区边缘用画笔画，调节透明度，结合橡皮擦和涂抹工具会达到更好的效果，多花几个光环效果会更好\n\n照片名称：制作一张被揉皱的旧照片\n&nbsp;\n1.找一张皱折的背景，将需要制作的照片拖入背景层，调整尺寸并裁剪，使之与背景边框相配， 2.调整-色相饱和度，全图：饱和度-35，明度+10， 3.调整图层改成柔光模式，出来旧照片的效果了， 4.色相饱和度，全图：0，-80，0 5.复制图层，色相饱和度-着色：340，24，0 6.创建新图层，放在最顶端，填充黑色， 7.滤镜-杂色-添加杂色，增加陈旧感，数量25%，高斯分布， 8.混合模式为正片叠底， 9.图像-调整-反相， 10.将边框中的杂色去掉，用矩形选择工具选边框内侧边，DEL键删除轮廓部分的杂色， 11.用橡皮擦工具擦出人物周围的杂色照片名称：玩转色彩-调色跟着感觉走\n&nbsp;\n1.复制图层，转入通道，复制红色通道，曲线调整红色通道副本，输入100，输出3， 2.用画笔或选取工具，把人物和花填充白色， 3.Ctrl+点击红副本，使其变为选区，删除红副本，返回图层面板， 4.Ctrl+C复制，Ctrl+V粘贴，人物和花抠图完成， 5.方法一：新建填充图层，R=255，G=128，B=173，图层改为颜色模式， 6.方法二：饱和度着色法，新建色相饱和度调整图层，着色前面打勾，色相=345，饱和度=60，明度=0，新建曲线调整图层，237，255；188，130 7.方法三：新建色彩平衡图层，中间调-色阶：+100，-54，-20/+100，-35，+43 阴影-色阶：+11，-7，+3.新建可选颜色调整图层，红色：0，+21，-23，-5.洋红：-100，-45，+32，-1 8.渐变映射运用，新建渐变映射1，图层改为颜色\n\n照片名称：Ps-油画效果\n&nbsp;\n1.新建图层，用历史画笔，松散长画笔20， 2.整体先扫一遍，随便涂， 3.用7的画笔画出边缘和细节，再用1的画笔画出五官衣服和物品， 4.样式改成绷紧口画脸部细节 5.用模糊工具画出脸部细节 6.复制两层，滤镜-艺术效果-绘画涂抹，画笔大小5，锐化程度15，画笔类型-简单 7.滤镜--纹理-纹理化，纹理-画布，缩放84%，凸现5，光照右上\n照片名称：破解-足球宝贝教程\n&nbsp;\n1.打开原图，复制图层，填充纯黑色，叠加模式。 2.新建色相饱和度图层：饱和度-85. 3.新建亮度对比度图层：对比度+10， 4.新建可选颜色，红色：0，+30，0，+100。黄色：0，-15，-100，0.中间色：0，0，0，+5. 5.盖印，滤镜-渲染-光照效果：点光，强度21，聚焦24，光泽0，材料69，曝光度0，环境8， 6.盖印，加文字装饰\n&nbsp;\n\n        ', null);
INSERT INTO `blog` VALUES ('90', 'C语言程序设计经典100例，会用到的', '\n            \n \n【程序1】\n题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？\n1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去\n　　　　　　掉不满足条件的排列。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int i,j,k;\n&nbsp;&nbsp;printf(&quot;\\n&quot;);\n&nbsp;&nbsp;for(i=1;i&lt;5;i++) /*以下为三重循环*/\n&nbsp;&nbsp;&nbsp;&nbsp;for(j=1;j&lt;5;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (k=1;k&lt;5;k++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i!=k&amp;&amp;i!=j&amp;&amp;j!=k) /*确保i、j、k三位互不相同*/\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d,%d,%d\\n&quot;,i,j,k);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序2】\n题目：企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高\n　　　于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可可提\n　　　成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于\n　　　40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于\n　　　100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？\n1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。　　　　　　\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;long int i;\n&nbsp;&nbsp;int bonus1,bonus2,bonus4,bonus6,bonus10,bonus;\n&nbsp;&nbsp;scanf(&quot;%ld&quot;,&amp;i);\n&nbsp;&nbsp;bonus1=100000*0. 1;\n&nbsp;&nbsp;bonus2=bonus1+100000*0.75;\n&nbsp;&nbsp;bonus4=bonus2+200000*0.5;\n&nbsp;&nbsp;bonus6=bonus4+200000*0.3;\n&nbsp;&nbsp;bonus10=bonus6+400000*0.15;\n&nbsp;&nbsp;if(i&lt;=100000)\n&nbsp;&nbsp;&nbsp;&nbsp;bonus=i*0.1;\n&nbsp;&nbsp;&nbsp;&nbsp;else if(i&lt;=200000)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus=bonus1+(i-100000)*0.075;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(i&lt;=400000)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus=bonus2+(i-200000)*0.05;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(i&lt;=600000)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus=bonus4+(i-400000)*0.03;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(i&lt;=1000000)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus=bonus6+(i-600000)*0.015;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bonus=bonus10+(i-1000000)*0.01;\n&nbsp;&nbsp;printf(&quot;bonus=%d&quot;,bonus);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序3】\n题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？\n1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后\n　　　　　　的结果满足如下条件，即是结果。请看具体分析：\n2.程序源代码：\n#include &quot;math.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;long int i,x,y,z;\n&nbsp;&nbsp;for (i=1;i&lt;100000;i++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;x=sqrt(i+100); /*x为加上100后开方后的结果*/\n&nbsp;&nbsp;&nbsp;&nbsp;y=sqrt(i+268); /*y为再加上168后开方后的结果*/\n&nbsp;&nbsp;&nbsp;&nbsp;if(x*x==i+100&amp;&amp;y*y==i+268) /*如果一个数的平方根的平方等于该数，这说明此数是完全平方数*/\n&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n%ld\\n&quot;,i);\n&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序4】\n题目：输入某年某月某日，判断这一天是这一年的第几天？\n1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊\n　　　　　　情况，闰年且输入月份大于3时需考虑多加一天。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int day,month,year,sum,leap;\n&nbsp;&nbsp;printf(&quot;\\nplease input year,month,day\\n&quot;);\n&nbsp;&nbsp;scanf(&quot;%d,%d,%d&quot;,&amp;year,&amp;month,&amp;day);\n&nbsp;&nbsp;switch(month) /*先计算某月以前月份的总天数*/\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;case 1:sum=0;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 2:sum=31;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 3:sum=59;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 4:sum=90;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 5:sum=120;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 6:sum=151;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 7:sum=181;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 8:sum=212;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 9:sum=243;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 10:sum=273;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 11:sum=304;break;\n&nbsp;&nbsp;&nbsp;&nbsp;case 12:sum=334;break;\n&nbsp;&nbsp;&nbsp;&nbsp;default:printf(&quot;data error&quot;);break;\n&nbsp;&nbsp;}\n&nbsp;&nbsp;sum=sum+day; /*再加上某天的天数*/\n&nbsp;&nbsp;if(year%400==0||(year%4==0&amp;&amp;year%100!=0)) /*判断是不是闰年*/\n&nbsp;&nbsp;&nbsp;&nbsp;leap=1;\n&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;leap=0;\n&nbsp;&nbsp;if(leap==1&amp;&amp;month&gt;2) /*如果是闰年且月份大于2,总天数应该加一天*/\n&nbsp;&nbsp;&nbsp;&nbsp;sum++;\n&nbsp;&nbsp;printf(&quot;It is the %dth day.&quot;,sum);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序5】\n题目：输入三个整数x,y,z，请把这三个数由小到大输出。\n1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，\n　　　　　　然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int x,y,z,t;\n&nbsp;&nbsp;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);\n&nbsp;&nbsp;if (x&gt;y)\n&nbsp;&nbsp;&nbsp;&nbsp;{t=x;x=y;y=t;} /*交换x,y的值*/\n&nbsp;&nbsp;if(x&gt;z)\n&nbsp;&nbsp;&nbsp;&nbsp;{t=z;z=x;x=t;} /*交换x,z的值*/\n&nbsp;&nbsp;if(y&gt;z)\n&nbsp;&nbsp;&nbsp;&nbsp;{t=y;y=z;z=t;} /*交换z,y的值*/\n&nbsp;&nbsp;printf(&quot;small to big: %d %d %d\\n&quot;,x,y,z);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序6】\n题目：用*号输出字母C的图案。\n1.程序分析：可先用\'*\'号在纸上写出字母C，再分行输出。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;printf(&quot;Hello C-world!\\n&quot;);\n&nbsp;&nbsp;printf(&quot; ****\\n&quot;);\n&nbsp;&nbsp;printf(&quot; *\\n&quot;);\n&nbsp;&nbsp;printf(&quot; * \\n&quot;);\n&nbsp;&nbsp;printf(&quot; ****\\n&quot;);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序7】\n题目：输出特殊图案，请在c环境中运行，看一看，Very Beautiful!\n1.程序分析：字符共有256个。不同字符，图形不一样。　　　　　　\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;char a=176,b=219;\n&nbsp;&nbsp;printf(&quot;%c%c%c%c%c\\n&quot;,b,a,a,a,b);\n&nbsp;&nbsp;printf(&quot;%c%c%c%c%c\\n&quot;,a,b,a,b,a);\n&nbsp;&nbsp;printf(&quot;%c%c%c%c%c\\n&quot;,a,a,b,a,a);\n&nbsp;&nbsp;printf(&quot;%c%c%c%c%c\\n&quot;,a,b,a,b,a);\n&nbsp;&nbsp;printf(&quot;%c%c%c%c%c\\n&quot;,b,a,a,a,b);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序8】\n题目：输出9*9口诀。\n1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int i,j,result;\n&nbsp;&nbsp;printf(&quot;\\n&quot;);\n&nbsp;&nbsp;for (i=1;i&lt;10;i++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;for(j=1;j&lt;10;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result=i*j;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d*%d=%-3d&quot;,i,j,result); /*-3d表示左对齐，占3位*/\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;); /*每一行后换行*/\n&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序9】\n题目：要求输出国际象棋棋盘。\n1.程序分析：用i控制行，j来控制列，根据i+j的和的变化来控制输出黑方格，还是白方格。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int i,j;\n&nbsp;&nbsp;for(i=0;i&lt;8;i++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;8;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((i+j)%2==0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%c%c&quot;,219,219);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;&nbsp;&nbsp;&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;);\n&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序10】\n题目：打印楼梯，同时在楼梯上方打印两个笑脸。\n1.程序分析：用i控制行，j来控制列，j根据i的变化来控制输出黑方格的个数。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int i,j;\n&nbsp;&nbsp;printf(&quot;\\1\\1\\n&quot;); /*输出两个笑脸*/\n&nbsp;&nbsp;for(i=1;i&lt;11;i++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;for(j=1;j&lt;=i;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%c%c&quot;,219,219);\n&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;);\n&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n\n\n　　.:.:经典c程序100例==11--20 :.:.\n\n　　　　经典c程序100例==11--20\n【程序11】\n题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月\n　　　后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？\n1.程序分析：　兔子的规律为数列1,1,2,3,5,8,13,21....\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;long f1,f2;\n&nbsp;&nbsp;int i;\n&nbsp;&nbsp;f1=f2=1;\n&nbsp;&nbsp;for(i=1;i&lt;=20;i++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%12ld %12ld&quot;,f1,f2);\n&nbsp;&nbsp;&nbsp;&nbsp;if(i%2==0) printf(&quot;\\n&quot;); /*控制输出，每行四个*/\n&nbsp;&nbsp;&nbsp;&nbsp;f1=f1+f2; /*前两个月加起来赋值给第三个月*/\n&nbsp;&nbsp;&nbsp;&nbsp;f2=f1+f2; /*前两个月加起来赋值给第三个月*/\n&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序12】\n题目：判断101-200之间有多少个素数，并输出所有素数。\n1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，\n　　　　　　则表明此数不是素数，反之是素数。 　　　　　　\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\n#include &quot;math.h&quot;\nmain()\n{\n&nbsp;&nbsp;int m,i,k,h=0,leap=1;\n&nbsp;&nbsp;printf(&quot;\\n&quot;);\n&nbsp;&nbsp;for(m=101;m&lt;=200;m++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;k=sqrt(m+1);\n&nbsp;&nbsp;&nbsp;&nbsp;for(i=2;i&lt;=k;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;if(m%i==0)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leap=0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if(leap)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%-4d&quot;,m);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(h%10==0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;leap=1;\n&nbsp;&nbsp;}\n&nbsp;&nbsp;printf(&quot;\\nThe total is %d&quot;,h);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序13】\n题目：打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数\n　　　本身。例如：153是一个“水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。\n1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int i,j,k,n;\n&nbsp;&nbsp;printf(&quot;\'water flower\'number is:&quot;);\n&nbsp;&nbsp;for(n=100;n&lt;1000;n++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;i=n/100;/*分解出百位*/\n&nbsp;&nbsp;&nbsp;&nbsp;j=n/10%10;/*分解出十位*/\n&nbsp;&nbsp;&nbsp;&nbsp;k=n%10;/*分解出个位*/\n&nbsp;&nbsp;&nbsp;&nbsp;if(i*100+j*10+k==i*i*i+j*j*j+k*k*k)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%-5d&quot;,n);\n&nbsp;&nbsp;}\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序14】\n题目：将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。\n程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：\n(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。\n(2)如果n&lt;&gt;k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,\n　重复执行第一步。\n(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。\n2.程序源代码：\n/* zheng int is divided yinshu*/\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int n,i;\n&nbsp;&nbsp;printf(&quot;\\nplease input a number:\\n&quot;);\n&nbsp;&nbsp;scanf(&quot;%d&quot;,&amp;n);\n&nbsp;&nbsp;printf(&quot;%d=&quot;,n);\n&nbsp;&nbsp;for(i=2;i&lt;=n;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;while(n!=i)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(n%i==0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d*&quot;,i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n=n/i;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;printf(&quot;%d&quot;,n);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序15】\n题目：利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，\n　　　60分以下的用C表示。\n1.程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int score;\n&nbsp;&nbsp;char grade;\n&nbsp;&nbsp;printf(&quot;please input a score\\n&quot;);\n&nbsp;&nbsp;scanf(&quot;%d&quot;,&amp;score);\n&nbsp;&nbsp;grade=score&gt;=90?\'A\':(score&gt;=60?\'B\':\'C\');\n&nbsp;&nbsp;printf(&quot;%d belongs to %c&quot;,score,grade);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序16】\n题目：输入两个正整数m和n，求其最大公约数和最小公倍数。\n1.程序分析：利用辗除法。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int a,b,num1,num2,temp;\n&nbsp;&nbsp;printf(&quot;please input two numbers:\\n&quot;);\n&nbsp;&nbsp;scanf(&quot;%d,%d&quot;,&amp;num1,&amp;num2);\n&nbsp;&nbsp;if(num1&lt;num2)/*交换两个数，使大数放在num1上*/\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;temp=num1;\n&nbsp;&nbsp;&nbsp;&nbsp;num1=num2;\n&nbsp;&nbsp;&nbsp;&nbsp;num2=temp;\n&nbsp;&nbsp;}\n&nbsp;&nbsp;a=num1;b=num2;\n&nbsp;&nbsp;while(b!=0)/*利用辗除法，直到b为0为止*/\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;temp=a%b;\n&nbsp;&nbsp;&nbsp;&nbsp;a=b;\n&nbsp;&nbsp;&nbsp;&nbsp;b=temp;\n&nbsp;&nbsp;}\n&nbsp;&nbsp;printf(&quot;gongyueshu:%d\\n&quot;,a);\n&nbsp;&nbsp;printf(&quot;gongbeishu:%d\\n&quot;,num1*num2/a);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序17】\n题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。\n1.程序分析：利用while语句,条件为输入的字符不为\'\\n\'.\n　　　　　　\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;char c;\n&nbsp;&nbsp;int letters=0,space=0,digit=0,others=0;\n&nbsp;&nbsp;printf(&quot;please input some characters\\n&quot;);\n&nbsp;&nbsp;while((c=getchar())!=\'\\n\')\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;if(c&gt;=\'a\'&amp;&amp;c&lt;=\'z\'||c&gt;=\'A\'&amp;&amp;c&lt;=\'Z\')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letters++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(c==\' \')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(c&gt;=\'0\'&amp;&amp;c&lt;=\'9\')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digit++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;others++;\n&nbsp;&nbsp;}\n&nbsp;&nbsp;printf(&quot;all in all:char=%d space=%d digit=%d others=%d\\n&quot;,letters,\n&nbsp;&nbsp;space,digit,others);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序18】\n题目：求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时\n　　　共有5个数相加)，几个数相加有键盘控制。\n1.程序分析：关键是计算出每一项的值。\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;int a,n,count=1;\n&nbsp;&nbsp;long int sn=0,tn=0;\n&nbsp;&nbsp;printf(&quot;please input a and n\\n&quot;);\n&nbsp;&nbsp;scanf(&quot;%d,%d&quot;,&amp;a,&amp;n);\n&nbsp;&nbsp;printf(&quot;a=%d,n=%d\\n&quot;,a,n);\n&nbsp;&nbsp;while(count&lt;=n)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;tn=tn+a;\n&nbsp;&nbsp;&nbsp;&nbsp;sn=sn+tn;\n&nbsp;&nbsp;&nbsp;&nbsp;a=a*10;\n&nbsp;&nbsp;&nbsp;&nbsp;++count;\n&nbsp;&nbsp;}\n&nbsp;&nbsp;printf(&quot;a+aa+...=%ld\\n&quot;,sn);\n&nbsp;&nbsp;getch();\n}\n==============================================================\n【程序19】\n题目：一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如6=1＋2＋3.编程\n　　　找出1000以内的所有完数。\n1. 程序分析：请参照程序&lt;--上页程序14.\n2.程序源代码：\n#include &quot;stdio.h&quot;\n#include &quot;conio.h&quot;\nmain()\n{\n&nbsp;&nbsp;static int k[10];\n&nbsp;&nbsp;int i,j,n,s;\n&nbsp;&nbsp;for(j=2;j&lt;1000;j++)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;n=-1;\n&nbsp;&nbsp;&nbsp;&nbsp;s=j;\n&nbsp;&nbsp;&nbsp;&nbsp;for(i=1;i&lt;j;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((j%i)==0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=s-i;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k[n]=i;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if(s==0)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d is a wanshu&quot;,j);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d,&quot;,k\n);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d\\n&quot;,k[n]);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;getch();}============================================================== 【程序20】题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在　　　第10次落地时，共经过多少米？第10次反弹多高？1.程序分析：见下面注释2.程序源代码：#include &quot;stdio.h&quot;#include &quot;stdio.h&quot;main(){&nbsp;&nbsp;float sn=100.0,hn=sn/2;&nbsp;&nbsp;int n;&nbsp;&nbsp;for(n=2;n&lt;=10;n++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;sn=sn+2*hn;/*第n次落地时共经过的米数*/&nbsp;&nbsp;&nbsp;&nbsp;hn=hn/2; /*第n次反跳高度*/&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;the total of road is %f\\n&quot;,sn);&nbsp;&nbsp;printf(&quot;the tenth is %f meter\\n&quot;,hn);&nbsp;&nbsp;getch();}  　　.:.:经典c程序100例==21--30:.:.  　　　　经典c程序100例==21--30【程序21】题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个　　　第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下　　　的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。1.程序分析：采取逆向思维的方法，从后往前推断。2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int day,x1,x2;&nbsp;&nbsp;day=9;&nbsp;&nbsp;x2=1;&nbsp;&nbsp;while(day&gt;0)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;x1=(x2+1)*2;/*第一天的桃子数是第2天桃子数加1后的2倍*/&nbsp;&nbsp;&nbsp;&nbsp;x2=x1;&nbsp;&nbsp;&nbsp;&nbsp;day--;&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;the total is %d\\n&quot;,x1);&nbsp;&nbsp;getch();}==============================================================【程序22】题目：两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定　　　比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出　　　三队赛手的名单。 1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，　　　　　　则表明此数不是素数，反之是素数。 　　　　　　2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;char i,j,k;/*i是a的对手，j是b的对手，k是c的对手*/&nbsp;&nbsp;for(i=\'x\';i&lt;=\'z\';i++)&nbsp;&nbsp;&nbsp;&nbsp;for(j=\'x\';j&lt;=\'z\';j++)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i!=j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(k=\'x\';k&lt;=\'z\';k++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i!=k&amp;&amp;j!=k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i!=\'x\'&amp;&amp;k!=\'x\'&amp;&amp;k!=\'z\')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;order is a--%c\\tb--%c\\tc--%c\\n&quot;,i,j,k);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序23】 题目：打印出如下图案（菱形）&nbsp;&nbsp; *&nbsp;&nbsp;*** ************ *****&nbsp;&nbsp;***&nbsp;&nbsp; *1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重　　　　　　for循环，第一层控制行，第二层控制列。 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int i,j,k;&nbsp;&nbsp;for(i=0;i&lt;=3;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;=2-i;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;for(k=0;k&lt;=2*i;k++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;*&quot;);&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;}&nbsp;&nbsp;for(i=0;i&lt;=2;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;=i;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;for(k=0;k&lt;=4-2*i;k++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;*&quot;);&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序24】 题目：有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13...求出这个数列的前20项之和。1.程序分析：请抓住分子与分母的变化规律。 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int n,t,number=20;&nbsp;&nbsp;float a=2,b=1,s=0;&nbsp;&nbsp;for(n=1;n&lt;=number;n++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;s=s+a/b;&nbsp;&nbsp;&nbsp;&nbsp;t=a;a=a+b;b=t;/*这部分是程序的关键，请读者猜猜t的作用*/&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;sum is %9.6f\\n&quot;,s);&nbsp;&nbsp;getch();}==============================================================【程序25】 题目：求1+2!+3!+...+20!的和1.程序分析：此程序只是把累加变成了累乘。 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;float n,s=0,t=1;&nbsp;&nbsp;for(n=1;n&lt;=20;n++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;t*=n;&nbsp;&nbsp;&nbsp;&nbsp;s+=t;&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;1+2!+3!...+20!=%e\\n&quot;,s);&nbsp;&nbsp;getch();}==============================================================【程序26】 题目：利用递归方法求5!。1.程序分析：递归公式：fn=fn_1*4!2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int i;&nbsp;&nbsp;int fact();&nbsp;&nbsp;for(i=0;i&lt;5;i++)&nbsp;&nbsp;printf(&quot;\\40:%d!=%d\\n&quot;,i,fact(i));&nbsp;&nbsp;getch();}int fact(j)int j;{&nbsp;&nbsp;int sum;&nbsp;&nbsp;if(j==0)&nbsp;&nbsp;&nbsp;&nbsp;sum=1;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;sum=j*fact(j-1);&nbsp;&nbsp;return sum;}==============================================================【程序27】 题目：利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来。1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int i=5;&nbsp;&nbsp;void palin(int n);&nbsp;&nbsp;printf(&quot;\\40:&quot;);&nbsp;&nbsp;palin(i);&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;getch();}void palin(n)int n;{&nbsp;&nbsp;char next;&nbsp;&nbsp;if(n&lt;=1)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;next=getchar();&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n\\0:&quot;);&nbsp;&nbsp;&nbsp;&nbsp;putchar(next);&nbsp;&nbsp;}&nbsp;&nbsp;else&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;next=getchar();&nbsp;&nbsp;&nbsp;&nbsp;palin(n-1);&nbsp;&nbsp;&nbsp;&nbsp;putchar(next);&nbsp;&nbsp;}}==============================================================【程序28】 题目：有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第　　　3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后 　　　问第一个人，他说是10岁。请问第五个人多大？1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道　　　　　　第四人的岁数，依次类推，推到第一人（10岁），再往回推。2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;age(n)int n;{&nbsp;&nbsp;int c;&nbsp;&nbsp;if(n==1) c=10;&nbsp;&nbsp;else c=age(n-1)+2;&nbsp;&nbsp;return(c);}main(){&nbsp;&nbsp;printf(&quot;%d&quot;,age(5));&nbsp;&nbsp;getch();}==============================================================【程序29】 题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。1. 程序分析：学会分解出每一位数，如下解释：(这里是一种简单的算法，师专数002班赵鑫提供) 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main( ){&nbsp;&nbsp;long a,b,c,d,e,x;&nbsp;&nbsp;scanf(&quot;%ld&quot;,&amp;x);&nbsp;&nbsp;a=x/10000;/*分解出万位*/&nbsp;&nbsp;b=x%10000/1000;/*分解出千位*/&nbsp;&nbsp;c=x%1000/100;/*分解出百位*/&nbsp;&nbsp;d=x%100/10;/*分解出十位*/&nbsp;&nbsp;e=x%10;/*分解出个位*/&nbsp;&nbsp;if (a!=0) printf(&quot;there are 5, %ld %ld %ld %ld %ld\\n&quot;,e,d,c,b,a);&nbsp;&nbsp;else if (b!=0) printf(&quot;there are 4, %ld %ld %ld %ld\\n&quot;,e,d,c,b);&nbsp;&nbsp;&nbsp;&nbsp;else if (c!=0) printf(&quot; there are 3,%ld %ld %ld\\n&quot;,e,d,c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (d!=0) printf(&quot;there are 2, %ld %ld\\n&quot;,e,d);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (e!=0) printf(&quot; there are 1,%ld\\n&quot;,e);&nbsp;&nbsp;getch();}==============================================================【程序30】 题目：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。　　　1.程序分析：同29例2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main( ){&nbsp;&nbsp;long ge,shi,qian,wan,x;&nbsp;&nbsp;scanf(&quot;%ld&quot;,&amp;x);&nbsp;&nbsp;wan=x/10000;&nbsp;&nbsp;qian=x%10000/1000;&nbsp;&nbsp;shi=x%100/10;&nbsp;&nbsp;ge=x%10;&nbsp;&nbsp;if(ge==wan&amp;&amp;shi==qian)/*个位等于万位并且十位等于千位*/&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;this number is a huiwen\\n&quot;);&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;this number is not a huiwen\\n&quot;);&nbsp;&nbsp;getch();}  　　.:.:经典c程序100例==31--40:.:.  　　　　经典c程序100例==31--40【程序31】题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续　　　判断第二个字母。1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;void main(){&nbsp;&nbsp;char letter;&nbsp;&nbsp;printf(&quot;please input the first letter of someday\\n&quot;);&nbsp;&nbsp;while((letter=getch())!=\'Y\')/*当所按字母为Y时才结束*/&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;switch (letter)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'S\':printf(&quot;please input second letter\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((letter=getch())==\'a\')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;saturday\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((letter=getch())==\'u\')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;sunday\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else printf(&quot;data error\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'F\':printf(&quot;friday\\n&quot;);break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'M\':printf(&quot;monday\\n&quot;);break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'T\':printf(&quot;please input second letter\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((letter=getch())==\'u\')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;tuesday\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((letter=getch())==\'h\')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;thursday\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else printf(&quot;data error\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'W\':printf(&quot;wednesday\\n&quot;);break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: printf(&quot;data error\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序32】题目：Press any key to change color, do you want to try it. Please hurry up!1.程序分析：　　　　　　　　　　　　2.程序源代码：#include &quot;conio.h&quot;#include &quot;stdio.h&quot;void main(void){&nbsp;&nbsp;int color;&nbsp;&nbsp;for (color = 0; color &lt; 8; color++)&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;textbackground(color);/*设置文本的背景颜色*/&nbsp;&nbsp;&nbsp;&nbsp;cprintf(&quot;This is color %d\\r\\n&quot;, color);&nbsp;&nbsp;&nbsp;&nbsp;cprintf(&quot;Press any key to continue\\r\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;getch();/*输入字符看不见*/&nbsp;&nbsp;}}==============================================================【程序33】题目：学习gotoxy()与clrscr()函数　　　1.程序分析：2.程序源代码：#include &quot;conio.h&quot;#include &quot;stdio.h&quot;void main(void){&nbsp;&nbsp;clrscr();/*清屏函数*/&nbsp;&nbsp;textbackground(2);&nbsp;&nbsp;gotoxy(1, 5);/*定位函数*/&nbsp;&nbsp;cprintf(&quot;Output at row 5 column 1\\n&quot;);&nbsp;&nbsp;textbackground(3);&nbsp;&nbsp;gotoxy(20, 10);&nbsp;&nbsp;cprintf(&quot;Output at row 10 column 20\\n&quot;);&nbsp;&nbsp;getch();}==============================================================【程序34】题目：练习函数调用1. 程序分析： 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;void hello_world(void){&nbsp;&nbsp;printf(&quot;Hello, world!\\n&quot;);}void three_hellos(void){&nbsp;&nbsp;int counter;&nbsp;&nbsp;for (counter = 1; counter &lt;= 3; counter++)&nbsp;&nbsp;&nbsp;&nbsp;hello_world();/*调用此函数*/}void main(void){&nbsp;&nbsp;three_hellos();/*调用此函数*/&nbsp;&nbsp;getch();}==============================================================【程序35】题目：文本颜色设置1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;void main(void){&nbsp;&nbsp;int color;&nbsp;&nbsp;for (color = 1; color &lt; 16; color++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;textcolor(color);/*设置文本颜色*/&nbsp;&nbsp;&nbsp;&nbsp;cprintf(&quot;This is color %d\\r\\n&quot;, color);&nbsp;&nbsp;}&nbsp;&nbsp;textcolor(128 + 15);&nbsp;&nbsp;cprintf(&quot;This is blinking\\r\\n&quot;);&nbsp;&nbsp;getch();}==============================================================【程序36】题目：求100之内的素数　　　1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;math.h&quot;#define N 101main(){&nbsp;&nbsp;int i,j,line,a[N];&nbsp;&nbsp;for(i=2;i&lt;N;i++) a=i;&nbsp;&nbsp;&nbsp;&nbsp;for(i=2;i&lt;sqrt(N);i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=i+1;j&lt;N;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a!=0&amp;&amp;a[j]!=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a[j]%a==0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;for(i=2,line=0;i&lt;N;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(a!=0)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%5d&quot;,a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if(line==10)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line=0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序37】题目：对10个数进行排序1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，　　　　　　下次类推，即用第二个元素与后8个进行比较，并进行交换。 　　　　　　 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#define N 10main(){&nbsp;&nbsp;int i,j,min,tem,a[N];&nbsp;&nbsp;/*input data*/&nbsp;&nbsp;printf(&quot;please input ten num:\\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;N;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;a[%d]=&quot;,i);&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&amp;a);&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;N;i++)&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%5d&quot;,a);&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;/*sort ten num*/&nbsp;&nbsp;for(i=0;i&lt;N-1;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;min=i;&nbsp;&nbsp;&nbsp;&nbsp;for(j=i+1;j&lt;N;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a[min]&gt;a[j])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min=j;&nbsp;&nbsp;&nbsp;&nbsp;tem=a;&nbsp;&nbsp;&nbsp;&nbsp;a=a[min];&nbsp;&nbsp;&nbsp;&nbsp;a[min]=tem;&nbsp;&nbsp;}&nbsp;&nbsp;/*output data*/&nbsp;&nbsp;printf(&quot;After sorted \\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;N;i++)&nbsp;&nbsp;printf(&quot;%5d&quot;,a);&nbsp;&nbsp;getch();}==============================================================【程序38】题目：求一个3*3矩阵对角线元素之和 1.程序分析：利用双重for循环控制输入二维数组，再将a累加后输出。2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;/* 如果使用的是TC系列编译器则可能需要添加下句 */static void dummyfloat(float *x){ float y; dummyfloat(&amp;y);}main(){&nbsp;&nbsp;float a[3][3],sum=0;&nbsp;&nbsp;int i,j;&nbsp;&nbsp;printf(&quot;please input rectangle element:\\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;3;i++)&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;3;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%f&quot;,&amp;a[j]);&nbsp;&nbsp;for(i=0;i&lt;3;i++)&nbsp;&nbsp;&nbsp;&nbsp;sum=sum+a;&nbsp;&nbsp;printf(&quot;duijiaoxian he is %6.2f&quot;,sum);&nbsp;&nbsp;getch();}==============================================================【程序39】题目：有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。1. 程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后　　　　　此元素之后的数，依次后移一个位置。 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int a[11]={1,4,6,9,13,16,19,28,40,100};&nbsp;&nbsp;int temp1,temp2,number,end,i,j;&nbsp;&nbsp;printf(&quot;original array is:\\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;10;i++)&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%5d&quot;,a);&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;printf(&quot;insert a new number:&quot;);&nbsp;&nbsp;scanf(&quot;%d&quot;,&amp;number);&nbsp;&nbsp;end=a[9];&nbsp;&nbsp;if(number&gt;end)&nbsp;&nbsp;&nbsp;&nbsp;a[10]=number;&nbsp;&nbsp;else&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;10;i++)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a&gt;number)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1=a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=number;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=i+1;j&lt;11;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2=a[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j]=temp1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1=temp2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;for(i=0;i&lt;11;i++)&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%6d&quot;,a);&nbsp;&nbsp;getch();}==============================================================【程序40】题目：将一个数组逆序输出。1.程序分析：用第一个与最后一个交换。2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#define N 5main(){&nbsp;&nbsp;int a[N]={9,6,5,4,1},i,temp;&nbsp;&nbsp;printf(&quot;\\n original array:\\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;N;i++)&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%4d&quot;,a);&nbsp;&nbsp;for(i=0;i&lt;N/2;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;temp=a;&nbsp;&nbsp;&nbsp;&nbsp;a=a[N-i-1];&nbsp;&nbsp;&nbsp;&nbsp;a[N-i-1]=temp;&nbsp;&nbsp;}&nbsp;&nbsp;printf(&quot;\\n sorted array:\\n&quot;);&nbsp;&nbsp;for(i=0;i&lt;N;i++)&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%4d&quot;,a);&nbsp;&nbsp;getch();}  　　.:.:经典c程序100例==41--50:.:.  　　　　经典c程序100例==41--50【程序41】题目：学习static定义静态变量的用法　　　1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;varfunc(){&nbsp;&nbsp;int var=0;&nbsp;&nbsp;static int static_var=0;&nbsp;&nbsp;printf(&quot;\\40:var equal %d \\n&quot;,var);&nbsp;&nbsp;printf(&quot;\\40:static var equal %d \\n&quot;,static_var);&nbsp;&nbsp;printf(&quot;\\n&quot;);&nbsp;&nbsp;var++;&nbsp;&nbsp;static_var++;}void main(){&nbsp;&nbsp;int i;&nbsp;&nbsp;for(i=0;i&lt;3;i++)&nbsp;&nbsp;&nbsp;&nbsp;varfunc();&nbsp;&nbsp;getch();}==============================================================【程序42】 题目：学习使用auto定义变量的用法1.程序分析：　　　　　　2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int i,num;&nbsp;&nbsp;num=2;&nbsp;&nbsp;for(i=0;i&lt;3;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40: The num equal %d \\n&quot;,num);&nbsp;&nbsp;&nbsp;&nbsp;num++;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto int num=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40: The internal block num equal %d \\n&quot;,num);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序43】题目：学习使用static的另一用法。　　　1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;main(){&nbsp;&nbsp;int i,num;&nbsp;&nbsp;num=2;&nbsp;&nbsp;for(i=0;i&lt;3;i++)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40: The num equal %d \\n&quot;,num);&nbsp;&nbsp;&nbsp;&nbsp;num++;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static int num=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40:The internal block num equal %d\\n&quot;,num);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序44】题目：学习使用external的用法。1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;int a,b,c;void add(){&nbsp;&nbsp;int a;&nbsp;&nbsp;a=3;&nbsp;&nbsp;c=a+b;}void main(){&nbsp;&nbsp;a=b=4;&nbsp;&nbsp;add();&nbsp;&nbsp;printf(&quot;The value of c is equal to %d\\n&quot;,c);&nbsp;&nbsp;getch();}==============================================================【程序45】题目：学习使用register定义变量的方法。1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;void main(){&nbsp;&nbsp;register int i;&nbsp;&nbsp;int tmp=0;&nbsp;&nbsp;for(i=1;i&lt;=100;i++)&nbsp;&nbsp;tmp+=i;&nbsp;&nbsp;printf(&quot;The sum is %d\\n&quot;,tmp);&nbsp;&nbsp;getch();}==============================================================【程序46】题目：宏#define命令练习(1)　　　1.程序分析：2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#define TRUE 1#define FALSE 0#define SQ(x) (x)*(x)void main(){&nbsp;&nbsp;int num;&nbsp;&nbsp;int again=1;&nbsp;&nbsp;printf(&quot;\\40: Program will stop if input value less than 50.\\n&quot;);&nbsp;&nbsp;while(again)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40:Please input number==&gt;&quot;);&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&amp;num);&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40:The square for this number is %d \\n&quot;,SQ(num));&nbsp;&nbsp;&nbsp;&nbsp;if(num&gt;=50)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again=TRUE;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again=FALSE;&nbsp;&nbsp;}&nbsp;&nbsp;getch();}==============================================================【程序47】题目：宏#define命令练习(2)1.程序分析：　　　　　　　　　　　　2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;/*宏定义中允许包含两道衣裳命令的情形，此时必须在最右边加上&quot;\\&quot;*/#define exchange(a,b) { \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t;\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=a;\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=b;\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b=t;\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}void main(void){&nbsp;&nbsp;int x=10;&nbsp;&nbsp;int y=20;&nbsp;&nbsp;printf(&quot;x=%d; y=%d\\n&quot;,x,y);&nbsp;&nbsp;exchange(x,y);&nbsp;&nbsp;printf(&quot;x=%d; y=%d\\n&quot;,x,y);&nbsp;&nbsp;getch();}==============================================================【程序48】题目：宏#define命令练习(3)　　　1.程序分析：2.程序源代码：#define LAG &gt;#define SMA &lt;#define EQ ==#include &quot;stdio.h&quot;#include &quot;conio.h&quot;void main(){&nbsp;&nbsp;int i=10;&nbsp;&nbsp;int j=20;&nbsp;&nbsp;if(i LAG j)&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40: %d larger than %d \\n&quot;,i,j);&nbsp;&nbsp;&nbsp;&nbsp;else if(i EQ j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40: %d equal to %d \\n&quot;,i,j);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(i SMA j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40:%d smaller than %d \\n&quot;,i,j);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\40: No such value.\\n&quot;);&nbsp;&nbsp;getch();}==============================================================【程序49】题目：#if #ifdef和#ifndef的综合应用。1. 程序分析： 2.程序源代码：#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#define MAX#define MAXIMUM(x,y) (x&gt;y)?x:y#define MINIMUM(x,y) (x&gt;y)?y:xvoid main(){&nbsp;&nbsp;int a=10,b=20;#ifdef MAX&nbsp;&nbsp;printf(&quot;\\40: The larger one is %d\\n&quot;,MAXIMUM(a,b));#else&nbsp;&nbsp;printf(&quot;\\40: The lower one is %d\\n&quot;,MINIMUM(a,b));#endif#ifndef MIN&nbsp;&nbsp;printf(&quot;\\40: The lower one is %d\\n&quot;,MINIMUM(a,b));#else&nbsp;&nbsp;printf(&quot;\\40: The larger one is %d\\n&quot;,MAXIMUM(a,b));#endif#undef MAX#ifdef MAX&nbsp;&nbsp;printf(&quot;\\40: The larger one is %d\\n&quot;,MAXIMUM(a,b));#else&nbsp;&nbsp;printf(&quot;\\40: The lower one is %d\\n&quot;,MINIMUM(a,b));#endif#define MIN#ifndef MIN&nbsp;&nbsp;printf(&quot;\\40: The lower one is %d\\n&quot;,MINIMUM(a,b));#else&nbsp;&nbsp;printf(&quot;\\40: The larger one is %d\\n&quot;,MAXIMUM(a,b));#endif&nbsp;&nbsp;getch();}============================================================== \n\n        ', null);
INSERT INTO `blog` VALUES ('91', 'Win7时代你不得不会的东东~', '\n            \n \n\n一、Windows键 + 空格键“Space”[作用]：透明化所有窗口，快速查看桌面(并不切换) [快捷键]：win+空格 [小结]：当你打开了很多程序窗口的时候，这招非常有用，而且桌面还会有华丽的光影效果哦。没用过的赶紧试试先 二、Windows键 + D [作用]：最小化所有窗口，并切换到桌面，再次按又重新打开刚才的所有窗口 [快捷键]：win+d [小结]：这个功能在以前的系统里是都有的，只不过win7的显示桌面放到了任务栏的右下角了(就是最右边的那个长方形小条) 三、Windows键 + tab键 [作用]：传说中的3D桌面展示效果 [快捷键]：win+tab [小结]：记得本区应该有一个帖就是关于这个效果的，不过感觉这招最简单了 四、Windows键 + ctrl键+tab键 [作用]：3D桌面浏览并锁定(可截屏) [快捷键]：win+ctrl+tab [小结]：见识了它的效果想留个图，win+tab是办不到di，win7说了 -- I can! 五、Windows键 + 数字键 [作用]：针对固定在快速启动栏中的程序，按照数字排序打开相应程序 [快捷键]：win+数字(1-9) [小结]：吼吼，这个功能爽吧 六、Windows键 + P[作用]：打开“外接显示”的设置窗口 [快捷键]：win+p[小结]：办公室一族，对这个功能肯定不会陌生吧。对了，接投影仪快速切换，嘿嘿。 七、Windows键 + X[作用]：打开“移动中心”设置窗口 [快捷键]：win+x[小结]：设置窗口里包括显示器亮度控制、音量控制、笔记本电池监控、Mobile手机同步设置、外接显示器管理...等多种功能 八、修复系统默认文件关联 [作用]：修复系统默认文件关联 [快捷键]：无 [小结]：当我们无意中破坏了系统默认的文件关联，这招就派上用场了。win7下可不像winxp那样容易修改文件关联的，不信？试试 *_* [操作方法]：开始-&gt;cmd，按如下格式输入assoc.XXX=XXXfile XXX代表文件类型，比如修复TXT和BAT的文件关联，命令就是assoc.TXT=TXTfile 和 assoc.BAT=BATfile 九、关闭系统休眠功能 [作用]：关闭系统休眠功能 [快捷键]：无 [小结]： windows7下的休眠功能需要硬件和操作系统的功能支持，目前该功能出现多种问题，建议在正式版出来之前先关闭它，而且还可以为系统盘节省大量磁盘空间(大约4G)。 [操作方法]：开始-&gt;cmd，输入powercfg -h off，回车 解决WIN7无法识别的网络方法 &nbsp;&nbsp;&nbsp;&nbsp;安装win7应经两个星期了，每次开机都会出现两个网络连接，一个家庭网络，一个未识别的网络，但是我的电脑只装了一个网卡，所以每次开机后总是首先禁用一下网卡在启用才能上网，那么怎么才能把那个开机启动的未识别的网络禁用呢。。下面进入正题。&nbsp;&nbsp; 出现未识别的网络是因为win7有一个DNSresponder.exe的开机启动进程，这是安装adobe ps3&nbsp;&nbsp;后的Bonjour.exe在作怪，这是一个搜寻局域网的进程，此文件夹在X:\\program Files\\下，有一个Bonjour的文件夹。首先用360软件管家，再点高级工具，找到DNSresponder.EXE进程，点结束进程，然后回到文件夹，把文件夹里面的mdnsNSP.dll重命名为mdnsNSP.txt。然后重启电脑，找到Bonjour文件夹，直接删除，重启电脑，看一下是不是就一个网络连接了。。希望能对大家有所帮助。。 双系统完全卸载Windows 7的方法 目前window 7 逐渐代替我们现在电脑系统，在window 7的步入之际，你是否觉得还不适应，是否还在window 7和window XP 之间徘徊，为了解决这个问题，很多朋友都是装了双系统（window 7和window xp）本人就是这样，本人把window xp装在C盘，window 7装在了D盘，在厌倦了window xp的时候，可以登录window 7系统来体验。但是有的朋友不习惯，想删除window 7的时候，就不知道怎么弄了，这里就介绍给大家一个方法。 &nbsp;&nbsp;&nbsp;&nbsp;想要完全卸载Windows 7，需要先处理双系统的引导启动菜单，在去掉了双系统共享使用的启动管理器之后，才能正常格式化Windows 7所在的分区。方法如下：　　首先，启动到xp系统，在电脑光驱中放入Windows 7的安装光盘（若是下载的ISO镜象文件，可以用虚拟光驱Deamon tools或者Virtual Drive Manager读取并加载Windows 7的光盘镜像到虚拟光驱中。　　其次，依次点击“开始菜单/运行”，弹出命令行窗口。在命令行窗口中输入A:\\boot\\bootsect.exe /nt52 all /force，然后敲回车键运行，需要注意的是，A是本例中放入Windows 7安装光盘的盘符，读者需要根据自己放入Windows 7光盘的盘符，将A改为自己的盘符。　　再次，弹出Windows 7安装光盘；接下来，再重启计算机，我们就可以发现双系统的启动菜单Windows 7系统启动项和early version Windows 选项消失了，直接进入xp系统，这表明双系统引导启动菜单已经删除完成。　　最后，在重启后的xp系统中，现在可以手动删除Windows 7文件和文件夹了，如程序文件，用户和Windows 文件夹。如果没有其它重要文件，直接格式化Windows 7所在的分区最省事的。就在XP下将Windows 7卸载得干干净净。 Windows 7系统服务清理手动优化方案 目前已经有不少配置不是很高的电脑用户正式用上了Windows7，如何让低配置电脑可以更流畅的运行Windows7呢？虽然部分软件提供了傻瓜化的优化处理方法，但这些优化往往让用户摸不到头脑，更不知道是否真实有效。本文教大家手动优化Windows7，而对象则是最容易被忽视的系统服务。 　　我们首先了解系统服务的一些相关知识，然后再根据Windows7用户的各种不同需求提供有针对性Windows7系统服务清理方案，提高WIndows7的运行速度。 　　什么是服务？ 　　服务是系统用以执行指定系统功能的程序或进程，其功用是支持其他应用程序，一般在后台运行。与用户运行的程序相比，服务不会出现程序窗口或对话框，只有在任务管理器中才能观察到它们的身影。 　　如何修改服务的启动类型？ 　　在Win 7开始菜单的“搜索程序和文件”栏里输入“services.msc”或“服务”，即可搜索到“服务”项，点击之后就可以打开服务管理列表窗口。双击任意一个服务即可查看或修改它的属性，在属性窗口中就可以修改启动类型为“手动”、“自动”、“自动(延时启动)”或“禁用”。 　　“自动”和“自动(延时启动)”有什么不同？ 　　“自动”启动是指电脑启动时同时加载该服务项，以便支持其他在此服务基础上运行的程序。而“自动(延时启动)”则是Windows7当中非常人性化的一个设计。采用这种方式启动，可以在系统启动一段时间后延迟启动该服务项，可以很好地解决一些低配置电脑因为加载服务项过多导致电脑启动缓慢或启动后响应慢的问题。 　　“手动”和“禁用”有什么不同？ 　　服务启动状态为“手动”的情况下，该进程虽然关闭，但依然可以在特定情况下被激活，而设置为“禁用”后，除非用户手动修改属性，否则服务将无法运行。 　　哪些服务需要手动启动？ 　　“手动”模式,顾名思义就是这种服务不会随着系统的启动而加载，而需要其他服务激活或者由用户进入服务管理界面后，手动启动它或者修改其属性为“自动”启动。 　　这种模式常用在需要开启一些系统原本没有开启的功能时。以“Application Identity”服务为例，默认状态下该服务为“手动”状态，即没有启动。但是当用户需要使用AppLocker功能时，就必须手动启用这一服务(修改为“自动”状态)，否则AppLocker功能将无法正常工作。 　　修改前我应该注意些什么？ 　　修改系统服务可能会造成一些意想不到的问题，所以修改前最好将默认的服务状态进行备份。方法为打开服务管理窗口后依次点击“操作→导出列表”，选择“保存类型”为TXT文本文件或CSV文件，建议选择后者，该文件可用Excel打开。 　　此外，如果出现因为修改错误导致无法正常进入系统的情况，可以在开机时按F8键选择进入安全模式，在安全模式中修改服务启动属性。 用Windows 7库功能管理临时文件有很多网络应用类程序，为了加快用户再次访问的速度，会将以前访问过的部分缓存保存到硬盘中，如IE的网页缓存、QQ的表情和接收图片、Picasa的图片缩略图索引文件。此类临时文件非常有用，不妨保留并统一管理，效率更高。 ◎ 用库集中管理临时文件 程序不同，临时文件默认的保存路径也不同，这无疑为我们统一管理带来了难度。若经常要管理临时文件，查看文件的大小或者批量清理很繁琐。其实可以用Windows 7的库来统一管理。 首先，添加Windows 7临时文件库。在资源管理器左侧右击“库”，在弹出的右键菜单中，选择“新建/库”，新建一个名为“临时文件”的库。 其次，让隐藏的系统文件显示出来。“属性”为“系统/隐藏”或“隐藏”的文件，需要在Windows 7资源管理器的工具栏中，单击“组织/文件夹和搜索选项”，打开相应的对话框，切换到“查看”标签，在列表中，取消对“隐藏受保护的操作系统文件”项的勾选，同时选择“显示隐藏的文件、文件夹和驱动器”项，单击“确定”按钮就可以看到。 最后，添加临时文件到库中。右击需要添加的临时文件夹，在弹出的右键菜单中，选择“包含到库中/临时文件”，将其添加到库中。 以后通过库，就能方便地进行查看和删除等操作了。可以通过Windows 7的搜索功能，搜索指定的文件然后批量删除。 属性为“系统/隐藏”的临时文件，如IE临时文件夹“Temporary Internet Files”，用上面的方法无法添加到库中，可以将其上级目录“Windows”添加到库中，以达到统一管理目的。 实用技巧:如何解决winXP/Win7文件不能互访如何解决XP/Win7文件不能互访，而不是一个“唯一确定的解决办法”。很多时候，一个看上去无关的系统默认设置，很可能就会造成系统之间无法正常访问，因此，谁都无法凭空造出一个完美解决方案。 对于这个的问题，一直认为没有唯一确定的解决方法，也就是说，在遇到具体的情况时才能找到具体的解决办法。但实际上，我们也可以总结出一个大概的解决思路，然后在根据大概的思路，具体问题具体对待。 在Winodws XP和Windows 7之间出现文件共享或互访的障碍时（包括局域网内互访和双机互联的情况），我们可以从以下几个方面入手。 1．防火墙是否关闭 如果在Windows 7和Windows XP之间无法看到对方，首先请坚持二者的防火墙是否关闭。 关闭Windows 7防火墙 在关闭Windows 7和Windows XP的系统防火墙后，你要注意是否安装了第三方防火墙。如果已安装，请关闭。 XP系统的电脑无法访问Windows7的共享文件夹，有些虽然能看到Windows7下的共享目录，但是一旦进入目录，就会提示没有访问权限。 2．开启Guest账户 直到现在，也没有一个比较合理的解释来说明，为什么不开启Guest账户会影响到Windows系统之间的互访。这一情况在解决Windows 98和Windows XP之间已经是不止一次的得到印证。因此，在Windows XP和Windows 7之间的互访，也需要开启Guest账户。 开启Windows 7的来宾账户 同样的，你还需要在Windows XP系统中，也开启Guest来宾账户。 3．文件和打印机共享 当用户将防火墙关闭，来宾帐户也已经开启，但仍然无法实现互访时，用户需要分别开启Windows XP和Windows 7防火墙下的“文件和打印机共享”。 开启Windows XP防火墙下的文件和打印机共享 特别提醒一句，如果你是通过远程共享的方式进行的访问，还应该找到远程服务有关的项，并分别将他们开启。 4．用户权限 在Windows 7系统中，出于系统安全的考虑，微软赋予了管理员帐户更高的安全权限。但这种“高权限”设置，在系统互访时会造成更多的访问障碍。通常情况下，由于Windows 7系统对于系统访问“警惕性较高”，因此，如果遇到系统提示权限不够时，你需要赋予访问者更高权限。 小知识：Windows 7系统中的安全账户权限 包括一些Windows 7用户在内，很多人都认为Administrator帐户是系统内最高权限的拥有者，其实并非如此。微软在Windows 7中还设置了一个隐藏账户，它具有更高的权限。 回到刚才的话题，由于对方是网络访问，你在局域网中很可能因为无法为具体的访问账户提升权限，因此，你就需要降低被访问的文件（夹）的权限，也就是说，间接赋予访问者“完全控制权限”。 　 降低被访问文件夹的权限Windows 7 特别提示： 如果用户按照上述方法设置后，访问者依然无法访问共享文件，建议大家在“123属性”文件夹中，切换到“安全”标签，然后给文件夹添加访问用户的完全控制权限。 5．安全软件或系统辅助软件 在Windows XP时代，鼎鼎有名的系统辅助类软件，莫过于Windows优化大师，已经超级兔子魔法设置。在Windows 7平台下，此类软件依然有部分用户在使用。此类软件也是出于系统安全的考虑，一般会关闭系统远程访问，或是文件夹共享等。如果你安装了此类软件，那就需要查看它们的程序设置，是否关闭了共享和远程服务等。 此外，在一些杀毒软件中，它们也会对远程服务和访问予以限制，你同样需要解除限制。 Windows 7最全的硬盘安装方法！还不知道怎么安装系统的进当然，网上下载的系统都是ISO的，有条件的朋友可以刻录成光盘进行安装！没条件的朋友就认真学习下硬盘安装吧!会安装的自动OUT！（内容转载）一、windows 7系统下全新安装高版Windows7：1、下载windows7 7100 ISO镜像(RC或RTM)，用虚拟光驱拷贝至非C盘(如D:\\7100) 2、开机按F8——修复系统——选择最后一项命令修复——在命令框输入“D:\\7100\\sources\\setup.exe“(不带引号) 3、进入安装界面、选择custom安装 4、选择安装语言、格式化C盘 5、OK了，装好后是一个纯系统(非双系统)。二、如果有vista安装盘的话，方法也很简单：1、下载windows7 7100 ISO镜像(RC或RTM)，用虚拟光驱拷贝至非C盘(如D:\\7100) 2、BIOS中选择光驱启动，进入vista安装界面 3、选择左下角修复计算机(自动搜索系统，提示加载驱动或关闭，选择关闭进入修复选项) 4、选择最后一项命令修复，在命令框输入“D:\\7100\\sources\\setup.exe“(不带引号)，开始安装 5、选择安装语言、格式化C盘 (即使C盘原本没有系统此法也可行)三、XP系统下全新安装windows 7：1、下载windows 7 7100 ISO镜像(RC或RTM)，用虚拟光驱拷贝至非C盘(如D:\\7100) 2、把D:\\7100目录下的bootmgr和boot目录(其实只要里面的boot.sdi和bcd文件)拷贝到c盘根目录下,并在C盘根目录下建个sources文件夹。(XP下不需要取得管理员权限) 3、把D:\\7100\\sources下的boot.win复制到C盘刚建的sources文件夹 4、用管理员身份运行cmd，然后输入c:\\boot\\bootsect.exe/nt60 c: 提示successful(即成功了!) 5、关闭cmd窗口重启计算机，自动进入安装界面，选择安装语言，同时选择适合自己的时间和货币显示种类及键盘和输入方式 6、出现“开始安装界面”，(要注意了，不点击“现在安装”)点左下角“修复计算机”(repair mycomputer)，进入&quot;系统恢复选择&quot;，选择最后一项&quot;命令提示符&quot;(commandprompt)，进入DOS窗口 7、输入“D:\\7100\\sources\\setup.exe“(不带引号)，开始安装 8、选择安装语言、格式化C盘，就OK了 四、vista系统下全新安装windows7(实践证明XP用此种方法也更加方便)：1、下载windows 7 7100 ISO镜像(RC或RTM)，用虚拟光驱拷贝至非C盘(如D:\\7100) 2、复制D:\\7100文件夹中的Boot、EFI、sources文件夹和bootmgr至C盘根目录下 。（需取得管理员权限）3、复制D:\\7100\\boot下Bootsect.exe至C盘根目录下 4、管理员身份运行cmd，输入c:\\bootsect.exe/nt60 c:并回车(最好复制，中间有空格) 5、重启系统自动进入安装界面，点左下角的修复计算机repair my computer) 6、选择最后一项命令提示符，进入DOS窗口，输入D:\\7100\\sources\\setup.exe进入安装界面 7、选择安装语言、格式化C盘，就OK了。\n\n        ', null);
INSERT INTO `blog` VALUES ('92', '学电脑，就得知道电脑每个键的用处，不知道请看', '\n            \n \n\n &nbsp;\nF1帮助 F2改名 F3搜索 F4地址 F5刷新 F6切换 F10菜单 CTRL+A全选&nbsp;&nbsp;&nbsp;&nbsp; CTRL+C复制&nbsp;&nbsp;&nbsp;&nbsp; CTRL+X剪切&nbsp;&nbsp;&nbsp;&nbsp; CTRL+V粘贴 CTRL+Z撤消&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CTRL+O打开 SHIFT+DELETE永久删除 DELETE删除 ALT+ENTER属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALT+F4关闭 CTRL+F4关闭 ALT+TAB切换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALT+ESC切换 ALT+空格键窗口菜单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CTRL+ESC开始菜单 拖动某一项时按CTRL复制所选项目 拖动某一项时按CTRL+SHIFT创建快捷方式 将光盘插入到CD-ROM驱动器时按SHIFT键阻止光盘自动播放 Ctrl+1,2,3...　切换到从左边数起第1,2,3...个标签 Ctrl+A　全部选中当前页面内容 Ctrl+C　复制当前选中内容 Ctrl+D　打开“添加收藏”面版(把当前页面添加到收藏夹中) Ctrl+E　打开或关闭“搜索”侧边栏(各种搜索引擎可选) Ctrl+F　打开“查找”面版 Ctrl+G　打开或关闭“简易收集”面板 Ctrl+H　打开“历史”侧边栏 Ctrl+I　打开“收藏夹”侧边栏/另:将所有垂直平铺或水平平铺或层叠的窗口恢复 Ctrl+K　关闭除当前和锁定标签外的所有标签 Ctrl+L　打开“打开”面版(可以在当前页面打开Iternet地址或其他文件...) Ctrl+N　新建一个空白窗口(可更改,Maxthon选项→标签→新建) Ctrl+O　打开“打开”面版(可以在当前页面打开Iternet地址或其他文件...) Ctrl+P　打开“打印”面板(可以打印网页,图片什么的...) Ctrl+Q　打开“添加到过滤列表”面板(将当前页面地址发送到过滤列表) Ctrl+R　刷新当前页面 Ctrl+S　打开“保存网页”面板(可以将当前页面所有内容保存下来) Ctrl+T　垂直平铺所有窗口 Ctrl+V　粘贴当前剪贴板内的内容 Ctrl+W　关闭当前标签(窗口) Ctrl+X　剪切当前选中内容(一般只用于文本操作) Ctrl+Y　重做刚才动作(一般只用于文本操作) Ctrl+Z　撤消刚才动作(一般只用于文本操作) Ctrl+F4　关闭当前标签(窗口) Ctrl+F5　刷新当前页面 Ctrl+F6　按页面打开的先后时间顺序向前切换标签(窗口) Ctrl+F11　隐藏或显示菜单栏 Ctrl+Tab　以小菜单方式向下切换标签(窗口) \n&nbsp;\n\nCtrl+Enter　域名自动完成http://www.XXX.com(内容可更改,Maxthon选项→地址栏→常规)/另:当输入焦点在搜索栏中时,为高亮关键字 Ctrl+拖曳　保存该链接的地址或已选中的文本或指定的图片到一个文件夹中(保存目录可更改,Maxthon选项→保存) Ctrl+小键盘\'+\'　当前页面放大20% Ctrl+小键盘\'-\'　当前页面缩小20% Ctrl+小键盘\'*\'　恢复当前页面的缩放为原始大小 Ctrl+Alt+S　自动保存当前页面所有内容到指定文件夹(保存路径可更改,Maxthon选项→保存) Ctrl+Shift+小键盘\'+\'　所有页面放大20% Ctrl+Shift+小键盘\'-\'　所有页面缩小20% Ctrl+Shift+F　输入焦点移到搜索栏 Ctrl+Shift+G　关闭“简易收集”面板 Ctrl+Shift+H　打开并激活到你设置的主页 Ctrl+Shift+N　在新窗口中打开剪贴板中的地址,如果剪贴板中为文字,则调用搜索引擎搜索该文字(搜索引擎可选择,Maxthon选项→搜索) Ctrl+Shift+S　打开“保存网页”面板(可以将当前页面所有内容保存下来,等同于Ctrl+S)　 Ctrl+Shift+W　关闭除锁定标签外的全部标签(窗口) Ctrl+Shift+F6　按页面打开的先后时间顺序向后切换标签(窗口) Ctrl+Shift+Tab　以小菜单方式向上切换标签(窗口) Ctrl+Shift+Enter　域名自动完成Alt+1　保存当前表单 Alt+2　保存为通用表单 Alt+A　展开收藏夹列表 资源管理器 END显示当前窗口的底端 HOME显示当前窗口的顶端 NUMLOCK+数字键盘的减号(-)折叠所选的文件夹 NUMLOCK+数字键盘的加号(+)显示所选文件夹的内容 NUMLOCK+数字键盘的星号(*)显示所选文件夹的所有子文件夹 向左键当前所选项处于展开状态时折叠该项，或选定其父文件夹 向右键当前所选项处于折叠状态时展开该项，或选定第一个子文件夹 自然键盘 【窗口】显示或隐藏“开始”菜单 【窗口】+F1帮助 【窗口】+D显示桌面 【窗口】+R打开“运行” 【窗口】+E打开“我的电脑” 【窗口】+F搜索文件或文件夹 【窗口】+U打开“工具管理器” 【窗口】+BREAK显示“系统属性” 【窗口】+TAB在打开的项目之间切换 辅助功能 按右边的SHIFT键八秒钟切换筛选键的开和关 按SHIFT五次切换粘滞键的开和关 按NUMLOCK五秒钟切换切换键的开和关 左边的ALT+左边的SHIFT+NUMLOCK切换鼠标键的开和关 左边的ALT+左边的SHIFT+PRINTSCREEN切换高对比度的开和关 运行\n\n&nbsp;按“开始”－“运行”，或按WIN键+R，在『运行』窗口中输入： （按英文字符顺序排列） %temp%---------打开临时文件夹 .--------------C:\\DocumentsandSettings\\用户名所在文件夹 ..-------------C:\\DocumentsandSettings ...------------我的电脑 \\--------------C盘 appwize.cpl----添加、删除程序 access.cpl-----辅助功能选项 Accwiz---------辅助功能向导 cmd------------CMD命令提示符 command--------CMD命令提示符 chkdsk.exe-----Chkdsk磁盘检查 certmgr.msc----证书管理实用程序 calc-----------启动计算器 charmap--------启动字符映射表 cintsetp-------仓颉拼音输入法 cliconfg-------SQLSERVER客户端网络实用程序 clipbrd--------剪贴板查看器 control--------打开控制面板 conf-----------启动netmeeting compmgmt.msc---计算机管理 cleanmgr-------垃圾整理 ciadv.msc------索引服务程序 dcomcnfg-------打开系统组件服务 ddeshare-------打开DDE共享设置 dxdiag---------检查DirectX信息 drwtsn32-------系统医生 devmgmt.msc----设备管理器 desk.cpl-------显示属性 dfrg.msc-------磁盘碎片整理程序 diskmgmt.msc---磁盘管理实用程序 dvdplay--------DVD播放器 eventvwr-------事件查看器 eudcedit-------造字程序 explorer-------打开资源管理器 fsmgmt.msc-----共享文件夹管理器 firewall.cpl---WINDOWS防火墙 gpedit.msc-----组策略 hdwwiz.cpl-----添加硬件 iexpress-------木马捆绑工具，系统自带 inetcpl.cpl----INTETNET选项 intl.cpl-------区域和语言选项（输入法选项） irprops.cpl----无线链接 joy.cpl--------游戏控制器 lusrmgr.msc----本机用户和组 logoff---------注销命令 main.cpl-------鼠标 mem.exe--------显示内存使用情况 migwiz---------文件转移向导 mlcfg32.cpl----邮件 mplayer2-------简易widnowsmediaplayer mspaint--------画图板 msconfig.exe---系统配置实用程序 mstsc----------远程桌面连接 magnify--------放大镜实用程序 mmc------------打开控制台 mmsys.cpl------声音和音频设备 mobsync--------同步命令 ncpa.cpl-------网络连接 nslookup-------IP地址侦测器 netstartX----开始X服务 netstopX-----停止X服务 netstat-an----命令检查接口 netsetup.cpl---无线网络安装向导 notepad--------打开记事本 nslookup-------IP地址侦探器 narrator-------屏幕“讲述人” ntbackup-------系统备份和还原 ntmsmgr.msc----移动存储管理器 ntmsoprq.msc---移动存储管理员操作请求 nusrmgr.cpl----用户账户 nwc.cpl--------NetWare客户服务 osk------------打开屏幕键盘 odbcad32-------ODBC数据源管理器 odbccp32.cpl---ODBC数据源管理器 oobe/msoobe/a-检查XP是否激活 packager-------对象包装程序 perfmon.msc----计算机性能监测程序 powercfg.cpl---电源选项 progman--------程序管理器 regedit--------注册表 rsop.msc-------组策略结果集 regedt32-------注册表编辑器 regsvr32/?----调用、卸载DLL文件运行（详细请在cmd中输入regsvr32/?）\n&nbsp;\n&nbsp;sapi.cpl-------语音 services.msc---本地服务设置 syncapp--------创建一个公文包 sysedit--------系统配置编辑器 sigverif-------文件签名验证程序 sndrec32-------录音机 sndvol32-------音量控制程序 shrpubw--------共享文件夹设置工具 secpol.msc-----本地安全策略 sysdm.cpl------系统 syskey---------系统加密（一旦加密就不能解开，保护windowsxp系统的双重密码） services.msc---本地服务设置 sfc.exe--------系统文件检查器 sfc/scannow---windows文件保护 shutdown-------关机命令（详细请在cmd中输入shutdown/?） taskmgr--------任务管理器 telephon.cpl---电话和调制解调器选项 telnet---------远程连接程序 timedate.cpl---日期和时间 tourstart------xp简介（安装完成后出现的漫游xp程序） tsshutdn-------60秒倒计时关机命令 utilman--------辅助工具管理器 winver---------检查Windows版本 winmsd---------系统信息 wiaacmgr-------扫描仪和照相机向导 winchat--------XP自带局域网聊天 wmimgmt.msc----打开windows管理体系结构(WMI) wordpad--------写字板 wuaucpl.cpl----自动更新 wupdmgr--------windows更新程序 write----------写字板 wscript--------windows脚本宿主设置 wscui.cpl------安全中心 C:/windows/fonts字体 \n&nbsp;\n\n\n        ', null);
INSERT INTO `blog` VALUES ('93', '关于U盘', '\n            \n \n\nU盘必备的5个软件  &nbsp; 相信在座的好多朋友，手中都拥有不止一个的U盘了。那么，除了存储文件，您的这些U盘还能做什么用呢？恐怕这也正是好多朋友经常思考的一个问题吧。那么今天，笔者就给您介绍几款小软件，让它们来帮助您“玩转”手里的U盘吧。\n\n　　一、 将U盘改造为“DOS启动盘”\n\n　　相信从Win98时代走过来的朋友们，大多听说过大名鼎鼎的Ghost软件吧。其实，这款软件最为神奇之处，就是能够完整地将当前系统备份下来，此后，无论是感染病毒还是系统崩溃，只需敲入几个命令，几分钟之内系统便能恢复正常，方便极了。只不过，由于Ghost软件必须工作在纯DOS环境中，在没有纯DOS的WinXP系统中，已经越来越不方便使用了。\n\n　　其实，目前的好多主板都支持U盘启动，只要能将一部U盘改造为系统启动盘，那么就可以通过U盘启动到纯DOS环境，进而轻松地使用Ghost进行系统恢复了。\n\n\n 软件名称：\nUSBoot 软件大小：\n595KB 软件授权：\n免费 下载地址：\n\n点击这里下载\n\n　　改造步骤：　　1. 插入U盘，启动USBoot软件，在主界面中选取U盘图标，如图1所示。　　2. 点击“点击此处选择工作模式”字样来选择一种启动盘工作模式，然后点击“开始”按钮，如图2所示。　　&nbsp;&nbsp; 　【小提示】 对于U盘而言，我们一般可以选择“ZIP模式”或者“FDD模式”，两者从理论上讲并没有多少区别。只不过，它们两者的兼容性略有不同，比如某些主板能支持“ZIP模式”启动，而有些主板只能支持“FDD模式”启动。因此，如果在某一模式下制作的U盘无法启动系统时，换用另外一种模式也许就能轻松解决。　　3. 最后，再根据USBoot的提示一步步做下去，这时的U盘便可以直接启动到纯DOS环境中了，如图3所示。　　 二、 将U盘改造为“开机钥匙盘”　　在办公室中，我们经常会看到一些不自觉的同事。当别人有事出去后，就跑到人家的电脑上翻来翻去。如果电脑中保存的都是些大众化的资料倒也无所谓，可万一存储的都是些机密文件或者个人隐私的话，就难免会有泄密的可能了。其实，完全可以将手中的U盘改造为一个“开机钥匙盘”。只有当U盘插入时，电脑才能正常工作，而一旦有事外出，只需拔下U盘，Windows便会自动锁定电脑。\n 软件名称：\nU盘文件管理专家 软件大小：\n2.56MB 软件授权：\n共享 下载地址：\n\n点击这里下载\n\n　　改造步骤：　　1. 启动“U盘专家”安装程序，确定好U盘的盘符，将软件安装到U盘上，如图4所示。　　　　2. 然后，在弹出的对话框中设置一个管理密码，完成“U盘专家”的安装。　　3. 右击任务栏处“U盘专家”图标，执行“启动主机锁护”命令，输入密码来启动“U盘锁”功能。　　4. 然后，将电脑的锁定终止时间设置为最长的“72小时”，并输入解锁密码，点击“启动”即可，如图5所示。　　　　【小提示】 在这里，先解释一下锁定终止时间的含义。当启动“U盘锁”功能后，锁定状态一般只会保持一段时间，如果超过这个时间，电脑将会自动解锁。所以，这也就是笔者选择“72小时”的原因之一，当然是保护的时间越长越好了。不过，之所以选择“72”小时，其实还有另外一个考虑。那就是在“U盘专家”的设计中，当用户选择的“锁定终止”时间超过了24小时之后，那么不但可以通过钥匙盘解锁，而且还能直接使用密码进行解锁，这样的话，使用起来就更加方便了。　　5. 此时，如果拔下U盘，那么电脑将立即进入锁定状态。而且，即使是强行重开机，锁定状态也会自动运行，安全性相当不错，如图6所示便是电脑进入锁定状态时的画面（全屏）。　　　　三、 将U盘改造为“加密保险箱”　　　　以前，经常听到某款U盘具有加密存储功能，某款U盘安全级别高这样的宣传。应该说，这类产品对于数据安全性要求较高的商务人员来说还是非常合适的。只不过，往往这功能一提升，价格方面就不会太让“心甜”了。其实，加密功能并非只有它们这些“专用”U盘才能享受，在下面这款小软件的帮助下，也能将自己的U盘改造为一个“加密保险箱”。\n 软件名称：\nU易U盘加密软件 软件大小：\n772KB 软件授权：\n免费 下载地址：\n\n点击这里下载\n\n　　　改造步骤：　　1. 首先，将“加密精灵”拷贝到U盘中执行，弹出操作主界面。　　2. 然后，根据下图中所标识的顺序启动加密功能，并点击“使配置生效”按钮予以确认，如图7所示。　　\n　　4. 最后，设置好加密区密码之后，U盘加密即告完成。此时，在加密精灵的主界面中点击“登录”按钮，并输入加密区密码即可看到隐藏分区。而这时，加密区图标也会同时显示在我的电脑中，如图8所示。　　　　5. 由于这个新划分的加密区能够完全支持文件的复制与删除，而且在操作习惯上也与普通U盘没有任何区别，所以上手是非常容易的。而当点击了“登出”按钮之后，加密区即自动关闭，如果没有密码是根本无法打开其中的文件的。下次，只要一启动加密精灵软件，并输入好正确的密码，加密区的文件便又会展现在面前了。　　【小提示】 使用加密分区功能时，切记千万不要对U盘直接插拔，因为这样的操作很容易造成加密区中的数据丢失。　　　　四、 将U盘改造为“随身文件柜”　　现在的U盘容量可是越来越大了，想不想把您的U盘也改造为一个“随身文件柜”？无论您走到哪里，只要将U盘插入到电脑中，便能轻松地阅读到自己的邮件和文档了。而且，由于所有的操作全部运行在U盘之上，所以拔下之后也不会在寄主电脑中留下任何痕迹，回到办公室还能与自己的电脑同步数据。其实，这些想法并不难实现，在一款名为“U盘文件管理专家”的软件帮助下，便能轻松地将这些想法变为现实。\n 软件名称：\nU盘文件管理专家 软件大小：\n2.56MB 软件授权：\n共享 下载地址：\n\n点击这里下载\n\n　　改造步骤：（由于该软件的安装上文已有介绍，本段将略过）　　　　1. 将电脑中的数据同步到U盘上　　将自己电脑中的数据同步到U盘，其实是很简单的。只要在“U盘专家”的主界面中点击“同步中心”按钮，然后再设定一下同步的方向就行了（图中显示的方向为：电脑 → U盘）。最后，点击“执行”按钮即可完成文件的同步，如图10所示。　　　　2. 在其他电脑中使用U盘　　同步完成的U盘便可以在其他的电脑上方便地使用了。只要双击U盘中的“USBNB”图标，然后输入权限密码（安装本软件时所设），就能看到一个如图9所示的主界面。点击上面的按钮便可以直接启动相应的功能，像下图便是点击了“移动版电子邮件”按钮之后所打开的界面，其中显示的正是原电脑中的邮件内容，如图11所示。\n　　3. 将拷贝到U盘的资料同步回电脑　　当然，既然工作嘛，肯定会在U盘上生成不少新的文件，而回到办公室，最先要干的便是将这些新文件复制回电脑。其实，同样是利用刚才介绍的那个“同步中心”按钮，也能很方便地将U盘上的文件复制回电脑。由于整个操作与步骤1完全一致，所以本文在此不再赘述，只要大家记着将“同步方向”再改回“U盘 → 电脑”便可以了。　　　　五、 将U盘改造为“随身小电脑”　　虽然上面介绍的“U盘文件管理专家”，能够很轻松地在别人电脑中查看自己的文件，但它终究只能对文件起作用，要想在别人的电脑中使用一些自己的特定程序，恐怕就得请另一位“随身专家” —— Ceedo大显身手了。\n 软件名称：\nCeedo 软件大小：\n2.03MB 软件授权：\n共享 下载地址：\n\n点击这里下载\n\n　　　　改造步骤：　　1. 双击安装文件，将Ceedo软件安装到U盘上。这样，以后只要一插入U盘，Ceedo便开始自动运行了，如图12所示。　　　　2. 在Ceedo上面安装软件是非常容易的，只要点击“全部程序”菜单下的“添加程序”命令，一个Ceedo的专用下载页面便弹了出来。然后，根据上面的提示，选好软件后便能一步步将它安装到Ceedo上了，如图13所示。　　　　【小提示】 Ceedo网站上所提供的大多是精简版的英文软件，并不符合使用习惯。其实，只要您的U盘有足够的空闲空间，大多数台式电脑程序也能被安装到Ceedo中。只不过，安装程序的运行必须要在Ceedo自己的资源管理器中进行才可，如图14所示。　　　　3. 和标准的Windows一样，安装完成的软件可以直接在“全部程序”菜单中找到，而执行也只是点击一下就可以了，非常方便，如图15所示。　　　　4. 至于程序的删除也很简单，因为同“添加程序”一样，在“全部程序”菜单下面还包含着一个“移除程序”命令，而具体的删除操作由于比较简单，本文在此也就不再赘述了。　　 写在最后　　怎么样？没想到您的U盘还有这些多玩法吧。其实，鉴于文章的篇幅有限，好多小功能没有来得及给大家介绍呢。有兴趣的朋友不妨再到网上再搜一搜，希望您能够再次“开发”出U盘的新潜力，让它更好地工作。\n\n        ', null);
INSERT INTO `blog` VALUES ('94', '解除电脑开机密码', '\n            \n \n\n教你怎样解除电脑开机密码！！！先记下来，以后总会有用到的！！！此方法仅供计算机教师交流，严禁作为非法手段使用！方法一在开机时，按下F8进入”带命令提示符的安全”模式输入”NET USER+用户名+123456/ADD”可把某用户的密码强行设置为”123456″方法二如用户忘记登入密码可按下列方法解决1.在计算机启动时按〔F8〕及选〔Safe Mode With Command Prompt〕2.选〔Administrator〕后便会跳出〔Command Prompt〕的窗口3.用〔Net〕的命令增加一个用户，例：增加一个用户名为alanhkg888，命令语法如下：net user alanhkg888/add 4.将新增用户提升至Administrator的权力，例：提升刚才增加用户alanhkg888的权力，命令语法如下net localgroup administrators alanhkg888/add 5.完成上列步骤后重新启动计算机，在启动画面上便增加了一个用户alanhkg888了，选alanhkg888进入6.登入后在〔控制台〕→〔使用者账户〕→选忘记密码的用户，然后选〔移除密码〕后〔等出〕7.在登入画面中选原来的用户便可不需密码情况下等入(因已移除了)8.删除刚才新增的用户，在〔控制台〕→〔使用者账户〕→选〔alanhkg888〕，然后选〔移除账户〕便可*不适用于忘记安装时所设定〔administrator〕的密码方法三1、重新启动Windows XP，在启动画面出现后的瞬间，按F8，选择”带命令行的安全模式”运行。2、运行过程停止时，系统列出了超级用户administrator和本地用户owner的选择菜单，鼠标点击administrator，进入命令行模式。3、键入命令：”net user owner 123456/add”，强制性将OWNER用户的口令更改为”123456″。若想在此添加某一用户(如：用户名为abcdef，口令为123456) 的话,请键入”net user abcdef 123456/add”,添加后可用”net localgroup administrators abcdef/add”命令将用户提升为系统管理组administrators用户,具有超级权限。4.DOS下删windows\\system32\\config里面的SAM档就可以了5.开机后按键盘的Delete键进入BIOS界面。找到User Password选项，其默认为关闭状态。启动并输入用户密码(1~8位，英文或者数字)。计算机提示请再输入一遍以确认密码无误，保存退出后重新启动机器，这时就会在开机时出现密码菜单方法四如果是FAT32，进入DOS，删除c：winntsystem32configsam*.*就可以了。登陆只要输入administrator不输密码即可。然后创建一个新的。要是NTFS则无效另外如果你的系统没有加过微软的输入法补丁的话也可以利用输入法的漏洞去做一个管理员权限账号，具体方法如下：开机后，Win2000自启动，出现登录窗口，显示用户名，并要求输入密码(当然这时你不会有密码)。这时请将输入焦点置于用户名一项，用Ctrl+Shift切换输入法(随便选上一种，只要能出现输入法工具条的就行)。在出现的输入法提示工具条上单击右键，选择帮助，会弹出一个帮助窗口。接下来你需要在这个窗口里找到一个(绿色带下划线)超级链接，并用SHIFT+鼠标左键单击，打开它会弹出一个IE窗口，请在窗口地址栏里输入c：，到这步你应该很清楚怎么做了。只要点击标准按键的”向上”，会发现你可以进入”控制面板”了，进入后你可以直奔”用户和密码”接下发生的事只有你自己知道了。方法五我们知道在安装Windows XP过程中，首先是以”administrator”默认登录，然后会要求创建一个新账户，以便进入Windows XP时使用此新建账户登录，而且在Windows XP的登录接口中也只会出现创建的这个用户账号，不会出现”administrator”，但实际上该”administrator”账号还是存在的，并且密码为空。\n\n        ', null);
INSERT INTO `blog` VALUES ('95', '程序员必读的防破解技巧，留着以后用', '\n            \n \n\n孰不知再好的盾也有茅可以刺破一样，世界上很多nb的软件用了好多nb的防破解技术，结果还是被强大的黑客一一攻破，那对于我们这样的小程序员或小公司来说，既然nb的技术没有用，我们也没有那nb的防破解技术，何不如化有形为无形，不去用技术问题解决软件的防破解。\n　　个人总结：软件防破解其实不是技术问题，而是一个社会工程学问题。\n　　现在就给大家几条在开发软件的过程中几招百试不爽的软件防破解技巧，这些非技术的技巧实现起来很容易，但是防破解的效果是大大的。以我的软件为例(http://www.boneb.com/)\n　　１、试用版就是试用版\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我前几年开发过一款叫做网络信息采集专家的软件，分为正式版和试用版，这个软件最主要的目的就是采集数据，试用版和正式版的区别就在于试用版不能保存采集下来的数据。在这种情况下，很多做软件产品的程序员，在软件里区别正式版和试用版就仅仅是靠注册码验证而已，这种情况下，只要试用版被破解，那正式版就到手了，而我做的时候思路就是，正式版不提供公开下载，只有用户付费后才提供下载地址，公开发布的试用版里彻底不放提供保存数据的代码，造成的结果是，很多破解者得到试用版后就破解，令他们高兴的是，软件很容易破解（我的加密算法本身就不想写得太复杂），但令他们沮丧的是，破解成功后，试用版还是试用版，改有的功能还是没有。这个招式适合软件使用量不是特别大的用户，依我的看法，95%的软件使用量都不算大，所以这招其实大家皆可用之。\n　　2、开发“破解版”\n　　呵呵，大家是不是不理解这一点，以为我打错了呢，对，没错，就是自己制作自己软件的破解版，在软件正式版发布后，你可以同时制作一个假的“破解版”，也就是从软件表面上让大家认为这是个破解版，实际上用了一小段时间后，就发现这个破解版是不可用的，或不好用的，这个时候你的“破解版”再适时弹出“破解失效，请到&times;&times;处购买正式版”等宣传话语。然后你把这个假的破解版找几个有明的破解站上传，这个时候真的破解版还没出假的破解版就已经满天飞了，这样的情况下大多数用户都不可能下载到真的破解版，并且上了你的当用了假的破解版后，定会对破解版大失所望，认为网上流传的破解版都不可用，这样就更有可能购买你的正式版软件。\n　　３、让简单的算法不简单\n　　你可能用来以防止破解的算法比较简单，但这并意味着你就不能有效的阻止破解，我们照样可以用简单的算法把破解者弄奔溃掉，我的软件用了５种破解算法，每种算法都不是很复杂，估计单个破的话也就１０来分钟的事情，但我的做法是没有将所有算法全部用于同一时间同一处进行注册码的验证，而是分散到软件的不同功能，不同时间来验证，有的是软件启动，有的是点某个按钮的时候，有的是当时间达到某个条件的时候，破解者往往是把软件启动时候的验证给破掉，但是他在使用过程中又会经常随机的遇到很多验证失败的提示，而且这些过程随机，可能除了作者，没人知道这背后有多少处验证，这些验证又是什么时候触发，所以这种做法能让破解者抓狂的说。另外很多破解者仅仅是为了破解而破解，自己本身又不用被破解的软件，往往是启动阶段的验证一破解掉，就认为大功告成的开始发布“成功”破解版。\n　　４、联网验证\n　　如果你的软件是基于互联网提供服务的，你可以在软件中写一段代码到你的网络数据库中取信息，取到这些信息软件才可正常使用，当然这些数据必须是软件必须的，而且是不可伪造的，否则破解者把你联网验证的这段代码给爆破掉照样可以正确破解。\n　　５、服务为本\n　　尽量让你的软件提供的是一种服务，而不是某项技术本身，如果仅仅是某项技术，软件一被破解，用户拿到破解版的软件就不再需要你了；如果是服务，即使用户得到了可用的破解版，他可能还是需要转而寻求你获得技术支持，通过这种策略也可以避免破解带来的巨大损失。\n　　好，就写这么多，这些办法一用上破解者就很难破解你的软件了，而且你完成这些工作也不需要太多时间，更不需要money，以我的网络信息采集专家为例，从２００３年发布至今，我还没有遇到过真正的破解版，倒是经常看到一些破解论坛上对于我软件的破解感到非常困惑，无技可施。本文转至http://www.boneb.com/，转载请注明出处，并保持链接，谢谢！\n&nbsp;\n本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/yaohuib/archive/2010/09/26/5908031.aspx\n\n        ', null);
INSERT INTO `blog` VALUES ('96', '学电脑必懂的53个英文单词和缩写', '\n            \n\n \n\n学电脑必懂的53个英文单词和缩写 　　&middot;PC：个人计算机Personal Computer\n　　&middot;CPU：中央处理器Central Processing Unit\n　　&middot;CPU Fan：中央处理器的“散热器”(Fan)\n　　&middot;MB：主机板MotherBoard\n　　&middot;RAM：内存Random Access Memory，以PC-代号划分规格，如PC-133，PC-1066，PC-2700\n　　&middot;HDD：硬盘Hard Disk Drive\n　　&middot;FDD：软盘Floopy Disk Drive\n　　&middot;CD-ROM：光驱Compact Disk Read Only Memory\n　　&middot;DVD-ROM：DVD光驱Digital Versatile Disk Read Only Memory\n　　&middot;CD-RW：刻录机Compact Disk ReWriter\n　　&middot;VGA：显示卡(显示卡正式用语应为Display Card)\n　　&middot;AUD：声卡(声卡正式用语应为Sound Card)\n　　&middot;LAN：网卡(网卡正式用语应为Network Card)\n　　&middot;MODM：数据卡或调制解调器Modem\n　　&middot;HUB：集线器\n　　&middot;WebCam：网络摄影机\n　　&middot;Capture：影音采集卡\n　　&middot;Case：机箱\n　　&middot;Power：电源\n　　&middot;Moniter：屏幕，CRT为显像管屏幕，LCD为液晶屏幕\n　　&middot;USB：通用串行总线Universal Serial Bus，用来连接外围装置\n　　&middot;IEEE1394：新的高速序列总线规格Institute of Electrical Ａnd Electronic Engineers\n　　&middot;Mouse：鼠标，常见接口规格为PS/2与USB\n　　&middot;KB：键盘，常见接口规格为PS/2与USB\n　　&middot;Speaker：喇叭\n　　&middot;Printer：打印机\n　　&middot;Scanner：扫描仪\n　　&middot;UPS：不断电系统\n　　&middot;IDE：指IDE接口规格Integrated Device Electronics，IDE接口装置泛指采用IDE接口的各种设备\n　　&middot;SCSI：指SCSI接口规格Small Computer System Interface，SCSI接口装置泛指采用SCSI接口的各种设备\n　　&middot;GHz：(中央处理器运算速度达)Gega赫兹/每秒\n　　&middot;FSB：指“前端总线(Front Side Bus)”频率，以MHz为单位\n　　&middot;ATA：指硬盘传输速率ATAttachment，ATA-133表示传输速率为133MB/sec\n　　&middot;AGP：显示总线Accelerated Graphics Port，以2X，4X，8X表示传输频宽模式\n　　&middot;PCI：外围装置连接端口Peripheral Component Interconnect\n　　&middot;ATX：指目前电源供应器的规格，也指主机板标准大小尺寸\n　　&middot;BIOS：硬件(输入/输出)基本设置程序Basic Input Output System\n　　&middot;CMOS：储存BIOS基本设置数据的记忆芯片Complementary Metal-Oxide Semiconductor\n　　&middot;POST：开机检测Power On Self Test\n　　&middot;OS：操作系统Operating System\n　　&middot;Windows：窗口操作系统，图形接口\n　　&middot;DOS：早期文字指令接口的操作系统\n　　&middot;fdisk：“规划硬盘扇区”-DOS指令之一\n　　&middot;format：“硬盘扇区格式化”-DOS指令之一\n　　&middot;setup.exe：“执行安装程序”-DOS指令之一\n　　&middot;Socket：插槽，如CPU插槽种类有SocketA，Socket478等等\n　　&middot;Pin：针脚，如ATA133硬盘排线是80Pin，如PC2700内存模块是168Pin\n　　&middot;Jumper：跳线(短路端子)\n　　&middot;bit：位(0与1这两种电路状态)， 计算机数据最基本的单位\n　　&middot;Byte：字节，等于8 bit(八个位的组合，共有256种电路状态)，计算机一个文字以8 bit来表示\n　　&middot;KB：等于1024 Byte\n　　&middot;MB：等于1024 KB\n　　&middot;GB：等于1024 MB &nbsp;\n        ', null);
INSERT INTO `blog` VALUES ('97', '宽带连接错误的处理办法691、623、678、645、720、721、718、734、769、619、676、815(留着', '\n            \n \n\n宽带连接错误691(由于域上的用户名或密码无效而拒绝访问)/错误635(未知错误)的处理流程如下：　　（1）用户名密码填写错误　　（2）如果用户帐号密码填写无误，则进入下一步继续处理；建议重建拨号软件（如果不懂装拨号软件，可参考户重新）：　　?如果重装拨号软件后正常，原因为“拨号软件丢失”；　　?如果重装拨号软件后故障依旧，请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告。　　宽带连接错误６９１　　错误691真正意义上来讲：1：域上名出现错误，（用户名或密码输入错误）。2：服务器无反映，（机房用户端口错误，或帐号未被激活）。3：电话或宽带到期欠费造成。　　出现错误691的原因　　1.电信限制了你帐户使用数目，比如你这个帐户可以4个人用，现在4个人在用，你拨号就是错误691　　2.你在用完后没断开，至少服务器那边还是没断开，以为你还在用，和上面情况类似，所以错误691　　建议：每次关机的时候在宽带连接上右键，点断开　　出现错误691后不要一直死缠烂打拨号，等待个几分钟再试试，如果一直出现这种情况，拨打客服电话10000电信(10060网通/10050铁通)，告诉工作人员你的电脑错误691上不了，然后她问“请问你的宽带编号多少”，告诉她你帐户，然后她有时问你开户的是谁，回答开户的是谁，然后过个几分钟她就会找人帮你搞定　　宽带连接错误691的解决办法之一 　　解决ADSL莫名其妙的错误691问题　　工厂的办公室里有无线路由器，而家里新装了宽带，还没有买路由器，所以只跟哥共用一个ADSL帐号上网，一根网线在两台手提之间插来拔去的。但是让人郁闷的是，插在哥的手提上，都能连接上网络，可是插到我这台手提上总是提示错误691：用户名/密码错误。但是可以确定的是，我绝对没有把用户名或者密码输错，让我在拔号器与机子设置了好久也不行！！！郁闷......　　打10000询问，电信小姐坚持是我输错了，不是他们的问题。后来上网搜了一些相关的文章终于把问题解决了——原来电信把我的ADSL帐号和哥哥的提提网卡绑定了。解决方法如下（部分参考《Win2000/XP下轻松修改网卡MAC地址》一文，作者小超）：　　1、在大哥的手提机上运行（在“运行”中输入“cmd”可以调出命令行）中输入ipconfig/all命令，查看网络配置信息，找出本地连接里面的PhysicalAddress，记录下来。　　2、再进入我的本本中，进入设备管理器，在网络适配器里找到网卡，在网卡名称上用右键选择属性，进入“高级”选项卡，在左面的框中选中看到NetwotkAddress一项，选中右边的“值“，填入刚刚记录下来的MAC地址（不区分大小写，不要加“-”符号）即可。　　也许以后大家也会碰到，谨当学习！！！　　宽带连接错误623(找不到电话薄项目)　　步骤一：是否有防火墙或3721上网助手等软件，如有则建议退出　　（1）防火墙及3721上网助手后测试：如果故障解决，“用户软件问题”；　　（2）如果故障依旧存在，则进入下一步继续处理；　　步骤二：指导用户检查网卡状态并拔插网线：　　（1）如果故障解决，故障原因为“pc硬件问题”；　　（2）如果故障依旧存在，则进入下一步继续处理；　　步骤三：在条件具备情况下（有拨号软件、安装光盘（Win98要备有网卡驱动盘）建议删除及，再重新后：　　（1）如果故障解决，为“pc硬件问题”；　　（2）如果故障依旧存在，则进入下一步继续处理；　　步骤四：以上处理均无效或无法做简单的配合操作时，请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告 　　宽带连接错误678（远程计算机没响应）的处理流程如下：　　步骤一：检查MODEM信号灯是否正常，不正常重新启动modem。如果正常见步骤二。　　步骤二：询问用户是否有防火墙或3721上网助手等软件，如有则建议用户退出　　（1）防火墙及3721上网助手后测试：如果故障解决，故障原因为“用户软件问题”；　　（2）如果故障依旧存在，则进入下一步继续处理；　　步骤三：指导用户检查网卡状态并拔插网线：　　（1）如果故障解决，则填写：故障原因为“pc硬件问题”；　　（2）如果故障依旧存在，则进入下一步继续处理；　　步骤四：在条件具备情况下（用户有拨号软件、安装光盘（Win98要备有网卡驱动盘）建议用户删除拨号软件及，再重新安装网卡驱动后安装拨号软件：　　（1）如果故障解决，则填写：故障现象为“拨号连接超时”，故障原因为“PC硬件问题”；　　（2）如果故障依旧存在，则进入步骤七继续处理；　　步骤五：判断MODEM后面电话线是否可用，分离器连接是否正确：　　（1）MODEM后连电话不能使用，而计费号的其他电话可以使用的，建议更换电话线，故障原因为“用户室内线故障”；　　（2）如果用户家计费号的所有电话都不可以使用的，则请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告。步骤六：以上处理均无效或用户无法做简单的配合操作，则请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告。 　　宽带连接错误645产生原因为拨号软件文件受损造成（常见于ＸＰ系统），处理流程如下：　　步骤一：在条件具备情况下（用户有拨号软件），建议重新装拨号软件：如果故障解决，故障原因为“用户软件问题”；如果故障依旧，则建议用户找电脑公司维修电脑系统，故障原因为“用户软件问题”；。　　步骤二：以上处理均无效或用户无法做简单的配合操作，则请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告。 　　宽带连接错误720现象常见于ＸＰ系统，一般将系统重新启动，可拨多次，百分之九十都可以解决，处理流程如下：　　步骤一：建议将系统重新启动后再重新拨号上网：　　（1）如果故障解决，故障原因无　　（2）如果故障依旧，则建议用户还原系统或找电脑公司将系统格式化重装，重装后及时关闭系统自己更新功能。　　步骤二：以上处理均无效或用户无法做简单的配合操作，则请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告。 　　宽带连接错误721（远程计算机没有响应）此现象多为USB接口Modem故障代码，可依据以下步骤进行处理：　　步骤一：判断ＭＯＤＥＭ信号灯是否同步，信号灯同步参照步骤二，信号灯不同步参照步骤三、四、五。　　步骤二：信号灯同步，则为用户协议选错（ＯＡ或ＯＥ），如若不行可电话向客服电话10000电信(10060网通/10050铁通)进行申告　　步骤三：信号灯不同步，判断ＭＯＤＥＭ后面电话线是否可用，如果不能使用，而计费号的其他电话可以使用的，可建议用户自已换电话线，如果用户家计费号的所有电话都不可以使用的，如若不行可电话向客服电话10000电信(10060网通/10050铁通)进行申告。　　步骤四：检查分离器是否接反。 　　宽带连接错误718现象，极少数为用户端问题：　　步骤一：建议首先重启计算机后拨号测试：　　（1）如果故障解决，故障原因无。　　（2）如果故障依旧或没法进行简单配合，可电话向客服电话10000电信(10060网通/10050铁通)进行障碍申告。字串5 　　宽带连接错误734(PPP链接控制协议被终止)/错误735(请求的地址被服务器拒绝　　步骤一：建议重新启动电脑。　　步骤二：拨号软件出错，建议重装拨号软件，常见于ＸＰ系统的自带拨号。　　步骤三：以上处理均无效或用户无法做简单的配合操作，则请拨打客服电话10000电信(10060网通/10050铁通)进行障碍申告。 　　宽带连接错误７６９ 　　错误769：无法连接到指定目标。　　问题：这是指你电脑的网络设备有问题　　解决方法：　　打开“我的电脑”→“控制面版”→“网络连接”，查看本地连接的是否处在　　“禁用”状态，是的话只需双击本地连接，看到状态变为“已启用”即可。若是连本地连接都没有的话，　　那你的网卡100%有问题了——不是没装好就是坏了。请您联系您的电脑供应商，或者自己解决。　　出现错误769的错误，大多数是网卡被禁用，启用即可！造成的原因一般为：用户的误操作或一些防火墙软件、计算机病毒引起的，很普遍。如果没有找到本地连接，一般是网卡的驱动程序丢了或计算机没有检测到网卡，可以重新安装即可　　错误原因：网卡被禁用　　解决方法：请您点击电脑右键，选择属性，再选择设备管理，再看网卡驱动程序情况，如果是个“x”说明网卡被禁用，点击右键激活网卡就可以解决。　　宽带连接错误769产生原因及解决方案　　宽带连接错误769产生原因　　通常，如果存在下列情况之一，您将收到错误769的信息：　　1.网络电缆已断开。　　2.调制解调器已禁用。　　3.调制解调器驱动程序已损坏。　　4.计算机上正在运行间谍软件，它妨碍了连接。　　5.Winsock需要得到修复。　　6.第三方防火墙软件阻止了连接。　　解决方案：　　要查找问题的原因，请按照下列步骤操作。　　步骤1：确保网络电缆已连接　　确保网络电缆分别连接到计算机和调制解调器。如果您的计算机连接到集线器或路由器，请确保将集线器或路由器连接到调制解调器的电缆已连接。　　步骤2：确保网络适配器已启用　　1.单击“开始”，单击“运行”，键入ncpa.cpl，然后单击“确定”。　　2.右键单击“本地连接”图标。单击“启用”（如果该选项可用）。　　步骤3：重置调制解调器　　1.将从计算机到调制解调器的电缆断开连接。　　2.关闭调制解调器。如果调制解调器没有电源开关，请切断调制解调器的电源。　　3.等待两分钟。　　4.打开调制解调器，然后连接从计算机到调制解调器的电缆。　　步骤4：使用设备管理器，先卸载、然后重新安装调制解调器和驱动程序　　在按照这些步骤操作之前，您可能必须从硬件制造商那里下载网络适配器的最新驱动程序。1.单击“开始”，单击“运行”，键入sysdm.cpl，然后单击“确定”。　　2.单击“硬件”选项卡，单击“设备管理器”，然后找到“网络适配器”。　　3.展开“网络适配器”，然后右键单击网络适配器的图标。　　4.单击“卸载”，然后单击“确定”。在提示您删除与此设备相关联的文件的对话框中，单击“是”。　　5.重新启动计算机。或者，单击“操作”，然后单击“扫描检测硬件改动”。　　6.如果Windows找到设备但是没有识别它，您必须为网络适配器安装最新的驱动程序。　　步骤5：创建新的DSL或电缆连接　　1.单击“开始”，单击“运行”，键入ncpa.cpl，然后单击“确定”。　　2.单击“网络任务”下的“创建一个新的连接”。当向导启动后，单击“下一步”。　　3.单击“连接到Internet”，然后单击“下一步”。　　4.单击“手动设置我的连接”，然后单击“下一步”。　　5.选择“用要求用户名和密码的宽带连接来连接”，然后单击“下一步”。　　6.执行其余的步骤。使用Internet服务提供商(ISP)提供的连接信息完成该向导。　　注意：您可能必须使用您的ISP提供的软件才能创建新的连接。　　步骤6：修复Winsock和TCP/IP　　1.单击“开始”，单击“运行”，键入netshwinsockreset，然后按Enter键。　　2.当命令提示符窗口闪烁时，请重新启动计算机。　　步骤7：临时卸载第三方防火墙　　某些第三方防火墙软件（如ZoneAlarm和NortonPersonal防火墙）在运行WindowsXPSP2的计算机上可能导致Internet连接问题。您可能必须临时卸载这些程序以测试计算机。要进行测试，仅禁用这些程序是不够的。请确保您有CD或安装文件以便可以稍后重新安装这些程序。如果问题是由这些程序导致的，则您可能必须与该程序的供应商联系，以获得关于设置该程序的帮助。　　注意：在删除第三方防火墙程序之前，您可能要验证启用了WindowsXP防火墙。百度百科上的一些：1、 错误代码718、619、691：属于帐号密码问题。　　A、用户输入帐号、密码时输错，让用户重新输入。　　B、 帐号到期，可去“IP综合系统”中查询帐号是否到期。　　C、帐号卡在网上：一般是用户下网时不断开网络连接或异常吊线所导致，可以让用户将猫和电脑的电源关闭10分钟以上再进行连接，一般可以解决。　　D、帐号被偷：与互联网项目部进行联系解决。　　2、 错误代码676：属于机房设备问题，可让用户连续多拨几次即可登陆。　　3、错误代码720：属于modem驱动设置不正确，主要为vpi、vci参数值设置不正确（万州铁通为0/35）或者需要重新启动电脑。　　4、错误769： 此类错误原因是本地连接被用户禁用或者停用，主要出现在以太网猫的用户中，属于用户下网时错误断开网卡连接，造成网卡禁用，在“本地连接”中网卡启用即可。　　5、错误678：一般MODEM指示灯不正常，猫上的link灯闪烁（少数猫的link灯的英文标识为showtime），参照link不上的故障处理或让用户检查自身防火墙。如果MODEM指示灯正常，那故障的原因是电脑不能与MODEM建立连接，解决方法是将MODEM重启，如果还不行，最好重装系统，这种问题一般会长期出现。　　6、在Windows Vista Home Basic下经常会出现错误815.是网络端口问题.是由于网络供应商的网络断口连接性能.以及连接字段值不正确引起的.和系统一般无关再补个678：错误678，是宽带adsl拨号上网用户常常遇到的故障提示，简单地说就是网络不通了。宽带adsl拨号上网使用pppoe协议连接，通过电话线传输数据，使用adsl专用modem实现数据的调制解调，错误提示678的含义是，远程计算机无响应，意思是从计算机发出指令到网卡向外发送数据，包括电话线的传输，局端（电信局机房端）端子板的端口处理到返回数据到计算机的过程中数据传输出问题都会提示。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解决方法 　　1、首先确认adsl modem拨号正常，因为网卡自动获取的IP没有清除，所以再次拨号的时候网卡无法获取　　新的IP地址会提示678，操作方法是：关闭adsl modem，进入控制面板的网络连接右击本地连接选择禁用，5秒钟后右击本地连接选择启用，然后打开adsl modem拨号即可；　　2、如果第一步无效，则在关闭adsl modem的情况下，仍然禁用本地连接（网卡），重启计算机，然后启　　用本地连接（网卡），再打开adsl modem即可解决;　　3、如果上述步骤都无法解决，查看网卡灯是否亮，如果网卡灯不亮，参看派单知识库：“网卡灯不亮或经常不亮”的解决方案　　4、如果网卡灯正常1，2步无法解决则带领用户卸载网卡驱动，重装网卡驱动，如果用户xp系统按照：知识编号：9973，如何在WINXP下设置ADSL拨号连接 方法带领用户创建拨号连接，如果98系统建议用户安装Raspppoe软件或者EHERNET300软件连接即可。　　5、如果上述操作无效联系电信部门确认端口。　　6.adsl modem故障是主要原因。　　7.如果多台电脑使用路由器上网，可尝试将路由器拆除后连接Internt。若能顺利上网，则说明路由器故障，应排除路由器故障或更换新的路由器。　　8.如果是ADSL包年用户，在使用过程中如果出现这种情况，有可能是电话欠费，请咨询客户服务中心。有部分地区中国电信或中国联通用户，在电话欠费的情况下，电话可以打通，但是却无法上网，这时也有可能是电话欠费，因为现在部分地区的电信部门在用户电话欠费情况下，不是停止电话的使用，而是停止网络的使用。　　9.部分品牌Modem供电不足也容易造成错误678　　10.如果以上方法都不能解决您的问题，可以尝试一下adsl modem的reset按两三下再上试试。　　11.adsl modem设备损坏也会造成错误678，虽然从表面上看起来adsl modem运转正常，但是就是连接失败，笔者就曾遇到此类问题，最终换了一个新的adsl modem方解决问题\n\n        ', null);
INSERT INTO `blog` VALUES ('98', '各种软件视频教学', '\n            \n \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不知道哪位高人收集了这么全，这么实用的视频教程。讲解深入浅出，生动具体，简直太棒了！我看了一两天的文字ps7.0的文字教程，在视频上几个小时就搞定了。有点相见恨晚，不过也没有撒，不是还有好多教程么看呢么。呵呵，好好学习，天天向上。所以强力向你推荐，希望能给你工作生活带来方便。&nbsp;&nbsp; &nbsp; 平面设计\n \nPhotoshop超强视频教程 \nPhotoshop高手进阶教程 \nPhotoshop图片调色教程\n\nCorelDRAW12视频教程 \nIllustrator视频教程\nPhotoshop CS2 视频教程\n\nPhotoshop实用技术讲解\nFireworks mx视频教程\n商业包装设计视频教程\n\n神奇数码照相馆\nCorelDRAW实例视频教程\nFreehand视频教程\n\nPhotoshop多媒体教程\nCorelDRAW视频教程连载\nPhotoshop (一部分图文)\n\nphotoshop \nphotoshop CS3视频教程\n大师之路PS3\n\nPhotoshop CS实例教程 \nPhotoshop CS2 高手之路\n光影魔术手使用视频教程\n\nPhotoshop CS/CS2 远程教育课程\nPhotoshop CS3专家讲堂视频教程合集\nCorelDRAW平面设计实训教程 \n\n3Dmax与Photoshop渲染实例讲解\nFireworks视频教程\nCorel PainterX视频教程 \n\n史上最全面的图片处理视频教程\nFireworks CS3入门到精通\nCorelDraw从入门到精通\n\nPhotoshopCS3经典案例视频教程\nPhotoshop中文版完全解析教程\nPhotoshop简单实用视频教程\n\n 三维设计\n\n\n\n3D Maxs 动画制作在线教程 \n用3d制作游戏\n3Dmax制作生活用品视频教程 \n\n3Dmax家装实例培训视频教程 \nAutoCAD2007机械制图教程 \nAutoCAD内外施工图绘制教程\n\n3Ds MAX 7.0 视频教程连载 \n3DMax视频教程\nAutoCAD2005视频教程\n\nAutoCAD07 中文版标准教程 \n3Dmax室内设计\nAutoCAD2007建筑效果图设计\n\n4U2V版3dmax建模教程\nPoser和Painter建模教程\n3D Maxs 三维动画制作教程\n\n3DSMAX插件Vray视频教程\n3Dmax室内豪华装潢设计\nLightscape基础与应用\n\nAutoCAD Mechanical标准教程\nMAYA基础教程之建模篇\nAutoCAD视频教程\n\nAutoCAD2007从入门到精通\n3DMAX制作生活用品视频教程\nRealFlow入门讲解与实例\n\n游戏建模实例视频教程\n装饰装修设计超级宝典\n3DMAX室内设计家庭装修实例培训视频教程\n\n用3Dmax制作魔兽世界视频教程\nAutocad2007新手进阶之路\n3DSMAX室内渲染实例教程\n\n\n\n 动画制作\n\nFlash从入门到精通视频教程 \nFlash工具实例视频教程 \nFlashMX2004实例制作教程 \n\nFlash基础应用指南视频教程 \nAuthorware 视频教程 \n东正Flash从入门到精通 \n\nFlash卡通动画制作视频教程\nFlash动画设计师培训\nFlash和Photoshop教程\n\nFlash9.0 新功能体验\n用Flash制作漫天飘扬的雪花\nFLASH8.0绘制百事可乐标志\n\nFlash MX 多媒体教程连载\nFlash实例视频教程\nFlash MX2004教程\n\nMaYa动画视频教程\nFlash 8.0视频教程\nFlash高级编程教程\n\nFlash CS3之动画教程\nFIF Flash MX 2004\nFlash actionscript(简称AS)\n\nUlead GIF Animator 5教程\nFlash8.0精彩视频教程\nFlash9.0 新功能体验 \n\nFlash CS3 之入门初窥\nFlash高级Action编程教程\nAdobe After Effects 7 使用之操作篇(上)\n\n超酷小软件视频教程\nFlash Action Scrip3.0 实用教程\nFlash制作经典案例教程\n\n\n 网页制作\n\n\n\nASP超速入门视频教程 \nASP互动视频教程 \nFrontPage视频教程 \n\nDreamweaver实例视频教程\n入门级HTML基础视频教程 \nDreamweaver轻松上手教程\n\nDreamweaver ASP动态网站 \n网页设计制作多媒体系列教程\nGoLive视频教程 \n\n美工之路系列视频 \nDreamweaver基础视频教程 \nDreamweaver入门基础 \n\nDreamweaver 8动态网站开发基础教程\nDreamweaver制作ASP动态网站\nCSS从入门到精通视频教程\n\nCSS层叠样式表简明教程\nDreamweaver 超全面视频教程\nDiscuz! Board架设与管理视频教程\n\nHTML基础及应用视频教程\nPHP编程之简明入门视频教程\n\n\n 办公软件\n\nWord2003 视频教程\nExcel2003视频教程 \n微软Office2007教程\n\nPageMaker视频教程 \n方正飞腾(FIT)4.0视频教程 \nWPS2005新手体验教程 \n\n21互联版Word2003视频教程 \nWord03 &amp; Word07 排版实例 \nPowerPoint2003视频教程\n\nOffice2007从入门到精通\n微软Office2007教程\n方正飞腾创意5.0视频教程\n\nOffice2003视频教程\nWPS2005文字处理视频教程\nWord2003入门到精通教程\n\n 工具应用\n\n\n\nQQ场景编辑器使用教程 \n实用工具视频教程 \nWinrar技巧视频教程 \n\nFoxmail技巧视频教程 \n我形我速从入门到精通 \nQQ技巧之Flash制作表情 \n\nVista的安装、优化教程\nWin XP秘籍视频教程\n王涛老师视频集合 \n\n电脑从入门到精通\nProAnimator 视频教程 \n音乐制作软件教程之二 \n\n一小时学会刻录软件nero\n音乐制作软件集合教程 \nWindows xp设置教程\n\n一键ghost视频教程 \n电脑基础百事通（上）\n电脑基础视频教程\n\n电脑基础百事通（下）\n安装优化使用视频教程\n硬盘安装XP到Ghost备份\n\n注册表到入门精通\nwindows优化大师教程\n虚拟光碟总管使用技巧\n\n《如何安装驱动程序》\n常用软件使用设置教程\n硬件维护菜鸟到高手教程\n\n全国计算机等级考试二级Visual Basic\n全国计算机等级考试二级Visual FoxPro\nSEO入门到精通视频教程\n\n\n\n\n 网络安全\n\n电脑网络安全设置视频教程 \n网络安全反黑视频讲堂\n江民杀毒软件KV2007\n\n网络安全培训视频教程 \n计算机网络安全教程\n黑客与安全网络培训教程\n\n\n 程序设计\n\nVC++开发详解视频教程 \nJava 开发详解视频教程 \n软件开发实战教程之Eclipse篇 \n\nVisual Basic 入门到精通视频教程\nC#程序设计入门与实例视频教程\nJAVA-J2ME移动开发实战教学\n\nPHP编程之简明入门视频教程 \nFlash Action Scrip3.0 实用教程\n\n\n 视频处理\n\n会声会影10 视频教程 \nPremierepro视频教程 \n家用视频编辑实用教程\n\nPremiere Pro 视频教程连载 \n视频录制软件视频教程\nPremierePro2.0 课堂录制版\n\n\n\n\n\n 几个教程网\n\n\n\n金鹰电脑教程网 \n中国教程网 \n天极网(设计在线)\n\n\n        ', null);
INSERT INTO `blog` VALUES ('99', 'USB重装系统（没光驱重装系统也没问题）', '\n            \n \n\n&nbsp;&nbsp;&nbsp;&nbsp; 前几天，公司的电脑由于C盘太小，导致修复错误的时候把C盘给塞满，开不了系统。又因为公司的主机没有光驱，用不了系统碟，而拿到公司总部修理又很麻烦，所以着手用U盘来重装系统。\n&nbsp;&nbsp;&nbsp; 其实用U盘装系统很简单，只要你的主板支持USB方式的启动就行了。\n&nbsp;&nbsp;&nbsp; 首先你要先制作WINPE的启动盘，这个也不难，主要是要下载 一个winpeu.rar的包下来，放在U盘里，然后按照以下步骤执行：\n1、首先将U盘插入电脑的USB接口，重要提示：制作过程U盘会被格式化，注意备份资料2、运行UltraISO.exe程序，选择“文件”——“打开”，选择WindowsPE.iso文件3、然后选择“启动光盘”——“写入硬盘映像”4、在“硬盘驱动器”项目中选择你要制作成启动盘的U盘盘符5、在“写入方式”项目中选择USB-HDD+或者USB-ZIP+，个人建议选择USB-ZIP+，兼容性比较好6、最后，点击“写入”，等待数秒，程序提示制作成功完成后，就可以拔出U盘了。\n做完以上步骤，那你就拥有U盘winpe的启动盘。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二部，你必须下载GHOST版本的系统的镜像文件（例如DeepinXP-v5.6.iso），这个镜像文件放在另外的一个U盘里（普通的没做成启动U盘就行了）。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第三部，重启电脑，按DELETE键，进入BIOGS，设置USB-ZIP启动（当时在做启动盘时，什么启动就什么启动），按F10,再敲ENTER键就可以了。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第四部，进入PE系统中，里面有一个系统备份，就好像装GHOST系统一样安装就行了，当然安装时要用到另外一个U盘的系统镜像文件，找到一个GHOSTXP.GHO的文件。安装完之后重启，重新进入BIOGS里，硬盘驱动，然后USB重装系统就完成了！\n\n        ', null);
INSERT INTO `blog` VALUES ('100', '无线网络密码破解方法大全(附破解软件下载)', '\n            \n \n\n目前网上流行有很多无线密码的破解方法，总结起来最实用的还是这两种：第一种是Wirelessnetview+WinAirCrackPack软件组合，这种方法简单方便；第二种就是大家熟悉的使用ＢＴ４破解了。这两种方法的具体操作步骤如下：\n&nbsp;\n一、Wirelessnetview+WinAirCrackPack软件组合\nwirelessnetview下载地址：http://www.heibai.net/download/Soft/Soft_18755.htm\nWinAircrackPack下载地址：http://www.heibai.net/download/Soft/Soft_5930.htm\n1、首先根据自己的无线网卡型号在网上下载相关无线网卡抓包驱动，更新驱动。一般的网卡都会有抓包驱动，但是Intel (R) WiFi Link 5100 AGN目前好像没有抓包驱动，我自己的就是这种网卡，只能采用BT4破解了，不过用这种方法倒挺方便也挺简单的。\n2、打开Wirelessnetview里面的WirelessNetView应用程序，查看当前无线AP的SSID号、加密方式、MAC地址，并作记录，后面会用到。\n&nbsp;\n&nbsp;\n3、打开WinAirCrackPack软件包，打开 airodump.exe,这是专门抓包的工具。按照下图\n\n首先程序会提示本机目前存在的所有无线网卡接口，并要求你输入需要捕捉数据帧的无线网卡接口编号，在这里我选择‘26’；然后程序要求你输入该WNIC的芯片类型，目前大多国际通用芯片都是使用‘HermesI/Realtek’子集的，因此选择‘o’；然后需要输入要捕捉的信号所处的频道，我们需要捕捉的AP所处的频道为‘6’；提示输入捕捉数据帧后存在的文件名及其位置，若不写绝对路径则文件默认存在在winaircrack的安装目录下，以.cap结尾，上例中使用的是‘last’； 最后winaircrack提示：‘是否只写入/记录IV[初始化向量]到cap文件中去？’，我在这里选择‘否/n’；确定以上步骤后程序开始捕捉数据包。\n 然后就是等待，直至上表中‘Packets’列的总数为300000时即可。最好选择在有客户端下东西的时候，这样抓包就会很快，当数据包大道要求时，按Ctrl+C停止捕获。这时程序目录下就会生成两个文件：last.cap和last.txt。其中last.cap为通用嗅探器数据包记录文件类型，可以使用ethereal程序打开查看相关信息，last.txt为此次嗅探任务最终的统计数据。 4、对last.cap执行破解工作。首先执行WinAirCrack.exe文件  输入要破解的无线AP的SSID号和MAC地址，然后单击上图的文件夹按钮，弹出*.cap选定对话框，选择last.cap文件。 5、点击左侧栏方的‘Wep’按钮切换主界面至WEP破解选项界面：  选择‘Key size’为64（目前大多数用户都是使用这个长度的WEP KEY，因此这一 步骤完全是靠猜测选定该值）。  6、选择aircrack.exe应用程序所在的路径  单击左侧的“Advanced”选项，根据自己程序存放的位置选择aircrack.exe路径。 7、一切设置好之后，单击主界面右下方的‘Aircrack the key…’按钮，此时将弹出一个内嵌在cmd.exe下运行的进程对话框，并在提示得出WEP KEY：  至此破解成功！ 我也没有用这种方法试过，因为无线网卡不支持，我用的是下面这种： &nbsp;&nbsp;&nbsp;&nbsp;二、使用ＢＴ４破解 &nbsp;&nbsp;&nbsp;&nbsp;backtrack4(bt4）下载地址：http://www.heibai.net/download/Soft/Soft_18788.htm  &nbsp;&nbsp;&nbsp;&nbsp;我感觉应该比第一种方法还要方便, 下面是我自己破解过程，并亲自截图 １、下载BT4系统，刻录光盘，或者用U盘做系统引导，可以用unetbootin-windows-356.Exe程序来做u盘镜像文件，作为系统引导盘，我也没试过，我直接用刻录光盘。注意，这里并不是让你装系统，而是直接用盘里的系统。 ２、把刻录好的系统放进光驱，或者插入U盘。重启电脑，会直接进入BT4系统界面，会有四个选项，一般选第一个按回车进入，系统开始装载文件。 ３、接下来会有命令行提示，输入用户名为root，密码为toor（看清楚了）。  ４、然后输入界面提示的第一个命令/etc/init.d/networking start进行网络初始化，再输入第二个命令startx，进入图形化界面。这就是Linux系统了。 ５、有汉化包的话可以选择中文语言，不过我在刻盘前忘了加入汉化包了，只好看英文了。 更改语言，大致如下图吧，我也没试过，呵呵！（这里推荐一种修改iso文件的工具UltraISO，挺好用的，把汉化包的两个lzm文件放入\\bt4\\modules目录下面就行了）   ６、打开Shell命令窗口，输入/etc/init.d/NetworkManager start命令开启网络管理功能。   ７、输入ifconfig -a查看本地网卡接口信息。 &nbsp; &nbsp;  Wlan0就是我的无线网卡了 7、输入airmon-ng start wlan0 6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里的6是通道channel。一般最常用的有1、6、11这三个通道。 　　  8、输入airodump-ng --ivs -w &lt;IVS_File&gt; -c &lt;Channel&gt; mon0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这行命令是开始捕获IVS数据包，&lt;IVS_File&gt;是存放数据的文件名，随便起个名字就成，&lt;Channel&gt;这里指通道，写6就行。比如：airodump-ng&nbsp;&nbsp; --ivs&nbsp;&nbsp; -w&nbsp;&nbsp; filename -c&nbsp;&nbsp; mon0   等待数据包data涨到5000以上，或者更高，可以多试试。再打开一个Shell窗口，输入破解命令：aircrack-ng&nbsp;&nbsp; -n&nbsp;&nbsp; 64&nbsp;&nbsp; -b&nbsp;&nbsp; &lt;ApMac&gt;&nbsp;&nbsp; &lt;IVS_File&gt;-01.ivs ，这里的&lt;ApMac&gt;是指目标AP的MAC地址，就是SSID号对应的MAC，只要数据包达到5000以上就可试试。&lt;IVS_File&gt;是就是上面保存数据的文件名。  至此，破解成功，数据包已达8400多，整个过程下来也就十多分钟。有的时候比较难破解，要涨到2万多时才破解出来，还要靠运气啊！ &nbsp; 有关工具下载地址： 1、BT4下载：http://www.heibai.net/download/Soft/Soft_18788.htm 2、WinAircrackPack：http://www.heibai.net/download/Soft/Soft_5930.htm 3、Wirelessnetview：http://www.heibai.net/download/Soft/Soft_18755.htm\n\n        ', null);
INSERT INTO `blog` VALUES ('101', '非常齐全的电脑知识（先保存，留备用）', '\n            \n \n\n误删资料恢复 一不小心，删错了，还把回收站清空了，咋办啊？只要三步，你就能找回你删掉并清空回收站的东西 步骤： 1、单击“开始——运行，然后输入regedit （打开注册表） 2、依次展开：HEKEY——LOCAL——MACHIME/SOFTWARE/microsoft/WINDOWS/ CURRENTVERSION/EXPLORER/DESKTOP/NAMESPACE 在左边空白外点击“新建” ，选择：“主键”，把它命名为“645FFO40——5081——101B——9F08——00AA002F954E” 再把右边的“默认”的主键的键值设为“回收站”，然后退出注册表。就OK啦。 3、要重启计算机。 只要机器没有运行过磁盘整理。系统完好.任何时候的文件都可以找回来。&nbsp;&nbsp;\n&nbsp;\n也许你已经在Excel中完成过上百张财务报表，也许你已利用Excel函数实现过上千次的复杂运算，也许你认为Excel也不过如此，甚至了无新意。但我们平日里无数次重复的得心应手的使用方法只不过是Excel全部技巧的百分之一。本专题从Excel中的一些鲜为人知的技巧入手，领略一下关于Excel的别样风情。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一、让不同类型数据用不同颜色显示 　　在工资表中，如果想让大于等于2000元的工资总额以“红色”显示，大于等于1500元的工资总额以“蓝色”显示，低于1000元的工资总额以“棕色”显示，其它以“黑色”显示，我们可以这样设置。 　　1.打开“工资表”工作簿，选中“工资总额”所在列，执行“格式→条件格式”命令，打开“条件格式”对话框。单击第二个方框右侧的下拉按钮，选中“大于或等于”选项，在后面的方框中输入数值“2000”。单击“格式”按钮，打开“单元格格式”对话框，将“字体”的“颜色”设置为“红色”。 　　2.按“添加”按钮，并仿照上面的操作设置好其它条件(大于等于1500，字体设置为“蓝色”；小于1000，字体设置为“棕色”)。 　　3.设置完成后，按下“确定”按钮。 　　看看工资表吧，工资总额的数据是不是按你的要求以不同颜色显示出来了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 二、建立分类下拉列表填充项 　　我们常常要将企业的名称输入到表格中，为了保持名称的一致性，利用“数据有效性”功能建了一个分类下拉列表填充项。 　　1.在Sheet2中，将企业名称按类别(如“工业企业”、“商业企业”、“个体企业”等)分别输入不同列中，建立一个企业名称数据库。 　　2.选中A列(“工业企业”名称所在列)，在“名称”栏内，输入“工业企业”字符后，按“回车”键进行确认。 　　仿照上面的操作，将B、C……列分别命名为“商业企业”、“个体企业”…… 　　3.切换到Sheet1中，选中需要输入“企业类别”的列(如C列)，执行“数据→有效性”命令，打开“数据有效性”对话框。在“设置”标签中，单击“允许”右侧的下拉按钮，选中“序列”选项，在下面的“来源”方框中，输入“工业企业”，“商业企业”，“个体企业”……序列(各元素之间用英文逗号隔开)，确定退出。 　　再选中需要输入企业名称的列(如D列)，再打开“数据有效性”对话框，选中“序列”选项后，在“来源”方框中输入公式：=INDIRECT(C1)，确定退出。 　　4.选中C列任意单元格(如C4)，单击右侧下拉按钮，选择相应的“企业类别”填入单元格中。然后选中该单元格对应的D列单元格(如D4)，单击下拉按钮，即可从相应类别的企业名称列表中选择需要的企业名称填入该单元格中。 　　提示：在以后打印报表时，如果不需要打印“企业类别”列，可以选中该列，右击鼠标，选“隐藏”选项，将该列隐藏起来即可。 　　三、建立“常用文档”新菜单 　　在菜单栏上新建一个“常用文档”菜单，将常用的工作簿文档添加到其中，方便随时调用。 　　1.在工具栏空白处右击鼠标，选“自定义”选项，打开“自定义”对话框。在“命令”标签中，选中“类别”下的“新菜单”项，再将“命令”下面的“新菜单”拖到菜单栏。 　　按“更改所选内容”按钮，在弹出菜单的“命名”框中输入一个名称(如“常用文档”)。 　　2.再在“类别”下面任选一项(如“插入”选项)，在右边“命令”下面任选一项(如“超链接”选项)，将它拖到新菜单(常用文档)中，并仿照上面的操作对它进行命名(如“工资表”等)，建立第一个工作簿文档列表名称。 　　重复上面的操作，多添加几个文档列表名称。 　　3.选中“常用文档”菜单中某个菜单项(如“工资表”等)，右击鼠标，在弹出的快捷菜单中，选“分配超链接→打开”选项，打开“分配超链接”对话框。通过按“查找范围”右侧的下拉按钮，定位到相应的工作簿(如“工资.xls”等)文件夹，并选中该工作簿文档。 　　重复上面的操作，将菜单项和与它对应的工作簿文档超链接起来。 　　4.以后需要打开“常用文档”菜单中的某个工作簿文档时，只要展开“常用文档”菜单，单击其中的相应选项即可。 　　提示：尽管我们将“超链接”选项拖到了“常用文档”菜单中，但并不影响“插入”菜单中“超链接”菜单项和“常用”工具栏上的“插入超链接”按钮的功能。 　　四、制作“专业符号”工具栏 　　在编辑专业表格时，常常需要输入一些特殊的专业符号，为了方便输入，我们可以制作一个属于自己的“专业符号”工具栏。 　　1.执行“工具→宏→录制新宏”命令，打开“录制新宏”对话框，输入宏名?如“fuhao1”?并将宏保存在“个人宏工作簿”中，然后“确定”开始录制。选中“录制宏”工具栏上的“相对引用”按钮，然后将需要的特殊符号输入到某个单元格中，再单击“录制宏”工具栏上的“停止”按钮，完成宏的录制。 　　仿照上面的操作，一一录制好其它特殊符号的输入“宏”。 　　2.打开“自定义”对话框，在“工具栏”标签中，单击“新建”按钮，弹出“新建工具栏”对话框，输入名称——“专业符号”，确定后，即在工作区中出现一个工具条。 　　切换到“命令”标签中，选中“类别”下面的“宏”，将“命令”下面的“自定义按钮”项拖到“专业符号”栏上(有多少个特殊符号就拖多少个按钮)。 　　3.选中其中一个“自定义按钮”，仿照第2个秘技的第1点对它们进行命名。 　　4.右击某个命名后的按钮，在随后弹出的快捷菜单中，选“指定宏”选项，打开“指定宏”对话框，选中相应的宏(如fuhao1等)，确定退出。 　　重复此步操作，将按钮与相应的宏链接起来。 　　5.关闭“自定义”对话框，以后可以像使用普通工具栏一样，使用“专业符号”工具栏，向单元格中快速输入专业符号了。 　　五、用“视面管理器”保存多个打印页面 　　有的工作表，经常需要打印其中不同的区域，用“视面管理器”吧。 　　1.打开需要打印的工作表，用鼠标在不需要打印的行(或列)标上拖拉，选中它们再右击鼠标，在随后出现的快捷菜单中，选“隐藏”选项，将不需要打印的行(或列)隐藏起来。 　　2.执行“视图→视面管理器”命令，打开“视面管理器”对话框，单击“添加”按钮，弹出“添加视面”对话框，输入一个名称(如“上报表”)后，单击“确定”按钮。 　　3.将隐藏的行(或列)显示出来，并重复上述操作，“添加”好其它的打印视面。 　　4.以后需要打印某种表格时，打开“视面管理器”，选中需要打印的表格名称，单击“显示”按钮，工作表即刻按事先设定好的界面显示出来，简单设置、排版一下，按下工具栏上的“打印”按钮，一切就OK了。 　　六、让数据按需排序 　　如果你要将员工按其所在的部门进行排序，这些部门名称既的有关信息不是按拼音顺序，也不是按笔画顺序，怎么办?可采用自定义序列来排序。 　　1.执行“格式→选项”命令，打开“选项”对话框，进入“自定义序列”标签中，在“输入序列”下面的方框中输入部门排序的序列(如“机关,车队,一车间,二车间,三车间”等)，单击“添加”和“确定”按钮退出。 　　2.选中“部门”列中任意一个单元格，执行“数据→排序”命令，打开“排序”对话框，单击“选项”按钮，弹出“排序选项”对话框，按其中的下拉按钮，选中刚才自定义的序列，按两次“确定”按钮返回，所有数据就按要求进行了排序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 七、把数据彻底隐藏起来 　　工作表部分单元格中的内容不想让浏览者查阅，只好将它隐藏起来了。 　　1.选中需要隐藏内容的单元格(区域)，执行“格式→单元格”命令，打开“单元格格式”对话框，在“数字”标签的“分类”下面选中“自定义”选项，然后在右边“类型”下面的方框中输入“；；；”(三个英文状态下的分号)。 　　2.再切换到“保护”标签下，选中其中的“隐藏”选项，按“确定”按钮退出。 　　3.执行“工具→保护→保护工作表”命令，打开“保护工作表”对话框，设置好密码后，“确定”返回。 　　经过这样的设置以后，上述单元格中的内容不再显示出来，就是使用Excel的透明功能也不能让其现形。 　　提示：在“保护”标签下，请不要清除“锁定”前面复选框中的“∨”号，这样可以防止别人删除你隐藏起来的数据。 　　八、让中、英文输入法智能化地出现 　　在编辑表格时，有的单元格中要输入英文，有的单元格中要输入中文，反复切换输入法实在不方便，何不设置一下，让输入法智能化地调整呢? 　　选中需要输入中文的单元格区域，执行“数据→有效性”命令，打开“数据有效性”对话框，切换到“输入法模式”标签下，按“模式”右侧的下拉按钮，选中“打开”选项后，“确定”退出。 　　以后当选中需要输入中文的单元格区域中任意一个单元格时，中文输入法(输入法列表中的第1个中文输入法)自动打开，当选中其它单元格时，中文输入法自动关闭。 　　九、让“自动更正”输入统一的文本 　　你是不是经常为输入某些固定的文本，如《电脑报》而烦恼呢?那就往下看吧。 　　1.执行“工具→自动更正”命令，打开“自动更正”对话框。 　　2.在“替换”下面的方框中输入“pcw”(也可以是其他字符，“pcw”用小写)，在“替换为”下面的方框中输入“《电脑报》”，再单击“添加”和“确定”按钮。 　　3.以后如果需要输入上述文本时，只要输入“pcw”字符?此时可以不考虑“pcw”的大小写?，然后确认一下就成了。 　　十、在Excel中自定义函数 　　Excel函数虽然丰富，但并不能满足我们的所有需要。我们可以自定义一个函数，来完成一些特定的运算。下面，我们就来自定义一个计算梯形面积的函数： 　　1.执行“工具→宏→Visual Basic编辑器”菜单命令(或按“Alt+F11”快捷键)，打开Visual Basic编辑窗口。 　　2.在窗口中，执行“插入→模块”菜单命令，插入一个新的模块——模块1。 　　3.在右边的“代码窗口”中输入以下代码： 　　Function V(a,b,h)V = h*(a+b)/2End Function 　　4.关闭窗口，自定义函数完成。 　　以后可以像使用内置函数一样使用自定义函数。 　　提示：用上面方法自定义的函数通常只能在相应的工作簿中使用。 　　十一、表头下面衬张图片 　　为工作表添加的背景，是衬在整个工作表下面的，能不能只衬在表头下面呢? 　　1.执行“格式→工作表→背景”命令，打开“工作表背景”对话框，选中需要作为背景的图片后，按下“插入”按钮，将图片衬于整个工作表下面。 　　2.在按住Ctrl键的同时，用鼠标在不需要衬图片的单元格(区域)中拖拉，同时选中这些单元格(区域)。 　　3.按“格式”工具栏上的“填充颜色”右侧的下拉按钮，在随后出现的“调色板”中，选中“白色”。经过这样的设置以后，留下的单元格下面衬上了图片，而上述选中的单元格(区域)下面就没有衬图片了(其实，是图片被“白色”遮盖了)。 　　提示?衬在单元格下面的图片是不支持打印的。 　　十二、用连字符“&amp;”来合并文本 　　如果我们想将多列的内容合并到一列中，不需要利用函数，一个小小的连字符“&amp;”就能将它搞定(此处假定将B、C、D列合并到一列中)。 　　1.在D列后面插入两个空列(E、F列)，然后在D1单元格中输入公式：=B1&amp;C1&amp;D1。 　　2.再次选中D1单元格，用“填充柄”将上述公式复制到D列下面的单元格中，B、C、D列的内容即被合并到E列对应的单元格中。 　　3.选中E列，执行“复制”操作，然后选中F列，执行“编辑→选择性粘贴”命令，打开“选择性粘贴”对话框，选中其中的“数值”选项，按下“确定”按钮，E列的内容(不是公式)即被复制到F列中。 　　4.将B、C、D、E列删除，完成合并工作。 　　提示：完成第1、2步的操作，合并效果已经实现，但此时如果删除B、C、D列，公式会出现错误。故须进行第3步操作，将公式转换为不变的“值”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 生成绩条 　　常有朋友问“如何打印成绩条”这样的问题，有不少人采取录制宏或VBA的方法来实现，这对于初学者来说有一定难度。出于此种考虑，我在这里给出一种用函数实现的简便方法。 　　此处假定学生成绩保存在Sheet1工作表的A1至G64单元格区域中，其中第1行为标题，第2行为学科名称。 　　1.切换到Sheet2工作表中，选中A1单元格，输入公式：=IF(MOD(ROW()，3)=0，″″，IF(0MOD?ROW()，3(=1，sheet1！Aū，INDEX(sheet1！$A：$G，INT(((ROW()+4)/3)+1)，COLUMN())))。 　　2.再次选中A1单元格，用“填充柄”将上述公式复制到B1至G1单元格中；然后，再同时选中A1至G1单元格区域，用“填充柄”将上述公式复制到A2至G185单元格中。 　　至此，成绩条基本成型，下面简单修饰一下。 　　3.调整好行高和列宽后，同时选中A1至G2单元格区域(第1位学生的成绩条区域)，按“格式”工具栏“边框”右侧的下拉按钮，在随后出现的边框列表中，选中“所有框线”选项，为选中的区域添加边框(如果不需要边框，可以不进行此步及下面的操作)。 　　4.同时选中A1至G3单元格区域，点击“常用”工具栏上的“格式刷”按钮，然后按住鼠标左键，自A4拖拉至G186单元格区域，为所有的成绩条添加边框。 　　按“打印”按钮，即可将成绩条打印出来。 　　十四、Excel帮你选函数 　　在用函数处理数据时，常常不知道使用什么函数比较合适。Excel的“搜索函数”功能可以帮你缩小范围，挑选出合适的函数。 　　执行“插入→函数”命令，打开“插入函数”对话框，在“搜索函数”下面的方框中输入要求(如“计数”)，然后单击“转到”按钮，系统即刻将与“计数”有关的函数挑选出来，并显示在“选择函数”下面的列表框中。再结合查看相关的帮助文件，即可快速确定所需要的函数。 　　十五、同时查看不同工作表中多个单元格内的数据 　　有时，我们编辑某个工作表(Sheet1)时，需要查看其它工作表中(Sheet2、Sheet3……)某个单元格的内容，可以利用Excel的“监视窗口”功能来实现。 　　执行“视图→工具栏→监视窗口”命令，打开“监视窗口”，单击其中的“添加监视”按钮，展开“添加监视点”对话框，用鼠标选中需要查看的单元格后，再单击“添加”按钮。重复前述操作，添加其它“监视点”。 　　以后，无论在哪个工作表中，只要打开“监视窗口”，即可查看所有被监视点单元格内的数据和相关信息。 　　十六、为单元格快速画边框 　　在Excel 2002以前的版本中，为单元格区域添加边框的操作比较麻烦，Excel 2002对此功能进行了全新的拓展。 　　单击“格式”工具栏上“边框”右侧的下拉按钮，在随后弹出的下拉列表中，选“绘图边框”选项，或者执行“视图→工具栏→边框”命令，展开“边框”工具栏。 　　单击工具栏最左侧的下拉按钮，选中一种边框样式，然后在需要添加边框的单元格区域中拖拉，即可为相应的单元格区域快速画上边框。 　　提示：①如果画错了边框，没关系，选中工具栏上的“擦除边框”按钮，然后在错误的边框上拖拉一下，就可以清除掉错误的边框。②如果需要画出不同颜色的边框，可以先按工具栏右侧的“线条颜色”按钮，在随后弹出的调色板中选中需要的颜色后，再画边框即可。③这一功能还可以在单元格中画上对角的斜线。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十七、控制特定单元格输入文本的长度 　　你能想象当你在该输入四位数的单元格中却填入了一个两位数，或者在该输入文字的单元格中你却输入了数字的时候，Excel就能自动判断、即时分析并弹出警告，那该多好啊!要实现这一功能，对Excel来说，也并不难。 　　例如我们将光标定位到一个登记“年份”的单元格中，为了输入的统一和计算的方便，我们希望“年份”都用一个四位数来表示。所以，我们可以单击“数据”菜单的“有效性”选项。在“设置”卡片“有效性条件”的“允许”下拉菜单中选择“文本长度”。然后在“数据”下拉菜单中选择“等于”，且“长度”为“4”。同时，我们再来到“出错警告”卡片中，将“输入无效数据时显示的出错警告”设为“停止”，并在“标题”和“错误信息”栏中分别填入“输入文本非法!”和“请输入四位数年份。”字样。 　　很显然，当如果有人在该单元格中输入的不是一个四位数时，Excel就会弹出示的警告对话框，告诉你出错原因，并直到你输入了正确“样式”的数值后方可继续录入。神奇吧?其实，在Excel的“数据有效性”判断中，还有许多特殊类型的数据格式可选，比如“文本类型”啊，“序列大小”啊，“时间远近”啊，如你有兴趣，何不自作主张，自己设计一种检测标准，让你的Excel展示出与众不同的光彩呢。 　　十八、成组填充多张表格的固定单元格 　　我们知道每次打开Excel，软件总是默认打开多张工作表。由此就可看出Excel除了拥有强大的单张表格的处理能力，更适合在多张相互关联的表格中协调工作。要协调关联，当然首先就需要同步输入。因此，在很多情况下，都会需要同时在多张表格的相同单元格中输入同样的内容。 　　那么如何对表格进行成组编辑呢?首先我们单击第一个工作表的标签名“Sheet1”，然后按住Shift键，单击最后一张表格的标签名“Sheet3”(如果我们想关联的表格不在一起，可以按住Ctrl键进行点选)。此时，我们看到Excel的标题栏上的名称出现了“工作组”字样，我们就可以进行对工作组的编辑工作了。在需要一次输入多张表格内容的单元格中随便写点什么，我们发现，“工作组”中所有表格的同一位置都显示出相应内容了。 　　但是，仅仅同步输入是远远不够的。比如，我们需要将多张表格中相同位置的数据统一改变格式该怎么办呢?首先，我们得改变第一张表格的数据格式，再单击“编辑”菜单的“填充”选项，然后在其子菜单中选择“至同组工作表”。这时，Excel会弹出“填充成组工作表”的对话框，在这里我们选择“格式”一项，点“确定”后，同组中所有表格该位置的数据格式都改变了。 　　十九、改变文本的大小写 　　在Excel中，为表格处理和数据运算提供最强大支持的不是公式，也不是数据库，而是函数。不要以为Excel中的函数只是针对数字，其实只要是写进表格中的内容，Excel都有对它编辑的特殊函数。例如改变文本的大小写。 　　在Excel 2002中，至少提供了三种有关文本大小写转换的函数。它们分别是：“=UPPER(源数据格)”，将文本全部转换为大写；“=LOWER(源数据格)”，将文本全部转换成小写；“=PROPER(源数据格)”，将文本转换成“适当”的大小写，如让每个单词的首字母为大写等。例如，我们在一张表格的A1单元格中输入小写的“excel”，然后在目标单元格中输入“=UPPER(A1)”，回车后得到的结果将会是“EXCEL”。同样，如果我们在A3单元格中输入“mr.weiwei”，然后我们在目标单元格中输入“=PROPER(A3)”，那么我们得到的结果就将是“Mr.Weiwei”了。 　　二十、提取字符串中的特定字符 　　除了直接输入外，从已存在的单元格内容中提取特定字符输入，绝对是一种省时又省事的方法，特别是对一些样式雷同的信息更是如此，比如员工名单、籍贯等信息。 　　如果我们想快速从A4单元格中提取称谓的话，最好使用“=RIGHT(源数据格，提取的字符数)”函数，它表示“从A4单元格最右侧的字符开始提取2个字符”输入到此位置。当然，如果你想提取姓名的话，则要使用“=LEFT(源数据格，提取的字符数)”函数了。还有一种情况，我们不从左右两端开始，而是直接从数据中间提取几个字符。比如我们要想从A5单元格中提取“武汉”两个字时，就只须在目标单元格中输入“=MID(A5,4,2)”就可以了。意思是：在A5单元格中提取第4个字符后的两个字符，也就是第4和第5两个字。二十一、把基数词转换成序数词　　将英文的基数词转换成序数词是一个比较复杂的问题。因为它没有一个十分固定的模式：大多数的数字在变成序数词都是使用的“th”后缀，但大凡是以“1”、“2”、“3”结尾的数字却分别是以“st”、“nd”和“rd”结尾的。而且，“11”、“12”、“13”这3个数字又不一样，它们却仍然是以“th”结尾的。因此，实现起来似乎很复杂。其实，只要我们理清思路，找准函数，只须编写一个公式，就可轻松转换了。不信，请看：“=A2&amp;IF(OR(VALUE(RIGHT(A2,2))={11,12,13}),″th″,IF(OR(VALUE(RIGHT(A2))={1,2,3,},CHOOSE(RIGHT(A2),″st″,″nd″,″rd″),″th″))”。该公式尽管一长串，不过含义却很明确：①如果数字是以“11”、“12”、“13”结尾的，则加上“th”后缀；②如果第1原则无效，则检查最后一个数字，以“1”结尾使用“st”、以“2”结尾使用“nd”、以“3”结尾使用“rd”；③如果第1、2原则都无效，那么就用“th”。因此，基数词和序数词的转换实现得如此轻松和快捷。　　二十二、用特殊符号补齐位数　　和财务打过交道的人都知道，在账面填充时有一种约定俗成的“安全填写法”，那就是将金额中的空位补齐，或者在款项数据的前面加上“$”之类的符号。其实，在Excel中也有类似的输入方法，那就是“REPT”函数。它的基本格式是“=REPT(“特殊符号”，填充位数)”。　　比如，我们要在中A2单元格里的数字结尾处用“#”号填充至16位，就只须将公式改为“=(A2&amp;REPT(″#″,16-LEN(A2)))”即可；如果我们要将A3单元格中的数字从左侧用“#”号填充至16位，就要改为“=REPT(″#″,16-LEN(A3)))&amp;A3”；另外，如果我们想用“#”号将A4中的数值从两侧填充，则需要改为“=REPT(″#″,8-LEN(A4)/2)&amp;A4&amp;REPT(″#″)8-LEN(A4)/2)”；如果你还嫌不够专业，要在A5单元格数字的顶头加上“$”符号的话，那就改为：“=(TEXT(A5,″$#,##0.00″(&amp;REPT(″#″,16-LEN(TEXT(A5,″$#,##0.00″))))”，一定能满足你的要求。　　二十三、创建文本直方图　　除了重复输入之外，“REPT”函数另一项衍生应用就是可以直接在工作表中创建由纯文本组成的直方图。它的原理也很简单，就是利用特殊符号的智能重复，按照指定单元格中的计算结果表现出长短不一的比较效果。　　比如我们首先制作一张年度收支平衡表，然后将“E列”作为直方图中“预算内”月份的显示区，将“G列”则作为直方图中“超预算”的显示区。然后根据表中已有结果“D列”的数值，用“Wingdings”字体的“N”字符表现出来。具体步骤如下：　　在E3单元格中写入公式“=IF(D30,REPT(″n″,ROUND(D3*100,0)),″″)”，也拖动填充柄至G14。我们看到，一个没有动用Excel图表功能的纯文本直方图已展现眼前，方便直观，简单明了。　　二十四、计算单元格中的总字数　　有时候，我们可能对某个单元格中字符的数量感兴趣，需要计算单元格中的总字数。要解决这个问题，除了利用到“SUBSTITUTE”函数的虚拟计算外，还要动用“TRIM”函数来删除空格。比如现在A1单元格中输入有“how many words?”字样，那么我们就可以用如下的表达式来帮忙：　　“=IF(LEN(A1)=0,0,LEN(TRIM(A1))-LEN(SUBSTITUTE(TRIM(A1),″,″,″″))+1)”　　该式的含义是先用“SUBSTITUTE”函数创建一个新字符串，并且利用“TRIM”函数删除其中字符间的空格，然后计算此字符串和原字符串的数位差，从而得出“空格”的数量，最后将空格数+1，就得出单元格中字符的数量了。　　二十五、关于欧元的转换　　这是Excel 2002中的新工具。如果你在安装Excel 2002时选择的是默认方式，那么很可能不能在“工具”菜单中找到它。不过，我们可以先选择“工具”菜单中的“加载宏”，然后在弹出窗口中勾选“欧元工具”选项，“确定”后Excel 2002就会自行安装了。　　完成后我们再次打开“工具”菜单，单击“欧元转换”，一个独立的专门用于欧元和欧盟成员国货币转换的窗口就出现了。与Excel的其他函数窗口一样，我们可以通过鼠标设置货币转换的“源区域”和“目标区域”，然后再选择转换前后的不同币种即可。所示的就是“100欧元”分别转换成欧盟成员国其他货币的比价一览表。当然，为了使欧元的显示更显专业，我们还可以点击Excel工具栏上的“欧元”按钮，这样所有转换后的货币数值都是欧元的样式了。\n&nbsp;\n&nbsp;\n给电脑重做系统，自己学学，可少花钱，哈哈[图]一、准备工作: 如何重装电脑系统 首先，在启动电脑的时候按住DELETE键进入BIOS，选择 Advanced BIOS Features 选项，按Enter键进入设置程序。选择First Boot Device 选项，然后按键盘上的Page Up或Page Down 键将该项设置为CD-ROM，这样就可以把系统改为光盘启动。 其次，退回到主菜单，保存BIOS设置。（保存方法是按下F10，然后再按Y键即可） &nbsp;&nbsp;&nbsp;&nbsp;1.准备好Windows XP Professional 简体中文版安装光盘,并检查光驱是否支持自启动。 &nbsp;&nbsp;&nbsp;&nbsp;2.可能的情况下，在运行安装程序前用磁盘扫描程序扫描所有硬盘检查硬盘错误并进行修复，否则安装程序运行时如检查到有硬盘错误即会很麻烦。 &nbsp;&nbsp;&nbsp;&nbsp;3.用纸张记录安装文件的产品密匙(安装序列号)。 &nbsp;&nbsp;&nbsp;&nbsp;4.可能的情况下，用驱动程序备份工具(如:驱动精灵 2004 V1.9 Beta.exe)将原Windows XP下的所有驱动程序备份到硬盘上(如∶F:Drive)。最好能记下主板、网卡、显卡等主要硬件的型号及生产厂家，预先下载驱动程序备用。 &nbsp;&nbsp;&nbsp;&nbsp;5.如果你想在安装过程中格式化C盘或D盘(建议安装过程中格式化C盘)，请备份C盘或D盘有用的数据。 &nbsp;&nbsp;&nbsp;&nbsp;二、用光盘启动系统: &nbsp;&nbsp;&nbsp;&nbsp;(如果你已经知道方法请转到下一步),重新启动系统并把光驱设为第一启动盘,保存设置并重启。将XP安装光盘放入光驱,重新启动电脑。刚启动时，当出现如下图所示时快速按下回车键，否则不能启动XP系统光盘安装。如果你不知道具体做法请参考与这相同的--&gt;如何进入纯DOS系统: 光盘自启动后,如无意外即可见到安装界面 ,将出现如下图1所示 &nbsp;&nbsp;&nbsp;&nbsp; 查看原图 全中文提示,“要现在安装Windows XP,请按ENTER”，按回车键后,出现如下图2所示  查看原图 许可协议,这里没有选择的余地，按“F8”后如下图3  查看原图 这里用“向下或向上”方向键选择安装系统所用的分区，如果你已格式化C盘请选择C分区，选择好分区后按“Enter”键回车，出现下图4所示  查看原图 这里对所选分区可以进行格式化,从而转换文件系统格,或保存现有文件系统,有多种选择的余地,但要注意的是NTFS格式可节约磁盘空间提高安全性和减小磁盘碎片但同时存在很多问题MacOS和98/Me下看不到NTFS格式的分区,在这里选“用FAT文件系统格式化磁盘分区(快),按“Enter”键回车，出现下图5所示  查看原图 格式化C盘的警告,按F键将准备格式化c盘,出现下图6所示  查看原图 由于所选分区C的空间大于2048M(即2G),FAT文件系统不支持大于2048M的磁盘分区,所以安装程序会用FAT32文件系统格式对C盘进行格式化,按“Enter”键回车，出现下图7所示  查看原图 图7中正在格式化C分区;只有用光盘启动或安装启动软盘 启动XP安装程序,才能在安装过程中提供格式化分区选项；如果用MS-DOS启动盘启动进入DOS下,运行i386\\winnt进行安装XP时,安装XP时没有格式化分区选项。格式化C分区完成后,出现下图8所示  查看原图 图8中开始复制文件,文件复制完后，安装程序开始初始化Windows配置。然后系统将会自动在15秒后重新启动。重新启动后,出现下图9所示  查看原图 9  查看原图 过5分钟后，当提示还需33分钟时将出现如下图10  查看原图 区域和语言设置选用默认值就可以了，直接点“下一步”按钮，出现如下图11  查看原图 这里输入你想好的姓名和单位，这里的姓名是你以后注册的用户名，点“下一步”按钮，出现如下图12  查看原图 如果你没有预先记下产品密钥（安装序列号）就大件事啦！这里输入安装序列号，点“下一步”按钮，出现如下图13  查看原图 安装程序自动为你创建又长又难看的计算机名称,自己可任意更改，输入两次系统管理员密码，请记住这个密码，Administrator系统管理员在系统中具有最高权限，平时登陆系统不需要这个帐号。接着点“下一步”出现如下图14  查看原图 日期和时间设置不用讲,选北京时间，点“下一步”出现如下图15  查看原图 开始安装,复制系统文件、安装网络系统，很快出现如下图16  查看原图 让你选择网络安装所用的方式，选典型设置点“下一步”出现如下图17  查看原图 点“下一步”出现如下图18  查看原图 继续安装，到这里后就不用你参与了，安装程序会自动完成全过程。安装完成后自动重新启动，出现启动画面，如下图19  查看原图 第一次启动需要较长时间，请耐心等候，接下来是欢迎使用画面，提示设置系统，如下图20  查看原图 点击右下角的“下一步”按钮，出现设置上网连接画面，如下图21所示  查看原图 点击右下角的“下一步”按钮，出现设置上网连接画面，如下图21所示  查看原图 这里建立的宽带拨号连接,不会在桌面上建立拨号连接快捷方式,且默认的拨号连接名称为“我的ISP”(自定义除外);进入桌面后通过连接向导建立的宽带拨号连接,在桌面上会建立拨号连接快捷方式,且默认的拨号连接名称为“宽带连接”(自定义除外)。如果你不想在这里建立宽带拨号连接,请点击“跳过”按钮。 &nbsp;&nbsp;&nbsp;&nbsp;在这里我先创建一个宽带连接,选第一项“数字用户线(ADSL)或电缆调制解调器”,点击“下一步”按钮，如下图22所示  查看原图 目前使用的电信或联通(ADSL)住宅用户都有帐号和密码的,所以我选“是,我使用用户名和密码连接”,点击“下一步”按钮，如下图23所示  查看原图 输入电信或联通提供的帐号和密码,在“你的ISP的服务名”处输入你喜欢的名称,该名称作为拨号连接快捷菜单的名称,如果留空系统会自动创建名为“我的ISP”作为该连接的名称,点击“下一步”按钮，如下图24所示  查看原图 已经建立了拨号连接,微软当然想你现在就激活XP啦,不过即使不激活也有30天的试用期,又何必急呢?选择“否,请等候几天提醒我”,点击“下一步”按钮，如下图25所示  查看原图 输入一个你平时用来登陆计算机的用户名，点下一步出现如下图26  查看原图 点击完成，就结束安装。系统将注销并重新以新用户身份登陆。登陆桌面后如下图27  查看原图 六、找回常见的图标 &nbsp;&nbsp;&nbsp;&nbsp;在桌面上点开始--&gt;连接到--&gt;宽带连接，如下图32  查看原图 左键点“宽带连接”不放手，将其拖到桌面空白处,可见到桌面上多了一个“宽带连接”快捷方式。结果如下图33  查看原图 然后，右键在桌面空白处点击，在弹出的菜单中选“属性”，即打开显示“属性窗口”如下图34  查看原图 在图中单击“桌面”选项卡，出现如下图35  查看原图 在图中的左下部点击“自定义桌面”按钮，出现如下图36  查看原图 在图中的上部，将“我的文档”、“我的电脑”、“网上邻居”和“Internet Explorer”四个项目前面的空格上打钩，然后点“确定”，再“确定”，你将会看到桌面上多了你想要的图标。如下图37 \n&nbsp;\n\n\n        ', null);
INSERT INTO `blog` VALUES ('102', '清华大学计算机全套教程！【学电脑的人都分享吧，包含全部计算机知识，点击即可进入】', '\n            \n \n\n 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　\n\n        ', null);
INSERT INTO `blog` VALUES ('103', 'Word，PDF，PPT，TXT之间的转换方法（好东西，以后整理课件就不会那么麻烦了。。。）', '\n            \n \n\n一、把PPT转WORD形式的方法　1．利用&quot;大纲&quot;视图　　打开PPT演示文稿，单击&quot;大纲&quot;，在左侧&quot;幻灯片/大纲”任务窗格的“大纲”选项卡里单击一下鼠标，按&quot;Ctrl+A&quot;组合健全选内容，然后使用&quot;Ctrl+C&quot;组合键或右键单击在快捷菜单中选择&quot;复制&quot;命令，然后粘贴到Word里。提示：这种方法会把原来幻灯片中的行标、各种符号原封不动的复制下来。　　2．利用&quot;发送&quot;功能巧转换　打开要转换的PPT幻灯片，单击&quot;文件&quot;→&quot;发送&quot;→&quot;MicrosoftWord&quot;菜单命令。然后选择&quot;只使用大纲&quot;单选按钮并单击&quot;确定&quot;按钮，等一会就发现整篇PPT文档在一个Word文档里被打开。　提示：　在转换后会发现Word有很多空行。在Word里用替换功能全部删除空行可按&quot;Ctrl+H&quot;打开&quot;替换&quot;对话框，在&quot;查找内容&quot;里输入&quot;^p^p&quot;，在&quot;替换为&quot;里输入&quot;^p&quot;，多单击几次&quot;全部替换&quot;按钮即可。(&quot;^&quot;可在英文状态下用&quot;Shift+6&quot;键来输入。)3．利用&quot;另存为&quot;直接转换　　　　打开需要转换的幻灯片，点击&quot;文件&quot;→&quot;另存为&quot;，然后在&quot;保存类型&quot;列表框里选择存为&quot;rtf&quot;格式。现在用Word打开刚刚保存的rtf文件，再进行适当的编辑即可实现转换。　　4．PPTConverttoDOC软件转换　PPTConverttoDOC是绿色软，解压后直接运行，在运行之前请将Word和PPT程序都关闭。选中要转换的PPT文件，直接拖曳到&quot;PPTConverttoDOC&quot;程序里。单击工具软件里的&quot;开始&quot;按钮即可转换，转换结束后程序自动退出。　　　　提示：　　如果选中&quot;转换时加分隔标志&quot;，则会在转换好的word文档中显示当前内容在原幻灯片的哪一页。转换完成后即可自动新建一个Word文档，显示该PPT文件中的所有文字。ps：第四种慎用,百度上很多所谓的那个软件都是有病毒的,毒性不小,一般的杀毒软件查不出~~PDF文档的规范性使得浏览者在阅读上方便了许多，但倘若要从里面提取些资料，实在是麻烦的可以。二、把PDF转换成Word的方法Adobe Acrobat 7.0 Professional 是编辑PDF的软件。用Adobe Acrobat 7.0 Professional 打开他另存为WORD试试看。或者用ScanSoft PDF Converte，安装完成后不须任何设置，它会自动整合到Word中。当我们在Word中点击“打开”菜单时，在“打开”对话框的“文件类型”下拉菜单中可以看到“PDF”选项，这就意味着我们可以用Word直接打开PDF文档了!ScanSoft PDF Converter的工作原理其实很简单，它先捕获PDF文档中的信息，分离文字、图片、表格和卷，再将它们统一成Word格式。由于Word在打开 PDF文档时，会将PDF格式转换成DOC格式，因此打开速度会较一般的文件慢。打开时会显示PDF Converter转换进度。转换完毕后可以看到，文档中的文字格式、版面设计保持了原汁原味，没有发生任何变化，表格和图片也完整地保存下来了，可以轻松进行编辑。除了能够在Word中直接打开PDF文档外，右击PDF文档，在弹出菜单中选择“Open PDF in Word”命令也可打开该文件。另外，它还会在Outlook中加入一个工具按钮，如果收到的电子邮件附件中有PDF文档，就可以直接点击该按钮将它转换成Word文件。有时我们在网上搜索到PDF格式的文件，同样可以通过右键菜单的相关命令直接在Word中打开它。 三、Word转换成PPT的方法我们通常用Word来录入、编辑、打印材料，而有时需要将已经编辑、打印好的材料，做成PowerPoint演示文稿，以供演示、讲座使用。如果在PowerPoint中重新录入，既麻烦又浪费时间。如果在两者之间，通过一块块地复制、粘贴，一张张地制成幻灯片，也比较费事。其实，我们可以利用PowerPoint的大纲视图快速完成转换。首先，打开Word文档，全部选中，执行“复制”命令。然后，启动PowerPoint，如果是Word 2002版，选择“普通”视图，单击“大纲”标签（如图1）；如果没有“大纲”和“幻灯片”选项卡，显示的方法是在“视图”菜单上，单击“普通（恢复窗格）”或在窗口的左下角，单击〔普通视图（恢复窗格）〕按钮；如果是Word 97/2000版，可直接选择“大纲”视图，将光标定位到第一张幻灯片处，执行“粘贴”命令，则将Word文档中的全部内容插入到了第一幻灯片中。接着，可根据需要进行文本格式的设置，包括字体、字号、字型、字的颜色和对齐方式等；然后将光标定位到需要划分为下一张幻灯片处，直接按回车键，即可创建出一张新的幻灯片；如果需要插入空行，按〔Shift+Enter〕。经过调整，很快就可以完成多张幻灯片的制作（如图2）。最后，还可以使用“大纲”工具栏，利用“升级”、“降级”、“上移”、“下移”等按钮进一步进行调整。反之，如果是将PowerPoint演示文稿转换成Word文档，同样可以利用“大纲”视图快速完成。方法是将光标定位在除第一张以外的其他幻灯片的开始处，按〔BackSpace〕（退格键），重复多次，将所有的幻灯片合并为一张，然后全部选中，通过复制、粘贴到Word中即可。四、将PDF转换成TXT的方法方法一： 用以上方法将PDF转DOC，再用WORD将DOC转TXT 方法二：用PDF2TXT 3.1汉化版 PDF2TXT 3.1汉化版可以快速把.pdf文件转换为.txt或.htm(.html)文件的小工具.操作简单,快捷注：Adobe Acrobat Reader6.0以上版本可以直接把PDF文件另存为txt文件。 五、PDF转BMP 方法一：用PDFTOOLS PDF是Adobe公司开发的作为全世界可移植电子文档的通用格式，它能够正确保存源文件的字体、格式、颜色和图片，使文件的交流可以轻易跨越应用程序和系统平台的限制。但是，一些文档的特殊操作（如提取PDF文档中的一段文字或图片）对于一般用户来说，不是那么容易上手的。不过现在有了PDFTools这款神奇工具后，你就可以轻松地把PDF文档的内容转换成HTM、TXT和BMP这三种常用的文件格式。 为了PDFTools能更好地为我们服务，我们首先得对它进行一番设置。在主界面中点击菜单“文件→设置”或直接按“Ctrl＋D”组合键调出设置对话框。在“常规设置”标签页中设置页面的转换范围，默认为全部转换，你可以点击下拉按钮，选择“选择指定页”后，输入转换的起始页和停止页。未注册版本只能转换PDF文档的前五页内容。 “输出设置”框的内容是设置输入图片的像素和JPEG图片质量。选中“转换后浏览”的复选框，那么当文档转换完成后，程序就会调出对应程序打开转换后的文件。“PDF2HTM”标签页只有一“使用完全处理模式”复选框，依实际情况决定。六、PDF转HTM 的方法 HTM是网页的通用格式，但PDFTools转换HTM文件后，所形成的HTM文件并不包含有PDF文档中的文字，而是将PDF文档的内容转换成JPG图像文件，然后再用HTML语言将图片嵌入到网页中。生成的HTM文件是一个框架网页，即左边是各页面的链接窗口，右边的内容就是JPG图片了。如果你用的是IE6的话，当鼠标移到右边窗口后，就会浮出一排快捷工具栏。 首先选择菜单“工具→PDF转HTM”，使其转为HTM模式。接着打开文件有多种操作方式：通过菜单“文件→打开”直接按“Ctrl＋F”键后调出打开对话框选择文件，或者直接把待转换的PDF文档拖到PDFTools主界面中，软件马上开始转换。转换后的文件是保存在源文件中，而且还有相应名称的子文件夹，里面就是一些JPG图片和其它资源。最后弹出一个提示窗口，点击“确定”即可。 \n\n        ', null);
INSERT INTO `blog` VALUES ('104', 'C++练习', '\n            \n \n#include &lt;iostream.h&gt;\nclass CBase1\n{\nprotected:\n int b;\npublic:\n CBase1(int x=0)\n {\n b=x;\n cout &lt;&lt; &quot;Construct CBase1!&nbsp;&nbsp;&quot; &lt;&lt; b &lt;&lt;endl;\n }\n ~CBase1()\n {\n cout &lt;&lt; &quot;Destruct CBase1!&nbsp;&nbsp;&quot; &lt;&lt; b &lt;&lt;endl;\n }\n};\n\nclass CBase2\n{\nprotected:\n int b;\npublic:\n CBase2(int x=0)\n {\n b=x;\n cout &lt;&lt; &quot;Construct CBase2!&nbsp;&nbsp;&quot; &lt;&lt; b &lt;&lt;endl;\n }\n ~CBase2()\n {\n cout &lt;&lt; &quot;Destruct CBase2!&nbsp;&nbsp;&quot; &lt;&lt; b &lt;&lt;endl;\n }\n};\n\nclass CDerived : public CBase1,private CBase2\n{\nprotected:\n CBase1 b1;\n CBase2 b2;\n int d;\npublic:\n CDerived(int x,int y, int z):b1(y),CBase2(y),b2(z),CBase1(x)\n {\n d=z;\n cout &lt;&lt; &quot;Construct CDerived!&nbsp;&nbsp;&quot; &lt;&lt; d &lt;&lt;endl;\n }\n ~CDerived()\n {\n cout &lt;&lt; &quot;Destruct CDerived!&nbsp;&nbsp;&quot; &lt;&lt; d &lt;&lt;endl;\n }\n};\n\nvoid main()\n{\n CDerived d1(1,2,3);\n}\n\n\n        ', null);
INSERT INTO `blog` VALUES ('105', '电脑配置（超详细的电脑常识', '\n            \n \n电脑配置（超详细的电脑常识） 2010/04/04 22:15\n \n电脑的配置，主要看CPU、显卡、主板、内存、硬盘、显示器等，而笔记本的话就看它的品牌就行了。国外的有HP、apple、松下、东芝等，不过顾客口碑和质量比较硬的是DELL和HP这两个品牌；国产的有：宏基、清华紫光、清华同方、神州、海尔、联想、八亿时空等。 \n\n评价标准\n\n1、CPU，这个主要取决于频率和二级缓存，频越高、二级缓存越大，速度越快，未来CPU会有三级缓存、四级缓存等，都影响响应速度。 \n\n\n　　2、内存，内存的存取速度取决于接口、颗粒数量多少与储存大小（包括内存的接口,如：SDRAM133，DDR233，DDR2-533，DDR3-800），一般来说，内存越大，处理数据能力越强，速度就越快。 \n\n\n　　3、主板，主要还是处理芯片，如：笔记本i965比i945芯片处理能力更强，i945比i910芯片在处理数据的能力又更强些，依此类推。 \n\n\n　　4、硬盘，硬盘在日常使用中，考虑得少一些，不过也有是有一些影响的，首先，硬盘的转速（分：高速硬盘和低速硬盘，高速硬盘一般用在大型服务器中，如：10000转，15000转；低速硬盘用在一般电脑中，包括笔记本电脑），台式机电脑一般用7200转，笔记本电脑一般用5400转，这主要是考虑功耗和散热原因。 \n\n\n　　硬盘速度又因接口不同，速率不同，一般而言，分IDE和SATA（也就是常说的串口）接口，早前的硬盘多是IDE接口，相比之下，存取速度比SATA接口的要慢些。 \n\n\n　　硬盘也随着市场的发展，缓存由以前的2M升到了8M或更大，就像CPU一样，缓存越大，速度会快些。 \n\n\n　　5、显卡：这项对运行超大程序软件的响应速度有着直接联系，如运行CAD2007，3DStudio、3DMAX等图形软件。显卡除了硬件级别上的区分外，也有“共享显存”技术的存在，和一般自带显存芯片的不同，就是该“共享显存”技术，需要从内存读取显存，以处理相应程序的需要。或有人称之为：动态显存。这种技术更多用在笔记本电脑中。 \n\n\n　　6、电源，这个只要功率足够和稳定性好，也就OK啦。 \n\n\n　　7、显示器：显示器与主板的接口也一样有影响，只是人们一般没有太在乎（请查阅显示设备相关技术资料）。\n\n软件方面\n\n　　1、操作系统：简单举个例子说明一下：电脑的同等配置，运行原版Windows 98肯定比运行原版Windows XP要快，而原版XP肯定又比运行原版的Windows Vista速度要快，这就说明，同等配置情况下，软件占用的系统资源越大，速度越慢，反之越快。 \n\n\n　　还有，英文原版的操作系统运行英文版程序比运行中文版的程序稳定性及速度都有是关系的。\n\n所以，这里特别强调是原版的系统，也就是没有精简过的系统。同理，精简过的Windows XP一般来说，会比原版的XP速度快些，因为精简掉一些不常用的程序，占用的系统资源少了，所以速度有明显提升。 \n\n\n　　2、软件（包括硬件）都可以适当优化，以适合使用者，如：一般办公文员，配置一般的电脑，装个精简版的XP和精简版的Office 2003就足以应付日常使用了。但如果是图形设计人员，就需要专业的配置，尤其对显卡的要求，所以，升级软件：Microsoft DirectX 9.0 或以上版本是很有必要的。\n\n哪些能软件查看电脑配置：\n\n\n　　1、EVEREST\n\n\n　　2、鲁大师+优化大师\n\n\n　　3、硬件快捕\n\n\n　　4、cpu-z\n\n\n　　5、gpu-z\n\n\n　　新版本都支持最新的酷睿i5、酷睿i7等新品\n\n详细配置\n\nCPU\n\n主流桌面级CPU厂商主要有INTEL和AMD两家。Intel平台的低端是赛扬和奔腾系列，高端是酷睿2（已成功代替酷睿1）09年作为下一代更先进的CPU I7也上市了，在此不久后32NM6核心I9也可能于2011年上市。 \n\n\n　　AMD平台的低端是闪龙，高端是速龙，皓龙。最常用的是两者的中低端。INTEL处理器方面，在中高端有e7400，可以搭配频率更高的DDR2内存，这一点是AMD中高端平台中难以实现的。AMD64bitSP2500+虽然超值，但缺少了对内存双通道的支持，这一点让许多玩家感觉不爽。\n\n\n　　Intel和AMD 市面上的主流配置有两种。一种是Intel配置一种是AMD配置。其主要区别在于cpu的不同，顾名思义Intel配置的cpu是Intel品牌的，AMD配置的cpu是AMD品牌的。产品的市场定位和性能基本相同。价格不同，主要性能倾向有所区别。可根据需要和价位而定。\n\n主板配置\n\n常用的比较好的牌子其实不止intel，华硕(ASUS)、技嘉(GIGABYTE)、精英(ECS)、微星(MSI)、磐正(EPOX)、双敏(UNIKA)、映泰(BIOSTAR)、硕泰克(SOLTEK)、捷波(JETWAY)、钻石(DFI)这些,还有一些二线牌子象斯巴达克这些也比较好。\n\n内存配置 常用内存条有3种型号：一）SDRAM的内存金手指（就是插入主板的金色接触部分）有两个防呆缺口，168针脚。SDRAM的中文含义是“随机动态储存器”。二）DDR的内存金手指只有一个防呆缺口，而且稍微偏向一边，184针脚。DDR中文含义是“双倍速率随机储存器”。三）DDR2的内存金手指也只有一个防呆缺口，但是防呆缺口在中间，240针脚。DDR2SDRAM内存的金手指有240个接触点。　　 \n存条2009年最新的内存已经升级到DDR3代，DDR3内存向DDR2内存兼容，同样采用了240针脚，DDR3是8bit预取设计，而DDR2为4bit预取，这样DRAM内核的频率只有接口频率的1/8，DDR3-800的核心工作频率只有100MHz。主流DDR3的工作频率是1333MHz。在面向64位构架的DDR3显然在频率和速度上拥有更多的优势，此外，由于DDR3所采用的根据温度自动自刷新、局部自刷新等其它一些功能，在功耗方面DDR3也要出色得多。一线内存品牌厂家均推出了自己的DDR3内存，如金士顿、宇瞻、威刚、海盗船、金邦等。在价格上，DDR3的内存仅比DDR2高出几十块，在内存的发展道路上，DDR3内存的前途无限。 硬盘配置 硬盘按接口来分：PATA这是早先的硬盘接口，2009年新生产的台式机里基本上看不到了；SATA这是主流的接口也就是平常说的串行接口，市面上的硬盘普遍采用这种接口；SATAII这是SATA接口的升级版，市面上这种硬盘有是也有，就是不多，主要就是缓存和传输速度的提高；SCSI这是一种在服务器中采用的硬盘接口，它的特点是转动速度快可以达到10000转，这样读写速度就可以加快而且还支持热插拔。 显卡配置 显卡作为电脑主机里的一个重要组成部分，对于喜欢玩游戏和从事专业图形设计的人来说显得非常重要。民用显卡图形芯片供应商主要包括ATI和nVIDIA两家。 　　显卡的基本构成 　　GPU 　　全称是Graphic Processing Unit，中文翻译为&quot;图形处理器&quot;。NVIDIA公司在发布GeForce 256图形处理芯片时 \n笔记本电脑首先提出的概念。GPU使显卡减少了对CPU的依赖，并进行部分原本CPU的工作，尤其是在3D图形处理时。GPU所采用的核心技术有硬件T&amp;l、立方环境材质贴图和顶点混合、纹理压缩和凹凸映射贴图、双重纹理四像素256位渲染引擎等，而硬件T&amp;l技术可以说是GPU的标志。 　　显示卡 　　显示卡（Display Card）的基本作用就是控制计算机的图形输出，由显示卡连接显示器，才能够在显示屏幕上看到图象，显示卡有显示芯片、显示内存、RAMDAC等组成，这些组件决定了计算机屏幕上的输出，包括屏幕画面显示的速度、颜色，以及显示分辨率。显示卡从早期的单色显示卡、彩色显示卡、加强型绘图显示卡，一直到VGA(Video Graphic Array)显示绘图数组，都是由IBM主导显示卡的规格。VGA在文字模式下为720*400分辨率，在绘图模式下为640*480*16色，或320*200*256色，而此256色显示模式即成为后来显示卡的共同标准，因此通称显示卡为VGA。而后来各家显示芯片厂商更致力把VGA的显示能力再提升，而有SVGA（SuperVGA）、XGA（eXtended Graphic Array）等名词出现，显示芯片厂商更把3D功能与VGA整合在一起， 即成为所贯称的3D加速卡，3D绘图显示卡。 　　像素填充率 　　像素填充率的最大值为3D时钟乘以渲染途径的数量。如NVIDIA的GeForce 2 GTS芯片，核心频率为200 MHz，4条渲染管道，每条渲染管道包含2个纹理单元。那么它的填充率就为4x2像素x2亿/秒=16亿像素/秒。这里的像素组成了在显示屏上看到的画面，在800x600分辨率下一共就有800x600=480，000个像素，以此类推1024x768分辨率就有1024x768=786，432个像素。在玩游戏和用一些图形软件常设置分辨率，当分辨率越高时显示芯片就会渲染更多的像素，因此填充率的大小对衡量一块显卡的性能有重要的意义。上面计算了GTS的填充率为16亿像素/秒，再看看MX200。它的标准核心频率为175，渲染管道只有2条，那么它的填充率为2x2 像素x1.75亿/秒=7亿像素/秒，这是它比GTS的性能相差一半的一个重要原因。 　　 \n\n显存 \n\n　　显示内存的简称。顾名思义，其主要功能就是暂时储存显示芯片要处\n\n理的数据和处理完毕的数据。图形核心的性能愈强，需要的显存也就越多。以前的显存主要是SDR的，容量也不大。而市面上基本采用的都是DDR规格的，在某些高端卡上更是采用了性能更为出色的DDRII或DDRIII代内存(DDRIII已不是更为出色的,而是最差的那种了)。 \n\n\n　　两大接口技术 \n\n\n　　AGP接口 \n\n\n　　Accelerate Graphical Port是Intel公司开发的一个视频接口技术标准, 是为了解决PCI总线的低带宽而开发的接口技术。它通过把图形卡与系统主内存连接起来，在CPU和图形处理器之间直接开辟了更快的总线。其发展经历了AGP1.0(AGP1X/2X)、AGP2.0(AGP4X)、AGP3.0(AGP8X)。最新的AGP8X其理论带宽为2.1Gbit/秒。 \n\n\n　　PCI Express接口 \n\n\n　　PCI Express是新一代的总线接口，而采用此类接口的显卡产品，已经在2004年正式面世。早在2001年的春季“英特尔开发者论坛”上，英特尔公司就提出了要用新一代的技术取代PCI总线和多种芯片的内部连接，并称之为第三代I/O总线技术。随后在2001年底，包括Intel、AMD、DELL、IBM在内的20多家业界主导公司开始起草新技术的规范，并在2002年完成，对其正式命名为PCI Express。理论速度达10Gbit以上,如此在的差距,AGP已经被PCIE打击的差不多了,但是就像PCI取代ISA一样,它需要一定的时间，而且必须是915以上的北桥才支持PCIE，所以，可以预见PCIE取代AGP还需好长时间。\n显示器\n\n　　市面上有纯屏显示器和液晶显示器两种。随着液晶显示器的价格下降，已经成为显 \n显示器\n\n示器的主流种类。常见的液晶显示器有19寸、21寸、22寸、24寸等。价格不一，性能差别很大。可根据需要和价位而定。\n\n\n　　好坏大部分看\n\n\n　　1)亮度\\对比度. 常用500NIT,对比度1000左右. \n\n\n　　2)可视角.IPS屏水平和垂直都可达到178度. \n\n\n　　3)是否有亮点\\坏点\\全黑是否有漏光. \n\n\n　　4)背光均不均匀. \n\n\n　　5)功耗. 单屏功耗包括逻辑板部分和背光部分.\n\n电脑配置注意事项\n\n\n电脑真正开始进入平常百姓家，对于电脑，DIY是一个很不错的选择，但是对于初接触电脑的朋友来说， \n双核笔记本电脑\n\n组装电脑是一个很复杂的事情，其实组装电脑并不复杂，真正复杂的是选择电脑的配置，对于组装电脑的原则，应秉承“适用为好”的原则，因为想追求最好配置，永远也不会追上！下面为大家讲解电脑配置选择过程中应当注意的五点！\n\n\n　　第一，关于电源。作为所有主机硬件“耗电”的供电“单位”，电源选配至关重要（不少人对此并不重视）：功率小了绝对不行（小马拉大车，后果不言自明）；功率大点当是最佳选择（留有余地，但也不是越大越好）。切忌：按照硬件“耗电”之和“严丝合缝”匹配电源，这是靠不住的（一旦某个硬件耗电增加，就会立马“掉闸”）。\n\n\n　　第二，关于主板。就攒机而言，低限要求应当支持64位双核CPU，支持主流SATA硬盘，支持内存二代产品。有的主板虽然也是最新产品，但是并不支持“SATA-II”（SATA硬盘有“I”和“II”之分）。如若选配安装了“SATA-II”，那么就不能在这样的主板（南桥芯片）上开启“AHCI模式”，只能运行于“IDE模式”之下。\n\n\n　　第三，关于内存。五年前的品牌机，256M和512M内存是主流配置。当时不是不能高配，而是厂家不想配（那时内存价格昂贵，高配就会加大成本影响竞争）。有鉴于此，建议把内存增加到512M x 2或1G x 2（双通道），这样就可流畅运行Windows 7。另外，就普通用户（包括游戏玩家）来说，内存配至4-8G似无必要，尽管内存降到了“白菜价”。\n\n\n　　第四，关于显卡。多数品牌台式机配置的是“集成显卡”。尽管最新主板依然延续了显卡“集成”，但显卡性能多数并未得以提升：1、在高分辨率和刷新率情况下会出现“闪屏”；2、对于运行大型3D游戏“难以胜任”；3、不支持Windows Vista / Windows 7的Aero特效。因此，建议在组装或改装电脑主机时配置“独立显卡”；4、但是AMD的780系列主板的出现改变了这一切，板载的HD3200可运行AERO特效和硬件加速（但是在经济能力许可的情况下还是选择独立显卡）。\n\n\n　　第五，关于CPU。抛开五年前主流配置“奔4”不说，组装电脑应当首选64位双核CPU（立足当前、着眼长远），不要沿袭传统观念选配32位、单核的。至于CPU“外频”与内存频率的“严丝合缝”，那是“攒机玩家”需要捉摸的“精益求精”，就绝大多数用户组装电脑来说，可以忽略不计。\n\n电脑配置网购攒机主要的四种购买方式\n\n\n第一种是网店购买，优势是价格极为便宜，远低于实体店，也是所有购买方式中最便宜的，适合购买中高档，与实体店差价过大的产品。缺点是低端廉价产品经常出现质量问题，或者实物与照片不符的现象。主要网站有，淘宝，拍拍，百度有啊，阿里巴巴等。\n\n\n　　第二种是网络商城，优势是产品质量不错，价格也低于实体店，但是略高于网店，最重要的优势是能够分期付款，适合刷卡一族用户购买。缺点是付货速度较慢，维修返厂有中转耽误时间。主要网站有，京东商城，新蛋网，红孩子网上商城，F7NET分期网等。\n\n\n　　第三种是官网直接购买，优势是产品质量极高，售后保障最全面，完全不用担心买到水货的问题，适合对产品质量要求很高的用户采用。缺点是价格往往比实体店还要贵不少。主要网站有，三星，LG，明基，戴尔等。\n\n\n　　第四种是团购，优势是价格极低，厂商利润非常少，由于团购是与厂商直接挂钩，因此产品售后保障也完全不是问题，是所有网购中最实惠的一种。缺点是产品样式稀少，无法满覆盖所有用户群体。主要网站有，IT168论坛团购，新浪团购等。\n\n\n　　因此要想买到真正超值的产品，一定要合理选择一个适合自己的网购方式，才能保证利益最大化。如果准备攒一台高配置电脑的话，一般推荐采用网络商城分期付款方式；低配电脑推荐采用网店购买方式；主流配置电脑推荐采用团购方式（基本上主流配置的硬件产品，团购都能买到）；对电脑质量要求很高的用户推荐采用官网直接购买的方式。如何查看电脑配置 \n\n\n　　如果想看看自己电脑的配置，那就单击“开始”→“程序”→“附件”→“系统工具”→“系统信息”里面包括硬件版本，性能指数，软件版本信息等，都在里面了。\n\n\n　　一般来讲，电脑的速度的响应并不能说某单个硬件对它的影响，它们之间需要相互匹配（下同此理），当然，硬件占主要因素，二是软件的优化设置方案推荐\n\n2009年3500元超值电脑配置装机方案推荐据悉，大部分学生的装机预算都在3000元左右，其中，不怎么玩游戏的学生都会选择集成平台+准19&nbsp;&nbsp;&nbsp; 2009年3500元超值配置推 屏LCD，预算大概在2800元左右；而喜欢玩一些游戏，而且不想自己的配置太快过时的同学，则会选择3500元左右的预算，采用主流双核CPU+主流显卡的搭配，以此得到更好的游戏性能。推荐一套3500元的主流配置，其特点就是性价比突出，游戏性能出众，非常适合学生使用。 　　对于学生而言，电脑与其说是工作工具，不如说是娱乐工具更恰当一些。毕竟在大学宿舍里，唯一可以依靠的，就是这部电脑了。所以电脑的游戏性能自然是非常重要的。在这个前提下，显卡的选择尤其显得非常重要。在这里推荐的是这款映众（Inno3D）9600GT冰龙版，2009年9月报价为599元，是市场上所见到的配置最出色的9600GT显卡。　　映众（Inno3D）iChiLL冰龙9600GT采用NVIDIA最新的55nn节能版G94核心，核心代号为G94-350-B1。与普通版相比，节能版的G94核心拥有高性能低功耗的特色，在为玩家提供强劲游戏性能的同时，还保持了显卡较低的功耗以及发热量。显卡支持DirectX10和Shader Model4.0特效，并完整支持NVIDIA CUDA运算技术和PhysX物理加速技术，具备PureVideo HD II的视频解码引擎，可以对H.264编码的主流高清视频实现硬件解码。　　显存部分，映众（Inno3D）iChill冰龙9600GT采用的是海力士1.0ns显存颗粒，一共八颗组成了512M/256Bit的规格，由于采用了高性能的P562 六层PCB板，因此其默认频率设定也达到了670/2000MHz的史上最强水准。从此前媒体的评测来看，冰龙9600GT可以轻松超到700/2600MHz以上，性能完全超越HD4830！散热方面映众（Inno3D）iChill冰龙9600GT采用的是倍受玩家好评的FreezerX散热器。FreezerX散热器采用了密集的散热鳍片设计，满满覆盖了整张显卡，同时散热器还配备了两根加粗热管，并通过DHT（热管直触技术），可以及时把热量从核心迅速带到鳍片上再发散出去。　　除了好显卡之外，好的CPU自然也是不可或缺的。在这里推荐的是这款Intel Pentium E5300/盒装，2009年9月报价不过是495元，性价比已经超过了经典的E5200。虽然E6300的呼声很高，不过价格还是有些高，而且对于普通的用户而言，E5300的表现并不比E6300弱。　　主板部分，秉承稳定就好的原则，毕竟对于大部分学生而言，很多人其实都不会考虑超频，因此只需要采用稳定性较好的产品就可以了。在这里采用的是捷波X-BLUEP43，P43与P45的性能差距并不大，相比之下，P43更具性价比，因此更适合学生采用。　　内存方面采用的是金士顿2G DDR2 800，对于一般的用户来说是足够的。而且2009年是DDR2到DDR3的过渡年，因此暂时不需要考虑买2根，可以再根据市场的变化而定。硬盘则是采用500G硬盘，性价比非常出色。　　显示器部分采用的是长城M2231，2009年9月LCD价格飙升，大家都有些难已下手。不过这款长城M2231依然保持999元的报价，性价比已经非常出色了。不过很多商家不肯包点，大家在购买的时候一定要问清楚。　　配置点评：采用映众（Inno3D）iChiLL冰龙9600GT+Intel E5300这套配置最大的特色。高频的映众（Inno3D）iChiLL冰龙9600GT在性能表现方面与9800GT已经相差无几，难得却保持599元的超低价；而E5300也拥有非常不错的娱乐性能，两者相加，可以满足大部分3D游戏的需求。对于开学装备装机的学生而言，绝对是最佳之选。 4000元超值电脑配置装机方案推荐 2009年9月，新的学期已经开始，许多学生用户想在新的学期里攒一台性价比高、性能优越的PC　　 4000元超值装机方案推荐一览表 　　机。从2009年DIY市场反映情况来看，Intel 奔腾双核 E5200处理器仍然占据了性价机型中的绝大多数位置，同时为了超爽体验主流游戏的刺激和高清画面，配备96GSO系列独立显卡和22寸LCD成为了最热门的攒机方案之一。孟子说过：“鱼，我所欲也，熊掌，亦我所欲也；二者不可得兼”。下面配置是一套性价比与性能优越兼得的一套整机，整套配置售价只有4050元。　　主板选择微星 G41TM-E43，它不仅提供了豪华的全固态电容设计，还提供了微星独家的“易超频”按键及APS动态相变节能技术，另外主板还支持蓝光音效，一线的品质，低廉的价格，是组建HTPC平台的最佳选择。 显卡除了太阳花 9600GSO/384M/DDR3(I-DSSIII)变频王外，还有几款可供大家选择的9600GSO。　　在追求完美性能的同时加上超高的性价比这是为广大学生用户推荐整套配置的核心思想。也就是“鱼，我所欲也，熊掌，亦我所欲也；二者可以得兼”。这套配置强劲的微星G41TM-E43主板，超大的显示器配上市场主流的太阳花9600GSO(I-DSS)变频王显卡， 4050元的价格享受高端主流配置对于一直追求性价比的学生用户来说，绝对是超值之选。\n\n\n类别：Computer |\n |\n添加到搜藏 |\n分享到i贴吧 | 浏览(\n19) |\n评论&nbsp;(0) &nbsp; 上一篇：\n一代枭雄：大陆首富宗庆后&nbsp;&nbsp;&nbsp;&nbsp;下一篇：\nLED显示屏死灯问题 &nbsp; 最近读者：\n\n\n\n\n众目睽奎\nheilongxiaodu\n刘亦菲裸睡\n\n        ', null);
INSERT INTO `blog` VALUES ('106', '美国人教你这样用Google，你真的会变特工！', '\n            \n \n\n&nbsp;\n美国人教你这样用Google，你真的会变特工！！！（看了才感叹原来这么多年的GOOGLE是白用了~这就是百度永远无法超越G的原因吧~）\n\n大前提：英文Google→www.google.com\n\n第一篇在搜索框上输入：“indexof/”inurl:lib再按搜索你将进入许多图书馆，并且一定能下载自己喜欢的书籍。在搜索框上输入：“indexof/”cnki再按搜索你就可以找到许多图书馆的CNKI、VIP、超星等入口！在搜索框上输入：“indexof/”ppt再按搜索你就可以突破网站入口下载powerpint作品！在搜索框上输入：“indexof/”mp3再按搜索你就可以突破网站入口下载mp3、rm等影视作品！在搜索框上输入：“indexof/”swf再按搜索你就可以突破网站入口下载flash作品！在搜索框上输入：“indexof/”要下载的软件名再按搜索你就可以突破网站入口下载软件！注意引号应是英文的！再透露一下，如果你输入：“indexof/”AVI另补上第二篇用GOOgle看世界!!!只要你在GOOGLE里输入特殊的关键字,就可以搜到数千个摄象头的IP地址!通过他你就可以看到其所摄的实时影象!!在google里输入inurl:&amp;quot;viewerframe?mode=&amp;quot;随便打开一个,然后按提示装一个插件,就可以看到了!!!再补上第三篇三则黑客的Google搜索技巧简介大家都知道，Google毫无疑问是当今世界上最强大的搜索引擎。然而，在黑客手中，它也是一个秘密武器，它能搜索到一些你意想不到的信息。赛迪编者把 他们进行了简单的总结不是希望您利用他去攻击别人的网站，而是利用这些技巧去在浩如烟海的网络信息中，来个大海捞针，寻找到对您有用的信息。如果您是一名普通网民，您可以使用黑客的技巧扩大自己的视野，提高自己的检索效率；如果您是一名网管，请您赶快看看您的网站是否做好了对下面黑客探测手 段的防范措施，如果没有就赶快来个亡羊补牢，毕竟隐患胜于明火，防范胜于救灾；如果您是一名黑客，相信您早以在别的黑客站点上见过类似的方法，这篇文章对 您没什么用处，这里的技巧对您是小儿科，菜鸟级！您可以节省宝贵的时间做更有意义的事情，这篇文章您不用看了，到别处去吧！基于上面的考虑我编发了这篇文章。搜索URL比如我们提交这种形式：passwd.txtsite:virtualave.net看到了什么？是不是觉得太不可思议了！有很多基于CGI/PHP/ASP类型的留言板存在这种问题。有时我们得到密码甚至还是明码的！管理员或许太不负 责了，或许安全防范的意识太差了，如果你是网络管理员，赶快检查一下不要让恶意攻击者捡了便宜。不要太相信DES加密，即使我们的密码经过DES加密的密 码，黑客们还是可以通过许多破解软件来搞定。这次我们能得到包含密码的文件。“site:virtualave.net”意思是只搜索virutalave.net的URL。virutalave.net是一个网络服务器提供商。同样，我们可以搜索一些顶级域名，比如：.net.org.jp.in.grconfig.txtsite:.jpadmin.txtsite:.tw搜索首页的目录首页是非常有用的，它会提供给你许多有用的信息。我们提交如下的形式：&amp;quot;Indexof/admin&amp;quot;&amp;quot;Indexof/secret&amp;quot;&amp;quot;Indexof/cgi-bin&amp;quot;site:.edu你可以自己定义搜索的首页字符。这样就可以获得许多信息。搜索特定的文件类型比如你想指定一种文件的类型，可以提交如下形式：filetype:.docsite:.milclassified这个就是搜索军方的资料，你可以自定义搜索。再提供一个第四篇Google的特殊功能1、查询电话号码Google的搜索栏中最新加入了电话号码和美国街区地址的查询信息。个人如想查找这些列表，只要填写姓名，城市和省份。如果该信息为众人所知，你就会在搜索结果页面的最上方看到搜索的电话和街区地址你还可以通过以下任何一种方法找到该列表：名字（或首位大写字母），姓，电话地区号名字（或首位大写字母），姓，邮递区号名字（或首位大写字母），姓，城市（可写州）名字（或首位大写字母），姓，州电话号码，包括区号名字，城市，州名字，邮递区号2、查找PDF文件现在GOOGLE的搜索结果中包括了PDF文件。尽管PDF文件不如HTML文件那么多，但他们经常具备一些其他文件不具备的高质量信息为了显示一个搜索结果是PDF文件而不是网页，PDF文件的标题开头显示蓝色文本。这就是让你知道ACRTOBATREADER程序会启动来阅读文件如果你的计算机没装有该程序，计算机会指导你去能免费下载该程序的网页。使用PDF文件时，相关的网页快照会由“TEXTVERSION”代替，它是PDF文档的复制文件，该文件除去了所有格式化命令。如果你在没有PDF链接的情况下想看一系列搜索结果，只要在搜索栏中打上-inurldf加上你的搜索条件。3、股票报价用Google查找股票和共有基金信息，只要输入一个或多个NYSE，NASDAQ，AMEX或共有基金的股票行情自动收录机的代码，也可以输入在股市开户的公司名字。如果Google识别出你查询的是股票或者共有基金，它回复的链接会直接连到高质量的金融信息提供者提供的股票和共有基金信息。在你搜索结果的开头显示的是你查询的股市行情自动收录器的代码。如果你要查找一家公司的名字（比如，INTEL），请查看“股票报价”在Google搜索结果的金融栏里会有那个公司的主页的链接（比如，\n www. INTEL. COM\n）。Google是以质量为基础来选择和决定金融信息提供者的，包括的因素有下载速度，用户界面及其功能。4、找找谁和你链接有些单词如果带有冒号就会有特殊的意思。比如link：操作员。查询link:siteURL，就会显示所有指向那个URL的网页。举例来说，链接\n www. Google. com\n会向你显示所有指向GOOGLE主页的网页。但这种方法不能与关键字查询联合使用。5、查找站点单词site后面如果接上冒号就能够将你的搜索限定到某个网站。具体做法是：在c搜索栏中使用site:sampledomain.com这个语法结构。比如，在斯坦福找申请信息，输入：admissionsite:\n www. stanford. edu\n 6、查找字典释意查找字典释意的方法是在搜索栏中输入你要查询的内容。在我们根据要求找到所有的字典释意都会标有下划线，位于搜索结果的上面，点击链接你会找到字典提供者根据要求给出的相关定义。7、用GOOLGE查找地图想用Google查找街区地图，在Google搜索栏中输入美国街区地址，包括邮递区号或城市/州（比如165大学大街PALOALTOCA）。通常情况下，街区地址和城市的名字就足够了。当Google识别你的要求是查找地图，它会反馈给你有高质量地图提供者提供的链接，使你直接找到相关地图。我们是以质量为基础选择这些地图提供者。值得注意的是Google和使用的地图信息提供者没有任何关联。\n\n        ', null);
INSERT INTO `blog` VALUES ('107', '修电脑，不求人。（大全 )', '\n            \n \n\n1：主板故障2：显卡故障3：声卡故障4：硬盘故障5：内存故障6：光驱故障7：鼠标故障8：键盘故障9：MODEM故障10：打印机故障11：显示器故障12：刻录机故障13：扫描仪故障14：显示器抖动的原因15：疑难BIOS设置16：电脑重启故障17：解决CPU占用率过高问题18：硬盘坏道的发现与修复19：网页恶意代码的手工处理20：集成声卡常见故障及解决21：USB存储设备无法识别22：黑屏故障23：WINDOWS 蓝屏代码速查表24：WINDOWS错误代码大全25：BIOS自检与开机故障问题下面是相关的故障速查与解决问题电脑出现的故障原因扑朔迷离，让人难以捉摸。并且由于Windows操作系统的组件相对复杂，电脑一旦出现故障，对于普通用户来说，想要准确地找出其故障的原因几乎是不可能的。那么是否是说我们如果遇到电脑故障的时候，就完全束手无策了呢？其实并非如此，使电脑产生故障的原因虽然有很多，但是，只要我们细心观察，认真总结，我们还是可以掌握一些电脑故障的规律和处理办法的。在本期的小册子中，我们就将一些最为常见也是最为典型的电脑故障的诊断、维护方法展示给你，通过它，你就会发现——解决电脑故障方法就在你的身边，简单，但有效！　一、主板　　主板是整个电脑的关键部件，在电脑起着至关重要的作用。如果主板产生故障将会影响到整个PC机系统的工作。下面，我们就一起来看看主板在使用过程中最常见的故障有哪些。常见故障一：开机无显示　　电脑开机无显示，首先我们要检查的就是是BIOS。主板的BIOS中储存着重要的硬件数据，同时BIOS也是主板中比较脆弱的部分，极易受到破坏，一旦受损就会导致系统无法运行，出现此类故障一般是因为主板BIOS被CIH病毒破坏造成（当然也不排除主板本身故障导致系统无法运行。）。一般BIOS被病毒破坏后硬盘里的数据将全部丢失，所以我们可以通过检测硬盘数据是否完好来判断BIOS是否被破坏，如果硬盘数据完好无损，那么还有三种原因会造成开机无显示的现象：　　1. 因为主板扩展槽或扩展卡有问题，导致插上诸如声卡等扩展卡后主板没有响应而无显示。　　2. 免跳线主板在CMOS里设置的CPU频率不对，也可能会引发不显示故障，对此，只要清除CMOS即可予以解决。清除CMOS的跳线一般在主板的锂电池附近，其默认位置一般为1、2短路，只要将其改跳为2、3短路几秒种即可解决问题，对于以前的老主板如若用户找不到该跳线，只要将电池取下，待开机显示进入 CMOS设置后再关机，将电池上上去亦达到CMOS放电之目的。　　3. 主板无法识别内存、内存损坏或者内存不匹配也会导致开机无显示的故障。某些老的主板比较挑剔内存，一旦插上主板无法识别的内存，主板就无法启动，甚至某些主板不给你任何故障提示（鸣叫）。当然也有的时候为了扩充内存以提高系统性能，结果插上不同品牌、类型的内存同样会导致此类故障的出现，因此在检修时，应多加注意。　　对于主板BIOS被破坏的故障，我们可以插上ISA显卡看有无显示（如有提示，可按提示步骤操作即可。），倘若没有开机画面，你可以自己做一张自动更新BIOS的软盘，重新刷新BIOS，但有的主板BIOS被破坏后，软驱根本就不工作，此时，可尝试用热插拔法加以解决（我曾经尝试过，只要BIOS相同，在同级别的主板中都可以成功烧录。）。但采用热插拔除需要相同的BIOS外还可能会导致主板部分元件损坏，所以可靠的方法是用写码器将BIOS更新文件写入BIOS里面（可找有此服务的电脑商解决比较安全）。　　常见故障二：CMOS设置不能保存　　此类故障一般是由于主板电池电压不足造成，对此予以更换即可，但有的主板电池更换后同样不能解决问题，此时有两种可能：　　1. 主板电路问题，对此要找专业人员维修；　　2. 主板CMOS跳线问题，有时候因为错误的将主板上的CMOS跳线设为清除选项，或者设置成外接电池，使得CMOS数据无法保存。常见故障三：在Windows下安装主板驱动程序后出现死机或光驱读盘速度变慢的现象　　在一些杂牌主板上有时会出现此类现象，将主板驱动程序装完后，重新启动计算机不能以正常模式进入Windows 98桌面，而且该驱动程序在Windows 98下不能被卸载。如果出现这种情况，建议找到最新的驱动重新安装，问题一般都能够解决，如果实在不行，就只能重新安装系统。常见故障四：安装Windows或启动Windows时鼠标不可用　　出现此类故障的软件原因一般是由于CMOS设置错误引起的。在CMOS设置的电源管理栏有一项modem use IRQ项目，他的选项分别为3、4、5......、NA，一般它的默认选项为3，将其设置为3以外的中断项即可。常见故障五：电脑频繁死机，在进行CMOS设置时也会出现死机现象　　在CMOS里发生死机现象，一般为主板或CPU有问题，如若按下法不能解决故障，那就只有更换主板或CPU了。　　出现此类故障一般是由于主板Cache有问题或主板设计散热不良引起，笔者在815EP主板上就曾发现因主板散热不够好而导致该故障的现象。在死机后触摸CPU周围主板元件，发现其温度非常烫手。在更换大功率风扇之后，死机故障得以解决。对于Cache有问题的故障，我们可以进入CMOS设置，将Cache禁止后即可顺利解决问题，当然，Cache禁止后速度肯定会受到有影响。常见故障六：主板 COM口或并行口、IDE口失灵　　出现此类故障一般是由于用户带电插拔相关硬件造成，此时用户可以用多功能卡代替，但在代替之前必须先禁止主板上自带的COM口与并行口（有的主板连IDE口都要禁止方能正常使用）。显卡常见故障一：开机无显示　　此类故障一般是因为显卡与主板接触不良或主板插槽有问题造成。对于一些集成显卡的主板，如果显存共用主内存，则需注意内存条的位置，一般在第一个内存条插槽上应插有内存条。由于显卡原因造成的开机无显示故障，开机后一般会发出一长两短的蜂鸣声（对于AWARD BIOS显卡而言）。常见故障二：显示花屏，看不清字迹　　此类故障一般是由于显示器或显卡不支持高分辨率而造成的。花屏时可切换启动模式到安全模式，然后再在 Windows 98下进入显示设置，在16色状态下点选“应用”、“确定”按钮。重新启动，在Windows 98系统正常模式下删掉显卡驱动程序，重新启动计算机即可。也可不进入安全模式，在纯DOS环境下，编辑SYSTEM.INI文件，将 display.drv=pnpdrver改为display.drv=vga.drv后，存盘退出，再在Windows里更新驱动程序。常见故障三：颜色显示不正常，此类故障一般有以下原因：　　1. 显示卡与显示器信号线接触不良　　2. 显示器自身故障　　3. 在某些软件里运行时颜色不正常，一般常见于老式机，在BIOS里有一项校验颜色的选项，将其开启即可　　4. 显卡损坏；　　5. 显示器被磁化，此类现象一般是由于与有磁性能的物体过分接近所致，磁化后还可能会引起显示画面出现偏转的现象。常见故障四：死机　　出现此类故障一般多见于主板与显卡的不兼容或主板与显卡接触不良；显卡与其它扩展卡不兼容也会造成死机。常见故障五：屏幕出现异常杂点或图案　　此类故障一般是由于显卡的显存出现问题或显卡与主板接触不良造成。需清洁显卡金手指部位或更换显卡。常见故障六：显卡驱动程序丢失　　显卡驱动程序载入，运行一段时间后驱动程序自动丢失，此类故障一般是由于显卡质量不佳或显卡与主板不兼容，使得显卡温度太高，从而导致系统运行不稳定或出现死机，此时只有更换显卡。　　此外，还有一类特殊情况，以前能载入显卡驱动程序，但在显卡驱动程序载入后，进入Windows时出现死机。可更换其它型号的显卡在载入其驱动程序后，插入旧显卡予以解决。如若还不能解决此类故障，则说明注册表故障，对注册表进行恢复或重新安装操作系统即可。声卡常见故障一：声卡无声。出现这种故障常见的原因有：　　1. 驱动程序默认输出为“静音”。单击屏幕右下角的声音小图标（小嗽叭），出现音量调节滑块，下方有“静音”选项，单击前边的复选框，清除框内的对号，即可正常发音。　　2. 声卡与其它插卡有冲突。解决办法是调整PnP卡所使用的系统资源，使各卡互不干扰。有时，打开“设备管理”，虽然未见黄色的惊叹号（冲突标志），但声卡就是不发声，其实也是存在冲突，只是系统没有检查出来。　　3. 安装了Direct X后声卡不能发声了。说明此声卡与Direct X兼容性不好，需要更新驱动程序。　　4. 一个声道无声。检查声卡到音箱的音频线是否有断线。常见故障二：声卡发出的噪音过大．出现这种故障常见的原因有：　　1. 插卡不正。由于机箱制造精度不够高、声卡外挡板制造或安装不良导致声卡不能与主板扩展槽紧密结合，目视可见声卡上“金手指”与扩展槽簧片有错位。这种现象在ISA卡或PCI卡上都有，属于常见故障。一般可用钳子校正。　　2. 有源音箱输入接在声卡的Speaker输出端。对于有源音箱，应接在声卡的Line out端，它输出的信号没有经过声卡上的功放，噪声要小得多。有的声卡上只有一个输出端，是Line out还是Speaker要靠卡上的跳线决定，厂家的默认方式常是Speaker，所以要拔下声卡调整跳线。　　3. Windows自带的驱动程序不好。在安装声卡驱动程序时，要选择“厂家提供的驱动程序”而不要选“Windows默认的驱动程序”如果用“添加新硬件”的方式安装，要选择“从磁盘安装”而不要从列表框中选择。如果已经安装了Windows自带的驱动程序，可选“控制面板→系统→设备管理 →声音、视频和游戏控制器”，点中各分设备，选“属性→驱动程序→更改驱动程序→从磁盘安装”。这时插入声卡附带的磁盘或光盘，装入厂家提供的驱动程序。常见故障三：声卡无法“即插即用”　　1. 尽量使用新驱动程序或替代程序。笔者曾经有一块声卡，在Windows 98下用原驱动盘安装驱动程序怎么也装不上，只好用Creative SB16驱动程序代替，一切正常。后来升级到Windows Me，又不正常了再换用Windows 2000（完整版）自带的声卡驱动程序才正常。　　2. 最头痛的问题莫过于Windows 9X下检测到即插即用设备却偏偏自作主张帮你安装驱动程序，这个驱动程序偏是不能用的，以后，每次当你删掉重装都会重复这个问题，并且不能用“添加新硬件”的方法解决。笔者在这里泄露一个独门密招：进入Win9xinfother目录，把关于声卡的＊.inf文件统统删掉再重新启动后用手动安装，这一着百分之百灵验，曾救活无数声卡性命……当然，修改注册表也能达到同样的目的。　　3. 不支持PnP声卡的安装（也适用于不能用上述PnP方式安装的PnP声卡）：进入“控制面板”/“添加新硬件”/“下一步”，当提示“需要Windows 搜索新硬件吗？”时，选择“否”，而后从列表中选取“声音、视频和游戏控制器”用驱动盘或直接选择声卡类型进行安装。常见故障四：播放 CD无声　　1. 完全无声。用Windows 98的“CD播放器”放CD无声，但“CD播放器”又工作正常，这说明是光驱的音频线没有接好。使用一条4芯音频线连接CD－ROM的模拟音频输出和声卡上的CD－in即可，此线在购买CD－ROM时会附带。　　2. 只有一个声道出声。光驱输出口一般左右两线信号，中间两线为地线。由于音频信号线的4条线颜色一般不同，可以从线的颜色上找到一一对应接口。若声卡上只有一个接口或每个接口与音频线都不匹配，只好改动音频线的接线顺序，通常只把其中2条线对换即可。常见故障五：PCI声卡出现爆音　　一般是因为PCI显卡采用Bus Master技术造成挂在PCI总线上的硬盘读写、鼠标移动等操作时放大了背景噪声的缘故。解决方法：关掉 PCI显卡的Bus Master功能，换成AGP显卡，将PCI声卡换插槽上。常见故障六：无法正常录音　　首先检查麦克风是否有没有错插到其他插孔中了，其次，双击小喇叭，选择选单上的“属性→录音”，看看各项设置是否正确。接下来在“控制面板→多媒体→设备”中调整 “混合器设备”和“线路输入设备”，把它们设为“使用”状态。如果“多媒体→音频”中“录音”选项是灰色的那可就糟了，当然也不是没有挽救的余地，你可以试试“添加新硬件→系统设备”中的添加“ISA Plug and Play bus”，索性把声卡随卡工具软件安装后重新启动。常见故障七：无法播放Wav音乐、Midi音乐　　不能播放Wav音乐现象比较罕见，常常是由于“多媒体”→“设备”下的“音频设备”不只一个，禁用一个即可；无法播放MIDI文件则可能有以下3种可能：　　1. 早期的ISA声卡可能是由于16位模式与32位模式不兼容造成MIDI播放的不正常，通过安装软件波表的方式应该可以解决　　 2. 如今流行的PCI声卡大多采用波表合成技术，如果MIDI部分不能放音则很可能因为您没有加载适当的波表音色库。　　3. Windows音量控制中的MIDI通道被设置成了静音模式。常见故障八：PCI声卡在WIN98下使用不正常　　有些用户反映，在声卡驱动程序安装过程中一切正常，也没有出现设备冲突，但在WIN98下面就是无法出声或是出现其他故障。这种现象通常出现在PCI声卡上，请检查一下安装过程中您把PCI声卡插在的哪条PCI插槽上。有些朋友出于散热的考虑，喜欢把声卡插在远离AGP插槽，靠近ISA插槽的那几条PCI插槽中。问题往往就出现在这里，因为Windows98有一个Bug：有时只能正确识别插在PCI-1和PCI-2两个槽的声卡。而在ATX主板上紧靠AGP 的两条PCI才是PCI-1和PCI-2（在一些ATX主板上恰恰相反，紧靠ISA的是PCI-1），所以如果您没有把PCI声卡安装在正确的插槽上，问题就会产生了.内存　　内存是电脑中最重要的配件之一，它的作用毋庸置疑，那么内存最常见的故障都有哪些呢？常见故障一：开机无显示　　内存条原因出现此类故障一般是因为内存条与主板内存插槽接触不良造成，只要用橡皮擦来回擦试其金手指部位即可解决问题（不要用酒精等清洗），还有就是内存损坏或主板内存槽有问题也会造成此类故障。　　由于内存条原因造成开机无显示故障，主机扬声器一般都会长时间蜂鸣（针对Award Bios而言）。常见故障二：Windows注册表经常无故损坏，提示要求用户恢复　　此类故障一般都是因为内存条质量不佳引起，很难予以修复，唯有更换一途。常见故障三：Windows经常自动进入安全模式　　此类故障一般是由于主板与内存条不兼容或内存条质量不佳引起，常见于高频率的内存用于某些不支持此频率内存条的主板上，可以尝试在CMOS设置内降低内存读取速度看能否解决问题，如若不行，那就只有更换内存条了。常见故障四：随机性死机　　此类故障一般是由于采用了几种不同芯片的内存条，由于各内存条速度不同产生一个时间差从而导致死机，对此可以在CMOS设置内降低内存速度予以解决，否则，唯有使用同型号内存。还有一种可能就是内存条与主板不兼容，此类现象一般少见，另外也有可能是内存条与主板接触不良引起电脑随机性死机。01常见故障五：内存加大后系统资源反而降低　　此类现象一般是由于主板与内存不兼容引起，常见于高频率的内存内存条用于某些不支持此频率的内存条的主板上，当出现这样的故障后你可以试着在COMS中将内存的速度设置得低一点试试。常见故障六：运行某些软件时经常出现内存不足的提示　　此现象一般是由于系统盘剩余空间不足造成，可以删除一些无用文件，多留一些空间即可，一般保持在300M左右为宜。常见故障七：从硬盘引导安装Windows进行到检测磁盘空间时，系统提示内存不足　　此类故障一般是由于用户在config.sys文件中加入了emm386.exe文件，只要将其屏蔽掉即可解决问题。光驱　　光驱是电脑硬件中使用寿命最短的配件之一。其实很多报废的光驱仍有很大的利用价值，只要略微维修一下就可以了。这往往不需要具有什么高深的无线电专业知识，也不需要使用什么太复杂的维修工具及材料。你只要细心观察故障现象并参照执行下面的一些排除方法，相信你的老光驱还是能恢 复昔日“风采”的。常见故障一：光驱工作时硬盘灯始终闪烁　　这是一种假象，实际上并非如此。硬盘灯闪烁是因为光驱与硬盘同接在一个IDE接口上，光盘工作时也控制了硬盘灯的结果。可将光驱单元独接在一个IDE接口上。常见故障二：在Windows环境下对CD-ROM进行操作时显示 “32磁盘访问失败”，然后死机　　很显然，Windows的32位磁盘存取对CD-ROM有一定的影响。CD-ROM大部分接在硬盘的IDE接口上，不支持Windows的32位磁盘存取功能，使Windows产生了内部错误而死机。进入Windows后，在“主群组”中双击“控制面板”，进入“386增强模式”设置，单击“虚拟内存”按钮后再单击“更改”，把左下角的“32位磁盘访问”核实框关闭，在确认后，再重启动Windows,在Windows中再访问CD-ROM进就不会出错误。常见故障三：光驱无法正常读盘，屏幕上显示：“驱动器X上没有磁盘，插入磁盘再试”，或&quot;CDR101:NOTREADY READING DRIVE X ABORT .RETRY.FALL?&quot;偶尔进出盒几次也都读盘，但不久又不读盘。　　在此情况下，应先检测病毒，用杀毒软件进行对整机进行查杀毒，如果没有发现病毒可用文件编辑软件打开C盘根目录下的CONFIG.SYS”文件，查看其中是否又挂上光驱动程序及驱动程序是否被破坏，并进行处理，还可用文本编辑软件查看&quot;AUIOEXEC.BAT&quot;文件中是否有&quot;MSCDEX.EXE/D:MSCDOOO /M:20/V&quot;.若以上两步未发现问题，可拆卸光驱维修。常见故障四：光驱使用时出现读写错误或无盘提示　　这种现象大部分是在换盘时还没有就位就对光驱进行操作所引起的故障。对光驱的所有的操作都必需要等光盘指示灯显示为就好位时才可进行操作。在播放影碟时也应将时间调到零时再换盘，这样就可以避免出现上述错误。常见故障五：在播放电影VCD时出现画面停顿或破碎现象　　检查一下AUTOEXEC.BAT文件中的“SMARTDRV”是否放在MSCDEX.EXE之后。若是，则应将 SMARTDRV语句放到MSCDEX.EXE之前；不使用光驱的高速党组地冲程序，改为SMARTDRV.EXE/U;故障即可排除。常见故障六：光驱在读数据时，有时读得不出，并且读盘的时间变长　　光驱读盘不出的硬件故障主要集中在激光头组件上，且可分为二种情况：一种是使用太久造成激光管老化；另一种是光电管表面太脏或激光管透镜太脏及位移变形。所以在对激光管功率进行调整时，还需对光电管和激光管透镜进行清洗。　　光电管及聚焦透镜的清洗方法是：拔掉连接激光头组件的一组扁平电缆，记住方向，拆开激光头组件。这时能看到护套罩着激光头聚焦透镜，去掉护套后会发现聚焦透镜由四根细铜丝连接到聚焦、寻迹线圈上，光电管组件安装在透镜正下方的小孔中。用细铁丝包上棉花沾少量蒸馏水擦拭（不可用酒精擦拭光电管和聚焦透镜表面），并看看透镜是否水平悬空正对激光管，否则须适当调整。至此，清洗工作完毕。　　调整激光头功率。在激光头组件的侧面有1个像十字螺钉的小电位器。用色笔记下其初始位置，一般先顺时针旋转5&deg;～10&deg;，装机试机不行再逆时针旋转5&deg;～10&deg;，直到能顺利读盘。注意切不可旋转太多，以免功率太大而烧毁光电管。常见故障七：开机检测不到光驱或者检测失败 　　　这有可能是由于光驱数据线接头松动、硬盘数据线损毁或光驱跳线设置错误引起的，遇到这种问题的时候，我们首先应该检查光驱的数据线接头是否松动，如果发现没有插好，就将其重新插好、插紧。如果这样仍然不能解决故障，那么我们可以找来一根新的数据线换上试试。这时候如果故障依然存在的话，我们就需要检查一下光盘的跳线设置了，如果有错误，将其更改即可 .鼠标　　鼠标的故障分析与维修比较简单，大部分故障为接口或按键接触不良、断线、机械定位系统脏污。少数故障为鼠标内部元器件或电路虚焊，这主要存在于某些劣质产品中，其中尤以发光二极管、IC电路损坏居多。常见故障一：找不到鼠标　　1. 鼠标彻底损坏，需要更换新鼠标。　　2. 鼠标与主机连接串口或PS/2口接触不良，仔细接好线后，重新启动即可。　　3. 主板上的串口或PS/2口损坏，这种情况很少见，如果是这种情况，只好去更换一个主板或使用多功能卡上的串口。　　4. 鼠标线路接触不良，这种情况是最常见的。接触不良的点多在鼠标内部的电线与电路板的连接处。故障只要不是再PS/2接头处，一般维修起来不难。通常是由于线路比较短，或比较杂乱而导致鼠标线被用力拉扯的原因，解决方法是将鼠标打开，再使用电烙铁将焊点焊好。还有一种情况就是鼠标线内部接触不良，是由于时间长而造成老化引起的，这种故障通常难以查找，更换鼠标是最快的解决方法。常见故障二：鼠标能显示，但无法移动　　鼠标的灵活性下降，鼠标指针不像以前那样随心所欲，而是反应迟钝，定位不准确，或干脆不能移动了。这种情况主要是因为鼠标里的机械定位滚动轴上积聚了过多污垢而导致传动失灵，造成滚动不灵活。维修的重点放在鼠标内部的X轴和Y轴的传动机构上。解决方法是，可以打开胶球锁片，将鼠标滚动球卸下来，用干净的布蘸上中性洗涤剂对胶球进行清洗，摩擦轴等可用采用酒精进行擦洗。最好在轴心处滴上几滴缝纫机油，但一定要仔细，不要流到摩擦面和码盘栅缝上了。将一切污垢清除后，鼠标的灵活性恢复如初。常见故障三：鼠标按键失灵　　1. 鼠标按键无动作，这可能是因为鼠标按键和电路板上的微动开关距离太远或点击开关经过一段时间的使用而反弹能力下降。拆开鼠标，在鼠标按键的下面粘上一块厚度适中的塑料片，厚度要根据实际需要而确定，处理完毕后即可使用。　　2. 鼠标按键无法正常弹起，这可能是因为当按键下方微动开关中的碗形接触片断裂引起的，尤其是塑料簧片长期使用后容易断裂。如果是三键鼠标，那么可以将中间的那一个键拆下来应急。如果是品质好的原装名牌鼠标，则可以焊下，拆开微动开关，细心清洗触点，上一些润滑脂后，装好即可使用。键盘　　键盘在使用过程中，故障的表现形式是多种多样的，原因也是多方面的。有接触不良故障，有按键本身的机械故障，还有逻辑电路故障、虚焊、假焊、脱焊和金属孔氧化等故障．维修时要根据不同的故障现象进行分析判断，找出产生故障原因，进行相应的修理。常见故障一：键盘上一些键，如空格键、回车键不起作用，有时，需按无数次才输入—个或两个字符，有的键，如光标键按下后不再起来，屏幕上光标连续移动，此时键盘其它字符不能输入，需再按一次才能弹起来。　　这种故障为键盘的“卡键”故障，不仅仅是使用很久的旧键盘，有个别没用多久的新键盘上，键盘的卡键故障也有时发生。出现键盘的卡键现象主要由以下两个原因造成的：一种原因就是键帽下面的插柱位置偏移，使得键帽按下后与键体外壳卡住不能弹起而造成了卡键，此原因多发生在新键盘或使用不久的键盘上。另一个原因就是按键长久使用后，复位弹簧弹性变得很差，弹片与按杆摩擦力变大，不能使按键弹起而造成卡键，此种原因多发生在长久使用的键盘上。当键盘出现卡键故障时，可将键帽拨下，然后按动按杆。若按杆弹不起来或乏力，则是由第二种原因造成的，否则为第一种原因所致。若是由于键帽与键体外壳卡住的原因造成“卡键”故障，则可在键帽与键体之间放一个垫片，该垫片可用稍硬一些的塑料(如废弃的软磁盘外套)做成，其大小等于或略大于键体尺寸，并且在按杆通过的位置开一个可使铵杆自由通过的方孔，将其套在按杆上后，插上键帽；用此垫片阻止键帽与键体卡住，即可修复故障按键；若是由于弹簧疲劳，弹片阻力变大的原因造成卡键故障，这时可特键体打开，稍微拉伸复位弹簧使其恢复弹性；取下弹片将键体恢复。通过取下弹片，减少按杆弹起的阻力，从而使故障按键得到了恢复。常见故障二：某些字符不能输入。　　若只有某一个键字符不能输入，则可能是该按键失效或焊点虚焊。检查时，按照上面叙述的方法打开键盘，用万用表电阻档测量接点的通断状态。若键按下时始终不导通，则说明按键簧片疲劳或接触不良，需要修理或更换；若键按下时接点通断正常，说明可能是因虚焊、脱焊或金屑孔氧化所致，可沿着印刷线路逐段测量，找出故障进行重焊；若因金属孔氧化而失效，可将氧化层清洗干净，然后重新焊牢；若金属孔完全脱落而造成断路时，可另加焊引线进行连接。常见故障三：若有多个既不在同一列，也不在同一行的按键都不能输入。　　可能是列线或行线某处断路，或者可能是逻辑门电路产生故障。这时可用100MHz的高频示波器进行检测，找出故障器件虚焊点，然后进行修复。常见故障四：键盘输入与屏幕显示的字符不一致。　　此种故障可能是由于电路板上产生短路现象造成的，其表现是按这一键却显示为同一列的其他字符，此时可用万用表或示波器进行测量，确定故障点后进行修复。常见故障五：按下一个键产生一串多种字符，或按键时字符乱跳。　　这种现象是由逻辑电路故障造成的。先选中某一列字符，若是不含回车键的某行某列，有可能产生多个其他字符现象；若是含回车键的一列，将会产生字符乱跳且不能最后进入系统的现象，用示波器检查逻辑电路芯片，找出故障芯片后更换同型号的新芯片，排除故障。Modem常见故障一：56K的Modem不能上到56K。这个问题可以从以下几方面考虑：　　1. 实际的56Kmodem最高速度只能达到53K左右，考虑各种影响，56Kmodem的速度一般在45-53K之间。　　2. 电话线路在很大程度上影响Modem的传输速度，如果电话线路质量不好、线路电压不稳，56K的Modem就上不到56K；另外使用分机上网，也会影响上网速度。　　3. 未安装正确的驱动程序。　　4. 和ISP使用的协议不同，只有您的Modem和您的ISP协议相同时，Modem才会达到56K的标准。　　排除以上原因，您的56K Modem仍速度远远低于53K，这就是您的Modem硬件问题，可以考虑更换或送修了。常见故障二：Modem经常掉线，产生掉线问题可能有以下几种原因：　　　　1. 电话线路质量不好；　　2. 若数据终端就绪(DTR)信号无效持续的时间超过Modem默认设置值，就会引起掉线；　　3. 如果您的电话具有&quot;呼叫等待&quot;这一程控电话新功能，每当有电话打进来，调制解调器就会受到干扰而断开；　　4. 另外，Modem本身的质量以及不同Modem间的兼容性问题也是引起Modem掉线的一个普遍存在的原因。常见故障三：Modem无拨号音　　当在夜深人静的时候上网时，为了不使拨号音影响别人睡眠，可以通过适当的AT命令来改变：可以用ATM0设置Modem无拨号音，而ATM1设置Modem从拨号到连接时有拨号音。对于音量的选择您可以通过以下指令改变，ATL0(低音量)、ATL1(低音量)、ATL2(中音量)、ATL3(高音量)。常见故障四：传真速率达不到14400　　Modem的最大传真速率是14400，而发传真时速率只有9600。这是因为大部分传真机的发送和接受速率都是9600，只有使用速率是14400或是33600的传真机，Modem的传真速率才会达到14400。常见故障五：Modem无法拨号或连接　　如果没有正确安装您的Modem，通信功能将无法正常工作。下列过程列出了验证Modem与Windows的通讯程序安装了不兼容的驱动程序文件，可能会导致COM端口和Modem工作不正常，所以应该首先检查是否加载了正确的Windows98文件。　　1. 检验现有的通讯文件　　(1) 将System目录中的COMM.DRV和SERIAL.VXD文件与Windows95软盘或光盘中的原版文件进行比较，检查文件的大小和日期是否相同。　　(2) 确认在System.ini文件中有下列几行：[boot]Comm.drv=Comm.drv[386enh]device=*vcd　　 (3) 在&quot;控制面板&quot;中运行&quot;添加新硬件&quot;向导，检测和安装Windows98驱动程序。注意：Windows98在System.ini中不加载SERIAL.VXD驱动程序，而是使用注册命令来加载它。另外，在System.ini中也没有与*VCD相关的文件。这些文件被内置于 VMM32.VXD中。　　2. 检验调制解调器的配置　　在&quot;控制面板&quot;中，双击&quot;调制解调器&quot;图标。验证您的调制解调器的制造商和型号，运行&quot;安装新调制解调器&quot;向导检测调制解调器并确认当前配置是否正确。如果您的调制解调器未出现在已安装的调制解调器列表中，请单击&quot;添加&quot;，然后选择合适的调制解调器。如果制造商和类型不正确，并且在列表中没有您的设备制造商及类型，请试着用“通用调制解调器&quot;中的&quot;与 Hayes兼容&quot;选项，设置为调制解调器支持的最大波特率，并单击&quot;确定&quot;。在排除冲突列表中删除所有的调制解调器条目。　　3. 检查调制解调器是否处于可以使用状态　　在&quot;控制面板&quot;中双击&quot;系统&quot;图标，然后单击&quot;设备管理&quot;标签，在列表中选择您的调制解调器并单击&quot;属性&quot;，确认是否选中&quot;设备已存在，请使用&quot;。　　4. 检查端口的正确性　　在&quot;控制面板&quot;中双击&quot;调制解调器&quot;图标，选择您的调制解调器，然后单击&quot;属性&quot;，在&quot;通用&quot;标签上，检验列出的端口是否正确。如果不正确，请选择正确的端口，然后单击&quot;确定&quot;。　　 5. 确认串口的I/O地址和IRQ设置是否正确　　在&quot;控制面板&quot;中双击&quot;系统&quot;图标，单击&quot;设备管理&quot;标签，再单击&quot;端口&quot;，选取一个端口，然后单击&quot;属性&quot;，单击&quot;资源&quot;标签显示该端口的当前资源设置，请参阅调制解调器的手册以找到正确的设置，在&quot;资源&quot;对话框中，检查&quot;冲突设备列表&quot;以查看调制解调器使用的资源是否与其它设备发生冲突，如果调制解调器与其它设备发生冲突，请单击&quot;更改设置&quot;，然后单击未产生资源冲突的配置。　　注意：如果COM1上有鼠标器或其它设备，请不要在COM3上使用调制解调器。通常COM1和COM3端口使用同样的IRQ，并且在多数计算机上不能同时使用。COM2和COM4也有同样的问题。如果可能的话，请更改COM3和COM4端口的IRQ设置，使它们不再冲突。另外，有一些显示卡的地址也和COM4端口冲突，如果发现冲突，请使用其它端口，或者更换您的图形适配器。　　6. 检验端口设置　　在&quot;控制面板&quot;上双击&quot;调制解调器&quot;图标，单击调制解调器，然后单击&quot;属性&quot;，在出现的菜单中单击&quot;连接&quot;标签以便检查当前端口设置，例如波特率、数据位、停止位和校验。　　7. 检验调制解调器波特率　　在&quot;控制面板&quot;中双击&quot;调制解调器&quot;，选择一种调制解调器，然后单击&quot;属性&quot;，单击&quot;通用&quot;标签，然后将波特率设置为正确速率。　　注意：如果您呼叫的主系统在原先设置的波特率下无法通讯，那么有时降低波特率可能会解决问题。打印机　　在办公室中，喷墨打印机是使用得较为普便的一种设备。喷墨打印机由于使用、保养、操作不当等原因经常会出现一些故障，如何解决是用户关心的问题。在此我们便将日常工作中的常见故障及处理方法总结出来，希望对大家有所帮助。常见故障一：打印时墨迹稀少，字迹无法辨认的处理，该故障多数是由于打印机长期未用或其他原因，造成墨水输送系统障碍或喷头堵塞。　　排除的方法：如果喷头堵塞得不是很厉害，那么直接执行打印机上的清洗操作即可。如果多次清洗后仍没有效果，则可以拿下墨盒（对于墨盒喷嘴非一体的打印机，需要拿下喷嘴，但需要仔细），把喷嘴放在温水中浸泡一会，注意，一定不要把电路板部分也浸在水中，否则后果不堪设想，用吸水纸吸走沾有的水滴，装上后再清洗几次喷嘴就可以了。常见故障二：更换新墨盒后，打印机在开机时面板上的&quot;墨尽&quot;灯亮的处理　　正常情况下，当墨水已用完时&quot;墨尽&quot;灯才会亮。更换新墨盒后，打印机面板上的&quot;墨尽&quot;灯还亮，发生这种故障，一是有可能墨盒未装好，另一种可能是在关机状态下自行拿下旧墨盒，更换上新的墨盒。因为重新更换墨盒后，打印机将对墨水输送系统进行充墨，而这一过程在关机状态下将无法进行，使得打印机无法检测到重新安装上的墨盒。另外，有些打印机对墨水容量的计量是使用打印机内部的电子计数器来进行计数的（特别是在对彩色墨水使用量的统计上），当该计数器达到一定值时，打印机判断墨水用尽。而在墨盒更换过程中，打印机将对其内部的电子计数器进行复位，从而确认安装了新的墨盒。　　解决方法：打开电源，将打印头移动到墨盒更换位置。将墨盒安装好后，让打印机进行充墨，充墨过程结束后，故障排除。常见故障三：喷头软性堵头的处理　　软性堵头堵塞指的是因种种原因造成墨水在喷头上粘度变大所致的断线故障。一般用原装墨水盒经过多次清洗就可恢复，但这样的方法太浪费墨水。最简单的办法是利用你手中的空墨盒来进行喷头的清洗。用空墨盒清洗前，先要用针管将墨盒内残余墨水尽量抽出，越干净越好，然后加入清洗液（配件市场有售）。加注清洗液时，应在干净的环境中进行，将加好清洗液的墨盒按打印机正常的操作上机，不断按打印机的清洗键对其进行清洗。利用墨盒内残余墨水与清洗液混合的淡颜色进行打印测试，正常之后换上好墨盒就可以使用了。常见故障四：打印机清洗泵嘴的故障处理　　打印机清洗泵嘴出毛病是较多的，也是造成堵头的主要因素之一。打印机清洗泵嘴对打印机喷头的保护起决定性作用。喷头小车回位后，要由清洗泵嘴对喷头进行弱抽气处理，对喷头进行密封保护。在打印机安装新墨盒或喷嘴有断线时，机器下端的抽吸泵要通过它对喷头进行抽气，此嘴的工作精度越高越好。但在实际使用中，它的性能及气密性会因时间的延长、灰尘及墨水在此嘴的残留凝固物增加而降低。如果使用者不对其经常进行检查或清洗，它会使你的打印机喷头不断出些故障。　　养护此部件的方法：将打印机的上盖卸下移开小车，用针管吸入纯净水对其进行冲洗，特别要对嘴内镶嵌的微孔垫片充分清洗。在此要特别提醒用户，清洗此部件时，千万不能用乙醇或甲醇对其进行清洗，这样会造成此组件中镶嵌的微孔垫片溶解变形。另外要提的是，喷墨打印机要尽量远离高温及灰尘的工作环境，只有良好的工作环境才能保证机器长久正常的使用。常见故障五：检测墨线正常而打印精度明显变差的处理　　喷墨打印机在使用中会因使用的次数及时间的延长而打印精度逐渐变差。喷墨打印机喷头也是有寿命的。一般一只新喷头从开始使用到寿命完结，如果不出什么故障较顺利的话，也就是20-40个墨盒的用量寿命。如果你的打印机已使用很久，现在的打印精度变差，你可以用更换墨盒的方法来试试，如果换了几个墨盒，其输出打印的结果都一样，那么你这台打印机的喷头将要更换了。如果更换墨盒以后有变化，说明可能你使用的墨盒中有质量较差的非原装墨水。　　如果打印机是新的，打印的结果不能令你满意，经常出现打印线段不清晰、文字图形歪斜、文字图形外边界模糊、打印出墨控制同步精度差，这说明你可能买到的是假墨盒或者使用的墨盒是非原装产品，应当对其立即更换。常见故障六：行走小车错位碰头的处理　　喷墨打印机行走小车的轨道是由两只粉末合金铜套与一根圆钢轴的精密结合来滑动完成的。虽然行走小车上设计安装有一片含油毡垫以补充轴上润滑油，但因我们生活的环境中到处都有灰尘，时间一久，会因空气的氧化，灰尘的破坏使轴表面的润滑油老化而失效，这时如果继续使用打印机，就会因轴与铜套的摩擦力增大而造成小车行走错位，直至碰撞车头造成无法使用。　　解决的办法是：一旦出现此故障应立即关闭打印机电源，用手将未回位的小车推回停车位。找一小块海绵或毡，放在缝纫机油里浸饱油，用镊子夹住在主轴上来回擦。最好是将主轴拆下来，洗净后上油，这样的效果最好。　　另一种小车碰头是因为器件损坏所致。打印机小车停车位的上方有一只光电传感器，它是向打印机主板提供打印小车复位信号的重要元件。此元件如果因灰尘太大或损坏，打印机的小车会因找不到回位信号碰到车头，而导致无法使用，一般出此故障时需要更换器件。显示器　　显示器用的时间长了，各种小毛病就会接踵而来。专家认为，要解决这些小毛病实际上很简单，用一双眼睛就可以看出故障的所在。常见故障一：电脑刚开机时显示器的画面抖动得很厉害，有时甚至连图标和文字也看不清，但过一二分钟之后就会恢复正常。　　这种现象多发生在潮湿的天气，是显示器内部受潮的缘故。要彻底解决此问题，可使用食品包装中的防潮砂用棉线串起来，然后打开显示器的后盖，将防潮砂挂于显象管管颈尾部靠近管座附近。这样，即使是在潮湿的天气里，也不会再出现以上的“毛病”。常见故障二：电脑开机后，显示器只闻其声不见其画，漆黑一片。要等上几十分钟以后才能出现画面。　　这是显象管座漏电所致，须更换管座。拆开后盖可以看到显象管尾的一块小电路板，管座就焊在电路板上。小心拔下这块电路板，再焊下管座，到电子商店买回一个同样的管座，然后将管座焊回到电路板上。这时不要急于将电路板装回去，要先找一小块砂纸，很小心地将显象管尾后凸出的管脚用砂纸擦拭干净。特别是要注意管脚上的氧化层，如果擦得不干净很快就会旧病复发。将电路板装回去就大功告成。常见故障三：显示器屏幕上总有挥之不去的干扰杂波或线条，而且音箱中也有令人讨厌的杂音。　　这种现象多半是电源的抗干扰性差所致。如果懒得动手，可以更换一个新的电源。如果有足够的动手能力，也可以试着自己更换电源内滤波电容，这往往都能奏效；如果效果不太明显，可以将开关管一并换下来。常见故障四：显示器花屏。　　这问题较多是显卡引起的。如果是新换的显卡，则可能是卡的质量不好或不兼容，再有就是还没有安装正确的驱动程序。如果是旧卡而加了显存的话，则有可能是新加进的显存和原来的显存型号参数不一所致。常见故障五：显示器黑屏。　　如果是显卡损坏或显示器断线等原因造成没有信号传送到显示器，则显示器的指示灯会不停地闪烁提示没有接收到信号。要是将分辨率设得太高，超过显示器的最大分辨率也会出现黑屏，重者销毁显示器，但现在的显示器都有保护功能，当分辨率超出设定值时会自动保护。另外，硬件冲突也会引起黑屏。显示器抖动的原因显示器刷新频率设置得太低　　当显示器的刷新频率设置低于75Hz时，屏幕常会出现抖动、闪烁的现象，把刷新率适当调高，比如设置成高于85Hz，屏幕抖动的现象一般不会再出现。电源变压器离显示器和机箱太近　　电源变压器工作时会造成较大的电磁干扰，从而造成屏幕抖动。把电源变压器放在远离机箱和显示器的地方，可以让问题迎刃而解。劣质电源或电源设备已经老化　　许多杂牌电脑电源所使用的元件做工、用料均很差，易造成电脑的电路不畅或供电能力跟不上，当系统繁忙时，显示器尤其会出现屏幕抖动的现象。电脑的电源设备开始老化时，也容易造成相同的问题。音箱放得离显示器太近　　音箱的磁场效应会干扰显示器的正常工作，使显示器产生屏幕抖动和串色等磁干扰现象。病毒作怪　　有些计算机病毒会扰乱屏幕显示，比如：字符倒置、屏幕抖动、图形翻转显示等。网上随处可见的屏幕抖动脚本，就足以让你在中招之后头大如牛。显示卡接触不良　　重插显示卡后，故障可得到排除。WIN95/98系统后写缓存引起　　如属于这种原因，在控制面板-系统-性能-文件系统- 疑难解答中禁用所有驱动器后写式高速缓存，可让问题得到根本解决。电源滤波电容损坏　　打开机箱，如果你看到电源滤波电容（电路板上个头最大的那个电容）顶部鼓起，那么便说明电容坏了，屏幕抖动是由电源故障引起的。换了电容之后，即可解决问题。刻录机常见故障一：安装刻录机后无法启动电脑　　首先切断电脑供电电源，打开机箱外壳检查IDE线是否完全插入，并且要保证PIN-1的接脚位置正确连接。如果刻录机与其它IDE设备共用一条IDE线，需保证两个设备不能同时设定为“MA”(Master)或“SL”(Slave)方式，可以把一个设置为“MA”，一个设置为“SL”。常见故障二：使用模拟刻录成功，实际刻录却失败　　刻录机提供的“模拟刻录”和 “刻录”命令的差别在于是否打出激光光束，而其它的操作都是完全相同的，也就是说，“模拟刻录＂可以测试源光盘是否正常，硬盘转速是否够快，剩余磁盘空间是否足够等刻录环境的状况，但无法测试待刻录的盘片是否存在问题和刻录机的激光读写头功率与盘片是否匹配等等。有鉴于此，说明“模拟刻录”成功，而真正刻录失败，说明刻录机与空白盘片之间的兼容性不是很好，可以采用如下两种方法来重新试验一下：　　1. 降低刻录机的写入速度，建议2X以下；　　2. 请更换另外一个品牌的空白光盘进行刻录操作。出现此种现象的另外一个原因就是激光读写头功率衰减现象造成的，如果使用相同品牌的盘片刻录，在前一段时间内均正常，则很可能与读写头功率衰减有关，可以送有关厂商维修。常见故障三：无法复制游戏CD　　一些大型的商业软件或者游戏软件，在制作过程中，对光盘的盘片做了保护，所以在进行光盘复制的过程中，会出现无法复制，导致刻录过程发生错误，或者复制以后无法正常使用的情况发生。常见故障四：刻录的CD音乐不能正常播放　　并不是所有的音响设备都能正常读取CD-R盘片的，大多数CD机都不能正常读取CD-RW盘片的内容，所以最好不要用刻录机来刻录CD音乐。另外，还需要注意的是，刻录的CD音乐，必须要符合CD-DA文件格式。常见故障五：刻录软件刻录光盘过程中，有时会出现“BufferUnderrun”的错误提示信息　　“BufferUnderrun”错误提示信息的意思为缓冲区欠载。一般在刻录过程中，待刻录数据需要由硬盘经过IDE界面传送给主机，再经由IDE界面传送到刻录机的高速缓存中 (BufferMemory)，最后刻录机把储存在BufferMemory里的数据信息刻录到CD-R或CD-RW盘片上，这些动作都必须是连续的，绝对不能中断，如果其中任何一个环节出现了问题，都会造成刻录机无法正常写入数据，并出现缓冲区欠载的错误提示，进而是盘片报废。解决的办法就是，在刻录之前需要关闭一些常驻内存的程序，比如关闭光盘自动插入通告，关闭防毒软件、Window任务管理和计划任务程序和屏幕保护程序等等。常见故障六：光盘刻录过程中，经常会出现刻录失败　　提高刻录成功率需要保持系统环境单纯，即关闭后台常驻程序，最好为刻录系统准备一个专用的硬盘，专门安装与刻录相关的软件。在刻录过程中，最好把数据资料先保存在硬盘中，制作成“ISO镜像文件”，然后再刻入光盘。为了保证刻录过程数据传送的流畅，需要经常对硬盘碎片进行整理，避免发生因文件无法正常传送，造成的刻录中断错误，可以通过执行“磁盘扫描程序”和“磁盘碎片整理程序”来进行硬盘整理。此外，在刻录过程中，不要运行其它程序，甚至连鼠标和键盘也不要去轻易去碰。刻录使用的电脑最好不要与其他电脑联网，在刻录过程中，如果系统管理员向本机发送信息，会影响刻录效果，另外，在局域网中，不要使用资源共享，如果在刻录过程中，其它用户读取本地硬盘，会造成刻录工作中断或者失败。除此以外，还要注意刻录机的散热问题，良好的散热条件会给刻录机一个稳定的工作环境，如果因为连续刻录，刻录机发热量过高，可以先关闭电脑，等温度降低以后再继续刻录。针对内置式刻录机最好在机箱内加上额外的散热风扇。外置式刻录机要注意防尘，防潮，以免造成激光头读写不正常。常见故障七：使用 EasyCDPro刻录无法识别中文目录名　　在使用EasyCDPro刻录中文文件名的时候，可以在文件名选项中选取Romeo，就可以支持长达128位文件名，即64个汉字的文件名了。另外，WinonCD、Nero、DirectCD2.x等都能很好地支持长中文文件名，\n\n        ', null);
INSERT INTO `blog` VALUES ('108', '百家讲坛全部视频', '\n            \n \n\n&nbsp;\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n \n&nbsp;\n\n&nbsp;武则天（全集） \n\n易中天品三国（全集）\n\n刘心武揭密红楼梦\n\n明亡清兴六十年\n\n清十二帝疑案\n\n玄奘西游记\n\n贞观之治\n\n李清照\n\n人际交往法则\n\n吕后的传奇一生 \n\n于丹庄子心得（全集）\n\n王立群读《史记》之汉武帝\n\n王立群读《史记》之秦始皇\n\n先秦诸子百家争鸣\n\n三字经\n\n&nbsp;诗仙-李白\n\n杜甫的文化意义\n\n诗圣-杜甫\n\n于丹《论语》心得\n\n于丹《论语》感悟\n\n我读经典(系列)\n\n解读苏东坡\n\n陆游　\n\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n\n        ', null);
INSERT INTO `blog` VALUES ('109', '好多大学视频教程,让你省去几万块的大学学费', '\n            \n \n\n计算机类计算机系统结构（30课时）http://www.da-fan-shu.cn/20091022_455/信息管理概论(12课时)http://www.da-fan-shu.cn/20091022_454/音频视频采集与编辑(6课时)http://www.da-fan-shu.cn/20091022_453/网络数据库SQL(12课时)http://www.da-fan-shu.cn/20091022_452/数据库系统概论(19课时)http://www.da-fan-shu.cn/20091022_451/信息科学基础(49课时)http://www.da-fan-shu.cn/20091022_450/组成与系统结构（80课时）http://www.da-fan-shu.cn/20091022_449/数据库原理及应用(25课时)http://www.da-fan-shu.cn/20091022_448/internet实用技术(37课时)http://www.da-fan-shu.cn/20091022_447/ 编译原理(40课时)http://www.da-fan-shu.cn/20091022_446/ 汇编语言(64课时)http://www.da-fan-shu.cn/20091022_445/ 计算机软件基础(54课时)http://www.da-fan-shu.cn/20091022_444/ 计算机文化基础(44课时)http://www.da-fan-shu.cn/20091022_431/ 有限元及程序设计(54课时)http://www.da-fan-shu.cn/20091022_443/ 微机原理(47课时)http://www.da-fan-shu.cn/20091022_442/ 网络营销(49课时)http://www.da-fan-shu.cn/20091022_441/ 操作系统(47课时)http://www.da-fan-shu.cn/20091022_440/ 数据通信与网络(40课时)http://www.da-fan-shu.cn/20091022_439/ 信息管理学(27课时)http://www.da-fan-shu.cn/20091022_438/ 网页设计与制作(53课时)http://www.da-fan-shu.cn/20091022_437/ 数据库语言(55课时)http://www.da-fan-shu.cn/20091022_436/ C语言(32课时)http://www.da-fan-shu.cn/20091022_435/ 软件工程(40课时)http://www.da-fan-shu.cn/20091022_434/ 程序语言的设计与实现(64课时)http://www.da-fan-shu.cn/20091022_433/ 计算方法(40课时)http://www.da-fan-shu.cn/20091022_432/ 数据结构(42课时)http://www.da-fan-shu.cn/20091022_430/ 计算机组成与系统结构(80课时)http://www.da-fan-shu.cn/20091022_426/ 算法设计与分析(57课时)http://www.da-fan-shu.cn/20091022_427/ 多媒体技术(44课时)http://www.da-fan-shu.cn/20091022_428/ 计算机网络(29课时)http://www.da-fan-shu.cn/20091022_429/ 机械类机械制造装备设计(40课时)http://www.da-fan-shu.cn/20091022_283/ 控制系统CAD(2课时)http://www.da-fan-shu.cn/20091022_282/ 工程力学(48课时)http://www.da-fan-shu.cn/20091022_281/ 计算机辅助设计(38课时)http://www.da-fan-shu.cn/20091022_280/ 机械制图(40课时)http://www.da-fan-shu.cn/20091022_279/ 先进制造系统(40课时)http://www.da-fan-shu.cn/20091022_273/ 机械设计(64课时)http://www.da-fan-shu.cn/20091022_278/ 控制工程(60课时)http://www.da-fan-shu.cn/20091022_277/ 机械原理(45课时)http://www.da-fan-shu.cn/20091022_276/ 电机学(32课时)http://www.da-fan-shu.cn/20091022_275/ 机床概论(26课时)http://www.da-fan-shu.cn/20091022_274/ 土木建筑类土木工程概论(44课时)http://www.da-fan-shu.cn/20091022_423/ 建筑制图（上）(35课时)http://www.da-fan-shu.cn/20091022_421/ l建筑制图（下）(26课时)http://www.da-fan-shu.cn/20091022_422/ 材料力学(48课时)http://www.da-fan-shu.cn/20091022_420/ 测量学(27课时)http://www.da-fan-shu.cn/20091022_419/ 抗震结构设计(30课时)http://www.da-fan-shu.cn/20091022_418/ 钢结构(31课时)http://www.da-fan-shu.cn/20091022_417/ 建筑设备(32课时)http://www.da-fan-shu.cn/20091022_416/ 土力学与地基基础(64课时)http://www.da-fan-shu.cn/20091022_415/ 工程监督概论(48课时)http://www.da-fan-shu.cn/20091022_414/ 土木工程施工技术(37课时)http://www.da-fan-shu.cn/20091022_413/ 工程概预算(37课时)http://www.da-fan-shu.cn/20091022_412/ 钢筋混泥土结构(52课时)http://www.da-fan-shu.cn/20091022_411/ 结构力学(45课时)http://www.da-fan-shu.cn/20091022_410/ 房屋建筑学(51课时)http://www.da-fan-shu.cn/20091022_409/ 混泥土结构与砌体结构(50课时)http://www.da-fan-shu.cn/20091022_408/ 结构计算软件(15课时)http://www.da-fan-shu.cn/20091022_425/钢-混凝土组合结构(16课时)http://www.da-fan-shu.cn/20091022_424/ 财经管类会计学基础(58课时)http://www.da-fan-shu.cn/20091022_326/ 经贸知识英语(57课时)http://www.da-fan-shu.cn/20091022_325/ 国际市场营销(43课时)http://www.da-fan-shu.cn/20091022_327/ 国际经济合作理论与实务(64课时)http://www.da-fan-shu.cn/20091022_328/ 政府与事业单位会计(64课时)http://www.da-fan-shu.cn/20091022_329/ 西方财务会计(45课时)http://www.da-fan-shu.cn/20091022_329/ 高级财务会计(47课时)http://www.da-fan-shu.cn/20091022_331/ 高级审计学(48课时)http://www.da-fan-shu.cn/20091022_332/ 贸易谈判(32课时)http://www.da-fan-shu.cn/20091022_333/ 成本会计(42课时)http://www.da-fan-shu.cn/20091022_334/ 电子类电路基础(54课时)http://www.da-fan-shu.cn/20091022_538/ 电工技术(45课时)http://www.da-fan-shu.cn/20091022_536/ 电子技术(64课时)http://www.da-fan-shu.cn/20091022_537/ 电路分析基础(60课时)http://www.da-fan-shu.cn/20091022_539/ 其它视频大学英语http://www.da-fan-shu.cn/20091022_461/ 大学语文http://www.da-fan-shu.cn/20091022_462/ 大学物理http://www.da-fan-shu.cn/20091022_467/ 多媒体课件制作http://www.da-fan-shu.cn/20091022_523/ 硬笔书法http://www.da-fan-shu.cn/20091022_516/ 变化中的英语http://www.da-fan-shu.cn/20091022_512/ 高级日常英语http://www.da-fan-shu.cn/20091022_511/ 大学化学http://www.da-fan-shu.cn/20091022_500/ 哲学http://www.da-fan-shu.cn/20091022_478/ 社会学概论http://www.da-fan-shu.cn/20091022_474/ 广告策划http://www.da-fan-shu.cn/20091022_505/ 常言道：&quot;书山有路勤为径，学海无涯苦作舟。&quot;无止境地学习，是每一个智者所必需的。人要想不断地进步，就得活到老、学到老。 \n\n        ', null);
INSERT INTO `blog` VALUES ('110', 'Excel高级使用技巧（有用就给自己留着）', '\n            \n \n\n1.编辑技巧 2.单元格内容的合并 3.条件显示 4.自定义格式 5.绘制函数图象 6.自定义函数 7.矩阵计算 8.自动切换输入法 9.批量删除空行 10.如何避免错误信息 11.宏的使用 12.图标的应用技巧 \n&nbsp;\n&nbsp;\n&nbsp;\n1、编辑技巧 1 编辑技巧 （1） 分数的输入 如果直接输入“1/5”，系统会将其变为“1月5日”，解决办法是：先输入“0”，然后输入空格，再输入分数“1/5”。 （2） 序列“001”的输入 如果直接输入“001”，系统会自动判断001为数据1，解决办法是：首先输入“\'”（西文单引号），然后输入“001”。 （3） 日期的输入　 如果要输入“4月5日”，直接输入“4/5”，再敲回车就行了。如果要输入当前日期，按一下“Ctrl+；”键。 （4） 填充条纹 　 如果想在工作簿中加入漂亮的横条纹，可以利用对齐方式中的填充功能。先在一单元格内填入“*”或“~”等符号，然后单击此单元格，向右拖动鼠标，选中横向若干单元格，单击“格式”菜单，选中“单元格”命令，在弹出的“单元格格式”菜单中，选择“对齐”选项卡，在水平对齐下拉列表中选择“填充”，单击“确定”按钮（如图1）。 图１  （5） 多张工作表中输入相同的内容 几个工作表中同一位置填入同一数据时，可以选中一张工作表，然后按住Ctrl键，再单击窗口左下角的Sheet1、Sheet2......来直接选择需要输入相同内容的多个工作表，接着在其中的任意一个工作表中输入这些相同的数据，此时这些数据会自动出现在选中的其它工作表之中。输入完毕之后，再次按下键盘上的Ctrl键，然后使用鼠标左键单击所选择的多个工作表，解除这些工作表的联系，否则在一张表单中输入的数据会接着出现在选中的其它工作表内。 （6） 不连续单元格填充同一数据 选中一个单元格，按住Ctrl键，用鼠标单击其他单元格，就将这些单元格全部都选中了。在编辑区中输入数据，然后按住Ctrl键，同时敲一下回车，在所有选中的单元格中都出现了这一数据。 （7） 在单元格中显示公式 如果工作表中的数据多数是由公式生成的，想要快速知道每个单元格中的公式形式，以便编辑修改，可以这样做：用鼠标左键单击“工具”菜单，选取“选项”命令，出现“选项”对话框，单击“视图”选项卡，接着设置“窗口选项”栏下的“公式”项有效，单击“确定”按钮（如图2）。这时每个单元格中的分工就显示出来了。如果想恢复公式计算结果的显示，就再设置“窗口选项”栏下的“公式”项失效即可。 图２  （8） 利用Ctrl＋*选取文本 如果一个工作表中有很多数据表格时，可以通过选定表格中某个单元格，然后按下Ctrl＋*键可选定整个表格。Ctrl＋*选定的区域为：根据选定单元格向四周辐射所涉及到的有数据单元格的最大区域。这样我们可以方便准确地选取数据表格，并能有效避免使用拖动鼠标方法选取较大单元格区域时屏幕的乱滚现象。 （9） 快速清除单元格的内容 如果要删除内容的单元格中的内容和它的格式和批注，就不能简单地应用选定该单元格，然后按Delete键的方法了。要彻底清除单元格,可用以下方法：选定想要清除的单元格或单元格范围；单击“编辑”菜单中“清除”项中的“全部”命令，这些单元格就恢复了本来面目。 \n\n2、单元格内容的合并 http://www.hongen.com/pc/oa/excel2k/ex2k1302.htm 根据需要，有时想把B列与C列的内容进行合并，如果行数较少，可以直接用“剪切”和“粘贴”来完成操作，但如果有几万行，就不能这样办了。 解决办法是：在C行后插入一个空列（如果D列没有内容，就直接在D列操作），在Ｄ1中输入“=B1&amp;C1”，D1列的内容就是B、C两列的和了。选中D1单元格，用鼠标指向单元格右下角的小方块“■”，当光标变成&quot;＋&quot;后，按住鼠标拖动光标向下拖到要合并的结尾行处，就完成了B列和C列的合并。这时先不要忙着把B列和C列删除，先要把D列的结果复制一下，再用“选择性粘贴”命令，将数据粘贴到一个空列上。这时再删掉B、C、D列的数据。 下面是一个“&amp;”实际应用的例子。用AutoCAD绘图时，有人喜欢在EXCEL中存储坐标点，在绘制曲线时调用这些参数。存放数据格式为“x，y”的形式，首先在Excel中输入坐标值，将x坐标值放入A列，y坐标值放入到B列，然后利用“&amp;”将A列和B列合并成C列，在C1中输入：=A1&amp;&quot;，&quot;&amp;B1，此时C1中的数据形式就符合要求了，再用鼠标向下拖动C1单元格，完成对A列和B列的所有内容的合并（如图3-4）。 合并不同单元格的内容，还有一种方法是利用CONCATENATE函数，此函数的作用是将若干文字串合并到一个字串中，具体操作为“=CONCATENATE（B1,C1）”。比如，假设在某一河流生态调查工作表中，B2包含“物种”、B3包含“河鳟鱼”，B7包含总数45，那么： 输入“=CONCATENATE（&quot;本次河流生态调查结果：&quot;，B2，&quot;&quot;，B3，&quot;为&quot;，B7，&quot;条/公里。&quot;）” 计算结果为：本次河流生态调查结果：河鳟鱼物种为45条/公里。 图３　　　　　　　　　　　　　　　　　　　图４   \n\n3、条件显示 我们知道，利用If函数，可以实现按照条件显示。一个常用的例子，就是教师在统计学生成绩时，希望输入60以下的分数时，能显示为“不及格”；输入60以上的分数时，显示为“及格&quot;。这样的效果，利用IF函数可以很方便地实现。 假设成绩在A2单元格中，判断结果在A3单元格中。那么在A3单元格中输入公式： =if（A2&lt;60，“不及格”，“及格”） 同时，在IF函数中还可以嵌套IF函数或其它函数。 　　 例如，如果输入： =if（A2&lt;60，“不及格”，if（A2&lt;=90，“及格”，“优秀&quot;）） 就把成绩分成了三个等级。　 如果输入　=if（A2&lt;60，“差&quot;，if（A2&lt;=70，“中”，if（A2&lt;90，“良”，“优”））） 就把成绩分为了四个等级。 　　 再比如，公式： =if（SUM（A1：A5&gt;0，SUM（A1：A5），0） 此式就利用了嵌套函数，意思是，当A1至A5的和大于0时，返回这个值，如果小于0，那么就返回0。 还有一点要提醒你注意：以上的符号均为半角，而且IF与括号之间也不能有空格。 \n\n4、自定义格式 Excel中预设了很多有用的数据格式，基本能够满足使用的要求，但对一些特殊的要求，如强调显示某些重要数据或信息、设置显示条件等，就要使用自定义格式功能来完成。 Excel的自定义格式使用下面的通用模型：正数格式，负数格式，零格式，文本格式，在这个通用模型中，包含三个数字段和一个文本段：大于零的数据使用正数格式；小于零的数据使用负数格式；等于零的数据使用零格式；输入单元格的正文使用文本格式。 我们还可以通过使用条件测试，添加描述文本和使用颜色来扩展自定义格式通用模型的应用。 （1）使用颜色 　要在自定义格式的某个段中设置颜色，只需在该段中增加用方括号括住的颜色名或颜色编号。Excel识别的颜色名为：[黑色]、[红色]、[白色]、[蓝色]、[绿色]、[青色]和[洋红]。Excel也识别按[颜色X]指定的颜色，其中X是1至56之间的数字，代表56种颜色(如图5）。 图５  （2）添加描述文本 　要在输入数字数据之后自动添加文本，使用自定义格式为：＂文本内容＂@；要在输入数字数据之前自动添加文本，使用自定义格式为：@＂文本内容＂。@符号的位置决定了Excel输入的数字数据相对于添加文本的位置。 （3）创建条件格式 　可以使用六种逻辑符号来设计一个条件格式：&gt;（大于）、&gt;=（大于等于）、&lt;（小于）、&lt;=（小于等于）、=（等于）、&lt;&gt;（不等于），如果你觉得这些符号不好记，就干脆使用“&gt;”或“&gt;=”号来表示。 由于自定义格式中最多只有3个数字段，Excel规定最多只能在前两个数字段中包括2个条件测试，满足某个测试条件的数字使用相应段中指定的格式，其余数字使用第3段格式。如果仅包含一个条件测试，则要根据不同的情况来具体分析。 自定义格式的通用模型相当于下式：[&gt;；0]正数格式；[&lt;；0]负数格式；零格式；文本格式。 下面给出一个例子：选中一列，然后单击“格式”菜单中的“单元格”命令，在弹出的对话框中选择“数字”选项卡，在“分类”列表中选择“自定义”，然后在“类型”文本框中输入“&quot;正数:&quot;($#,##0.00);&quot;负数:&quot;($ #,##0.00);&quot;零&quot;;&quot;文本:&quot;@”，单击“确定”按钮，完成格式设置。这时如果我们输入“12”，就会在单元格中显示“正数：（$12.00）”，如果输入“-0.3”，就会在单元格中显示“负数：（$0.30）”，如果输入“0”，就会在单元格中显示“零”，如果输入文本“this is a book”，就会在单元格中显示“文本：this is a book”。 如果改变自定义格式的内容，“[红色]&quot;正数:&quot;($#,##0.00);[蓝色]&quot;负数:&quot;($ #,##0.00);[黄色]&quot;零&quot;;&quot;文本:&quot;@”，那么正数、负数、零将显示为不同的颜色。如果输入“[Blue];[Red];[Yellow];[Green]”，那么正数、负数、零和文本将分别显示上面的颜色（如图6）。 图６  再举一个例子，假设正在进行帐目的结算，想要用蓝色显示结余超过$50，000的帐目，负数值用红色显示在括号中，其余的值用缺省颜色显示，可以创建如下的格式： “[蓝色][&gt;50000] $#,##0.00_);[红色][&lt;0]( $#,##0.00); $#,##0.00_)” 使用条件运算符也可以作为缩放数值的强有力的辅助方式，例如，如果所在单位生产几种产品，每个产品中只要几克某化合物，而一天生产几千个此产品，那么在编制使用预算时，需要从克转为千克、吨，这时可以定义下面的格式： “[&gt;999999]#,##0,,_m&quot;吨&quot;&quot;;[&gt;999]##,_k_m&quot;千克&quot;;#_k&quot;克&quot;” 可以看到，使用条件格式，千分符和均匀间隔指示符的组合，不用增加公式的数目就可以改进工作表的可读性和效率。 另外，我们还可以运用自定义格式来达到隐藏输入数据的目的，比如格式＂；＃＃；0＂只显示负数和零，输入的正数则不显示；格式“；；；”则隐藏所有的输入值。 自定义格式只改变数据的显示外观，并不改变数据的值，也就是说不影响数据的计算。灵活运用好自定义格式功能，将会给实际工作带来很大的方便。 \n\n5、绘制函数图象 做教学工作的朋友们一定会遇到画函数曲线的问题吧！如果想快速准确地绘制一条函数曲线，可以借助EXCEL的图表功能，它能使你画的曲线既标准又漂亮。你一定会问，是不是很难学呀？其实这一点儿也不难，可以说非常简便，不信你就跟我试一试。 以绘制y=|lg（6+x^3）|的曲线为例，其方法如下： 在某张空白的工作表中，先输入函数的自变量：在A列的A1格输入&quot;X=&quot;，表明这是自变量，再在A列的A2及以后的格内逐次从小到大输入自变量的各个值；实际输入的时候，通常应用等差数列输入法，先输入前二个值，定出自变量中数与数之间的步长，然后选中A2和A3两个单元格，使这二项变成一个带黑色边框的矩形，再用鼠标指向这黑色矩形的右下角的小方块“■”，当光标变成&quot;＋&quot;后，按住鼠标拖动光标到适当的位置，就完成自变量的输入。 输入函数式：在B列的B1格输入函数式的一般书面表达形式，y=|lg（6+x^3）|；在B2格输入“=ABS（LOG10（6+A2^3））”，B2格内马上得出了计算的结果。这时，再选中B2格，让光标指向B2矩形右下角的“■”，当光标变成&quot;＋&quot;时按住光标沿B列拖动到适当的位置即完成函数值的计算。 图７  绘制曲线：点击工具栏上的“图表向导”按钮，选择“X，Y散点图”（如图7），然后在出现的“X，Y散点图”类型中选择“无数据点平滑线散点图”；此时可察看即将绘制的函数图像，发现并不是我们所要的函数曲线，单击“下一步”按钮，选中“数据产生在列”项，给出数据区域，这时曲线就在我们面前了（如图8）。 图８  需要注意：如何确定自变量的初始值，数据点之间的步长是多少，这是要根据函数的具体特点来判断，这也是对使用者能力的检验。如果想很快查到函数的极值或看出其发展趋势，给出的数据点也不一定非得是等差的，可以根据需要任意给定。 从简单的三角函数到复杂的对数、指数函数，都可以用EXCEL画出曲线。如果用得到，你还可以利用EXCEL来完成行列式、矩阵的各种计算，进行简单的积分运算，利用迭代求函数值（如x^2=x^7+4，可用迭代方法求x值），等等，凡是涉及计算方面的事，找EXCEL来帮忙，它一定会给你一个满意的答案。 \n\n6、自定义函数 虽然Excel中已有大量的内置函数，但有时可能还会碰到一些计算无函数可用的情况。假如某公司采用一个特殊的数学公式计算产品购买者的折扣，如果有一个函数来计算岂不更方便？下面就说一下如何创建这样的自定义函数。 自定义函数，也叫用户定义函数，是Excel最富有创意和吸引力的功能之一，下面我们在Visual Basic模块中创建一个函数。 在下面的例子中，我们要给每个人的金额乘一个系数，如果是上班时的工作餐，就打六折；如果是加班时的工作餐，就打五折；如果是休息日来就餐，就打九折。首先打开“工具”菜单，单击“宏”命令中的“Visual Basic编辑器”，进入Visual Basic编辑环境，在“工程－VBAobject”栏中的当前表上单击鼠标右键，选择“插入”-“模块”，在右边栏创建下面的函数rrr，代码如下： Function rrr(tatol, rr) If rr = &quot;上班&quot; Then rrr = 0.6 * tatol ElseIf rr = &quot;加班&quot; Then rrr = 0.5 * tatol ElseIf rr = &quot;休息日&quot; Then rrr = 0.9 * tatol End If End Function （如图9）。 图９  这时关闭编辑器，只要我们在相应的列中输入rrr(F２，B２)，那么打完折后的金额就算出来了（如图10）。 图10  \n\n7、矩阵计算 Excel的强大计算功能，不但能够进行简单的四则运算，也可以进行数组、矩阵的计算。 （1）数组和矩阵的定义 　　 矩阵不是一个数，而是一个数组。在Excel里，数组占用一片单元域，单元域用大括号表示，例如{A1：C3}，以便和普通单元域A1：C3相区别。设置时先选定单元域，同时按Shift＋Ctrl＋Enter键，大括弧即自动产生，数组域得以确认。 　 一个单元格就是一个变量，一片单元域也可以视为一组变量。为了计算上的方便，一组变量最好给一个数组名。例如A={A1：C3}、B={E1:G3}等。数组名的设置步骤是：选定数组域，单击“插入”菜单，选择“名称”项中的“定义”命令，输入数组名，单击“确定”按钮即可。更简单的命名办法为：选择数组域，单击名称框，直接输入名称就行了。 　　 矩阵函数是Excel进行矩阵计算的专用模块。用“插入”－“函数”命令打开“粘贴函数”对话框（如图11），选中函数分类栏中的“数学与三角函数”，在右边栏常用的矩阵函数有： MDETERM——计算一个矩阵的行列式； MINVERSE——计算一个矩阵的逆矩阵； MMULT——计算两个矩阵的乘积； SUMPRODUCT——计算所有矩阵对应元素乘积之和。 图11  （2）矩阵的基本计算 　　 数组计算和矩阵计算有很大的区别，比如下面这个例子中，A和B都是定义好的数组，因为这两个数组都是3&times;3的，输出结果也是3&times;3个单元格。计算时先选定矩阵计算结果的输出域，为3&times;3的单元格区域，然后输入公式。如果输入“=A＋B”或“=A-B”，计算结果是数组对应项相加或相减，输入“=A*B”表示数组A和B相乘，输入“=A/B”表示数组A除数组B。如果要进行矩阵计算，就要用到相应的矩阵函数。矩阵相加、相减与数组的加减表达形式是一样的，也是“=A＋B”和“=A-B”，表示矩阵相乘可以输入“=MMULT(A，B)”，而矩阵相除是矩阵A乘B的逆矩阵，所以计算公式是“=MMULT(A，MINVERSE（B）)”。公式输入后，同时按Shift＋Ctrl＋Enter键得到计算结果。 对于更复杂的矩阵计算，可以采用分步计算。 \n\n8、自动切换输入法 在一张工作表中，往往是既有数据，又有文字，这样在输入时就需要来回在中英文之间反复切换输入法，非常麻烦。 如果你要输入的东西很有规律性，比如这一列全是单词，下一列全是汉语解释，你可以用以下方法实现自动切换。方法是： （1）选中要输入英文的列，单击“数据”菜单，选择“有效性...”命令，在弹出的“数据有效性”对话框中，选中“输入法模式”选项卡，在“模式”框中选择“关闭（英文模式）”命令，单击“确定”按钮（如图12）。 图12  （2）选中要输入汉字的列，在“有效数据”对话框中，单击“IME模式”选项卡，在“模式”框中选择“打开”命令，单击“确定”按钮。这样，当光标在前一列时，可以输入英文，在下一列时，直接可以输入中文，从而实现了中英文输入方式之间的自动切换。 \n\n9、批量删除空行 有时我们需要删除Excel工作薄中的空行，一般做法是将空行一一找出，然后删除。如果工作表的行数很多，这样做就非常不方便。我们可以利用“自动筛选”功能，把空行全部找到，然后一次性删除。 做法：先在表中插入新的一个空行，然后按下Ctrl+A键，选择整个工作表，用鼠标单击“数据”菜单，选择“筛选”项中的“自动筛选”命令。这时在每一列的顶部，都出现一个下拉列表框，在典型列的下拉列表框中选择“空白”，直到页面内已看不到数据为止（如图13）。 图13  在所有数据都被选中的情况下，单击“编辑”菜单，选择“删除行”命令，然后按“确定”按钮。这时所有的空行都已被删去，再单击“数据”菜单，选取“筛选”项中的“自动筛选”命令，工作表中的数据就全恢复了。插入一个空行是为了避免删除第一行数据。 如果想只删除某一列中的空白单元格，而其它列的数据和空白单元格都不受影响，可以先复制 此列，把它粘贴到空白工作表上，按上面的方法将空行全部删掉，然后再将此列复制，粘贴到原工作表的相应位置上。 \n\n10、如何避免错误信息 在Excel中输入公式后，有时不能正确地计算出结果，并在单元格内显示一个错误信息，这些错误的产生，有的是因公式本身产生的，有的不是。下面就介绍一下几种常见的错误信息，并提出避免出错的办法。 １）错误值：＃＃＃＃ 　　 含义：输入到单元格中的数据太长或单元格公式所产生的结果太大，使结果在单元格中显示不下。或是日期和时间格式的单元格做减法，出现了负值。 解决办法：增加列的宽度，使结果能够完全显示。如果是由日期或时间相减产生了负值引起的，可以改变单元格的格式，比如改为文本格式，结果为负的时间量。 　　 ２）错误值：＃DIV/0! 　　 含义：试图除以0。这个错误的产生通常有下面几种情况：除数为0、在公式中除数使用了空单元格或是包含零值单元格的单元格引用。 解决办法：修改单元格引用，或者在用作除数的单元格中输入不为零的值。 　　 ３）错误值：＃VALUE! 　　 含义：输入引用文本项的数学公式。如果使用了不正确的参数或运算符，或者当执行自动更正公式功能时不能更正公式，都将产生错误信息＃VALUE!。 　　 解决办法：这时应确认公式或函数所需的运算符或参数正确，并且公式引用的单元格中包含有效的数值。例如，单元格C4中有一个数字或逻辑值，而单元格D4包含文本，则在计算公式=C4＋D4时，系统不能将文本转换为正确的数据类型，因而返回错误值＃VALUE!。 　　 ４）错误值：＃REF! 　　 含义：删除了被公式引用的单元格范围。 解决办法：恢复被引用的单元格范围，或是重新设定引用范围。 ５）错误值：＃N/A 　　 含义：无信息可用于所要执行的计算。在建立模型时，用户可以在单元格中输入#N/A，以表明正在等待数据。任何引用含有#N/A值的单元格都将返回#N/A。 解决办法：在等待数据的单元格内填充上数据。 ６）错误值：＃NAME? 　　 含义：在公式中使用了Excel所不能识别的文本，比如可能是输错了名称，或是输入了一个已删除的名称，如果没有将文字串括在双引号中，也会产生此错误值 解决办法：如果是使用了不存在的名称而产生这类错误，应确认使用的名称确实存在；如果是名称，函数名拼写错误应就改正过来；将文字串括在双引号中；确认公式中使用的所有区域引用都使用了冒号（：）。例如：SUM（C1：C10）。 　　注意将公式中的文本括在双引号中。 ７）错误值：＃NUM! 含义：提供了无效的参数给工作表函数，或是公式的结果太大或太小而无法在工作表中表示。 解决办法：确认函数中使用的参数类型正确。如果是公式结果太大或太小，就要修改公式，使其结果在-1&times;10307和1&times;10307之间。 ８）错误值：＃NULL！ 含义：在公式中的两个范围之间插入一个空格以表示交叉点，但这两个范围没有公共单元格。比如输入：“=SUM(A1:A10 C1:C10)”，就会产生这种情况。 解决办法： 取消两个范围之间的空格。上式可改为“=SUM(A1:A10 ,C1:C10)” \n\n11、宏的应用 宏是一个指令集，用来告诉EXCEL来完成用户指定的动作。宏类似于计算机程序，但是它是完全运行于EXCEL之中的，我们可以使用宏来完成枯燥的、频繁的重复性工作。 宏完成动作的速度比用户自己做要快得多。例如，我们可以创建一个宏，用来在工作表的每一行上输入一组日期，并在每一单元格内居中对齐日期，然后对此行应用边框格式。我们还可以创建一个宏，在“页面设置”对话框中指定打印设置并打印文档。 由于宏病毒的影响和对编程的畏惧心理，使很多人不敢用“宏”，或是不知道什么时候可以找宏来帮忙。其实你尽管放心大胆地去用，如果只是用“录制宏”的方法，根本就没有什么难的，只是把一些操作象用录音机一样录下来，到用的时候，只要执行这个宏，系统就会把那操作再执行一遍。 下面给出了宏的应用场合，只要用“录制宏”就可以帮你完成任务，而不需要编程。如果想对所录制的宏再进行编辑，就要有一定的VBA知识了。 * 设定一个每个工作表中都需要的固定形式的表头； * 将单元格设置成一种有自己风格的形式； * 每次打印都固定的页面设置； * 频繁地或是重复地输入某些固定的内容，比如排好格式的公司地址、人员名单等； * 创建格式化表格； * 插入工作表或工作薄等。 需要指出的是，EXCEL中的宏与WORD中的宏有些不同之处，对于录制的操作，它会记住单元格的坐标（即所有的引用都是绝对的），所以在涉及到与位置有关的操作时，要格外注意。如果相用相对引用，可以借助于Offset方法，比如下面的语句： ActiveCell.Offset(1,0). range(&quot;A1&quot;).select 宏的应用是很广的，上面提到的只是一点点，如果真的用起来，你会发现它有更丰富的内容和更灵活的应用方法。 \n\n12、图表的应用技巧 Excel提供了14种标准的图表类型，每一种都具有多种组合和变换。在众多的图表类型中，选用那一种图表更好呢？ 根据数据的不同和使用要求的不同，可以选择不同类型的图表。图表的选择主要同数据的形式有关，其次才考虑感觉效果和美观性。 下面给出了一些常见的规则。 面积图：显示一段时间内变动的幅值。当有几个部分正在变动，而你对那些部分总和感兴趣时，他们特别有用。面积图使你看见单独各部分的变动，同时也看到总体的变化。 条形图：由一系列水平条组成。使得对于时间轴上的某一点，两个或多个项目的相对尺寸具有可比性。比如：它可以比较每个季度、三种产品中任意一种的销售数量。条形图中的每一条在工作表上是一个单独的数据点或数。因为它与柱形图的行和列刚好是调过来了，所以有时可以互换使用。 柱形图：由一系列垂直条组成，通常用来比较一段时间中两个或多个项目的相对尺寸。例如：不同产品季度或年销售量对比、在几个项目中不同部门的经费分配情况、每年各类资料的数目等。条形图是应用较广的图表类型，很多人用图表都是从它开始的。 折线图：被用来显示一段时间内的趋势。比如：数据在一段时间内是呈增长趋势的，另一段时间内处于下降趋势，我们可以通过折线图，对将来作出预测。例如：速度-时间曲线、推力-耗油量曲线、升力系数-马赫数曲线、 压力-温度曲线、疲劳强度-转数曲线、转输功率代价-传输距离曲线等，都可以利用折线图来表示，一般在工程上应用较多，若是其中一个数据有几种情况，折线图里就有几条不同的线，比如五名运动员在万米过程中的速度变化，就有五条折线，可以互相对比，也可以对添加趋势线对速度进行预测。 股价图：是具有三个数据序列的折线图，被用来显示一段给定时间内一种股标的最高价、最低价和收盘价。通过在最高、最低数据点之间画线形成垂直线条，而轴上的小刻度代表收盘价。股价图多用于金融、商贸等行业，用来描述商品价格、货币兑换率和温度、压力测量等，当然对股价进行描述是最拿手的了。 饼形图：在用于对比几个数据在其形成的总和中所占百分比值时最有用。整个饼代表总和，每一个数用一个楔形或薄片代表。比如：表示不同产品的销售量占总销售量的百分比，各单位的经费占总经费的比例、收集的藏书中每一类占多少等。饼形图虽然只能表达一个数据列的情况，但因为表达得清楚明了，又易学好用，所以在实际工作中用得比较多。如果想多个系列的数据时，可以用环形图。 雷达图：显示数据如何按中心点或其他数据变动。每个类别的坐标值从中心点辐射。来源于同一序列的数据同线条相连。你可以采用雷达图来绘制几个内部关联的序列，很容易地做出可视的对比。比如：你有三台具有五个相同部件的机器，在雷达图上就可以绘制出每一台机器上每一部件的磨损量。 XY散点图：展示成对的数和它们所代表的趋势之间的关系。对于每一数对，一个数被绘制在X轴上，而另一个被绘制在Y轴上。过两点作轴垂线，相交处在图表上有一个标记。当大量的这种数对被绘制后，出现一个图形。散点图的重要作用是可以用来绘制函数曲线，从简单的三角函数、指数函数、对数函数到更复杂的混合型函数，都可以利用它快速准确地绘制出曲线，所以在教学、科学计算中会经常用到。 还有其他一些类型的图表，比如圆柱图、圆锥图、棱锥图，只是条形图和柱形图变化而来的，没有突出的特点，而且用得相对较少，这里就不一一赘述。这里要说明的是：以上只是图表的一般应用情况，有时一组数据，可以用多种图表来表现，那时就要根据具体情况加以选择。 对有些图表，如果一个数据序列绘制成柱形，而另一个则绘制成折线图或面积图，则该图表看上去会更好些。 在EXCE中L允许这创建这样的组合图表，但如果想创建一种EXCEL不允许的组合图表类型，比如不可能将一个二维图同一个三维图表混在一起，这种组合是不可能的，系统就会显示错误信息。怎么建立混合图表呢？单击“图表向导”按钮，选择“自定义类型”选项卡，这里还躲着二十种图表类型（如图14），也有各种组合形式。如果你对这些内部定义的形式还不满意，就单击“自定义”选项钮，按照向导自己定义全新的图表类型。\n\n        ', null);
INSERT INTO `blog` VALUES ('111', '办公室——教你如何把打印稿变成电子稿（太牛啦！！你打一天的字都比不上她2分钟！！人手一份，留着以后用哈！）', '\n            \n \n\n办公室——教你如何把打印稿变成电子稿（太牛啦！！你打一天的字都比不上她2分钟！！人手一份，留着以后用哈！） \n&nbsp;&nbsp;&nbsp; 注意：&nbsp;&nbsp;&nbsp;&nbsp; \n&nbsp;\n&nbsp; 教你如何将打印稿变成电子稿最近，我的一个刚刚走上工作岗位上的朋友老是向我报怨，说老板真的是不把我们这些新来工作的人不当人看啊，什么粗活都是让我们 做，这不，昨天又拿了10几页的文件拿来，叫他打成电子稿，他说都快变成打字工具了，我听之后既为他感到同情，同时教给他一个简单的方法，可以轻松将打印 稿变成电子稿，我想以后对大家也有用吧，拿出来给大家分享一下。 \n首先你得先把这些打印稿或文件通过扫描仪扫到电脑上去，一般单位都有扫描仪，如果没有也没关系，用数码相机拍也行，拍成图片放到WORD里面去，不过在些 之前，你还得装一下WORD自带的组件，03和07的都行。点开始-程序-控制面板-添加/删除程序，找到Office-修改 找到Microsoft Office Document Imaging 这个组件，Microsoft Office Document Imaging Writer 点在本机上运行，安装就可以了。 \n首先将扫描仪安装好，接下来从开始菜单启动“Microsoft Office/ Microsoft Office 工具/Microsoft Office Document Scanning”即可开始扫描。 　　 \n提示:Office 2003默认安装中并没有这个组件，如果你第一次使用这个功能可能会要求你插入Office2003的光盘进行安装。 由于是文字扫描通常我们选择“黑白模式”，点击扫描，开始调用扫描仪自带的驱动进行扫描。这里也要设置为“黑白模式”，建议分辨率为300dpi。扫 描完毕后回将图片自动调入Office 2003种另外一个组件“Microsoft Office Document Imaging”中。 　　 \n点击工具栏中的“使用OCR识别文字”按键，就开始对刚才扫描的文件进行识别了。按下“将文本发送到Word”按键即可将识别出来的文字转换到 Word中去了。如果你要获取部分文字，只需要用鼠标框选所需文字，然后点击鼠标右键选择“将文本发送到Word”就将选中区域的文字发送到Word中 了。 \n&nbsp;\n此软件还有一小技巧：通过改变选项里的OCR语言，可以更准确的提取文字。例如图片里为全英文，把OCR语言改为“英语”可以确保其准确率，而如果是“默认”则最终出现的可能是乱码～\n&nbsp;\n还有：\n应该说，PDF文档的规范性使得浏览者在阅读上方便了许多，但倘若要从里面提取些资料，实在是麻烦的可以。回忆起当初做毕业设计时规定的英文翻译，痛苦的要命，竟然傻到用Print Screen截取画面到画图板，再回粘到word中，够白了：（最近连做几份商务标书，从Honeywell本部获取的业绩资料全部是英文版的PDF，为了不再被折磨，花费了一个晚上的时间研究PDF和Word文件的转换，找到下面2种方法，出于无产阶级所谓的同甘共苦之心，共享下：） \n&nbsp;\n1、实现工具：Office 2003中自带的Microsoft Office Document Imaging \n&nbsp;\n应用情景：目前国外很多软件的支持信息都使用PDF方式进行发布，如果没有Adobe Reader，无法查看其内容，如果没有相关的编辑软件又无法编辑PDF文件。转换为DOC格式则可以实现编辑功能。尽管有些软件也可以完成PDF转换为DOC的工作，但很多都不支持中文，我们利用Office 2003中的Microsoft Office Document Imaging组件来实现这一要求最为方便。 \n　　使用方法： \n　　第一步：首先使用Adobe Reader打开待转换的PDF文件，接下来选择“文件→打印”菜单，在打开的“打印”设置窗口中将“打印机”栏中的“名称”设置为“Microsoft Office Document Image Writer”，确认后将该PDF文件输出为MDI格式的虚拟打印文件。 \n　　编辑提示：如果你在“名称”设置的下拉列表中没有找到“Microsoft Office Document Image Writer”项，那证明你在安装Office 2003的时候没有安装该组件，请使用Office 2003安装光盘中的“添加/删除组件”更新安装该组件。 \n　　第二步：运行Microsoft Office Document Imaging，并利用它来打开刚才保存的MDI文件，选择“工具→将文本发送到Word”菜单，并在弹出的窗口中勾选“在输出时保持图片版式不变”，确认后系统提示“必须在执行此操作前重新运行OCR。这可能需要一些时间”，不管它，确认即可。\n&nbsp;\n　　编辑提示：目前，包括此工具在内的所有软件对PDF转DOC的识别率都不是特别完美，而且转换后会丢失原来的排版格式，所以大家在转换后还需要手工对其进行后期排版和校对工作。 \n&nbsp;\n2、实现工具：Solid Converter PDF \n&nbsp;\n应用情景：利用Office 2003中的Microsoft Office Document Imaging组件来实现PDF转Word文档在一定程度上的确可以实现PDF文档到Word文档的转换，但是对于很多“不规则”的PDF文档来说，利用上面的方法转换出来的Word文档中常常是乱码一片。为了恢复PDF的原貌，推荐的这种软件可以很好地实现版式的完全保留，无需调整，而且可以调整成需要的样板形式。 \n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用方法：&nbsp; \n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、下载安装文件Solid Converter PDF,点击安装。 \n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 编辑提示：安装前有个下载安装插件的过程，因此需要保证网络连接通畅。 \n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、运行软件，按工具栏要求选择需要转换的PDF文档，点击右下的“转换”（Convert）按扭，选择自己需要的版式，根据提示完成转换\n\n        ', null);

-- ----------------------------
-- Table structure for channel
-- ----------------------------
DROP TABLE IF EXISTS `channel`;
CREATE TABLE `channel` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(50) default NULL,
  `father_id` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of channel
-- ----------------------------
INSERT INTO `channel` VALUES ('142', '栏目一', null);
INSERT INTO `channel` VALUES ('178', '栏目二', null);
INSERT INTO `channel` VALUES ('180', '栏目三', null);
INSERT INTO `channel` VALUES ('181', '栏目四', null);

-- ----------------------------
-- Table structure for price
-- ----------------------------
DROP TABLE IF EXISTS `price`;
CREATE TABLE `price` (
  `id` int(11) NOT NULL auto_increment,
  `10` int(11) default NULL,
  `20` int(11) default NULL,
  `30` int(11) default NULL,
  `50` int(11) default NULL,
  `100` int(11) default NULL,
  `200-500` int(11) default NULL,
  `other` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of price
-- ----------------------------

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role` (
  `id` int(11) NOT NULL auto_increment,
  `role` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of role
-- ----------------------------
INSERT INTO `role` VALUES ('1', '1');
INSERT INTO `role` VALUES ('2', '2');

-- ----------------------------
-- Table structure for supplier
-- ----------------------------
DROP TABLE IF EXISTS `supplier`;
CREATE TABLE `supplier` (
  `id` int(11) NOT NULL auto_increment,
  `province` varchar(100) default NULL,
  `city` varchar(100) default NULL,
  `supplier` varchar(255) default NULL,
  `port` varchar(255) default NULL,
  `serviceformat` varchar(255) default NULL,
  `price_id` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of supplier
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL auto_increment,
  `username` varchar(50) default NULL,
  `password` varchar(60) default NULL,
  `fullName` varchar(30) default NULL,
  `sex` varchar(10) default NULL,
  `role_id` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('4', 'admin', '6E4EEE8E391A062865CE4F2FDDCB115C', '林晓生', '0', '1');
